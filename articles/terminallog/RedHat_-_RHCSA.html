<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<style>
			.code-block {
				display: block;
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
				text-align: left;
			}
			.code-inline {
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
			}
			ul {
				text-align: left;
			}
      .toc {
        list-style-type: none;
      }
      p {
        text-align: justify;
      }
      .exam_tip {
        border: solid 1px black;
      }
		</style>
	</head>
	<body style="font-family: monospace;" >
<pre>
 ____          _ _   _       _   
|  _ \ ___  __| | | | | __ _| |_ 
| |_) / _ \/ _` | |_| |/ _` | __|
|  _ &lt;  __/ (_| |  _  | (_| | |_ 
|_| \_\___|\__,_|_| |_|\__,_|\__|
                                 
</pre>
    <p style="margin: 0; padding: 0; outline: 0; font-size: 18pt;">
	    &#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
    </p>
		<div style="margin-left: auto; margin-right: auto; width: 80%;">
      <h1 style="text-align: center;">RedHat - Red Hat Certified System 
        Administrator 9</h1>
      <h2>Spis treści</h2>
      <ul class="toc">
        <li><a href="#1.introduction">1. Wstęp</a>
          <ul class="toc">
            <li><a href="#1.1.exam">1.1. Egzamin</a></li>
            <li><a href="#1.2.examobjectives">1.2. Zagadnienia</a></li>
            <li><a href="#1.3.exampreparation">1.3. Przygotowania</a>
              <ul class="toc">
                <li><a href="#1.3.1.vboxinstallationonrhel">1.3.1. Instalacja Oracle VirtualBox na RHEL 8.6.</a></li>
                <li><a href="#1.3.2.gettingrheliso">1.3.2. Pozyskiwanie obrazu ISO z Red Hat Enterprise Linux 9</a></li>
                <li><a href="#1.3.3.createvmwithrhel">1.3.3. Tworzenie maszyn wirtualnych VirtualBox z RHEL</a></li>
                <li><a href="#1.3.4.rhelinstallation">1.3.4. Instalacja Red Hat Enterprise Linux 9.0</a></li>
              </ul> 
            <li><a href="#exec1.1">Ćwiczenie: 1-1</a></li>
            <li><a href="#exec1.2">Ćwiczenie: 1-2</a></li>
            <li><a href="#ch1summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#2.firststepsinRHEL9">2. Poruszanie się po systemie RHEL 9</a>
          <ul class="toc">
            <li><a href="#2.1.serverwithgui">2.1. Środowisko graficzne RHEL 9</a></li>
            <li><a href="#2.2.hfs">2.2. Struktura katalogowa w Uniksach</a></li>
            <li><a href="#2.3.usingcli">2.3. Obsługa wiersza poleceń i najprostsze polecenia</a>
              <ul class="toc">
                <li><a href="#2.3.1.ls">2.3.1. Listowanie zawartości katalogu</a></li>
                <li><a href="#2.3.2.pwd">2.3.2. Wyświetlanie bierzącego katalogu</a></li>
                <li><a href="#2.3.3.cd">2.3.3. Poruszanie się wśród katalogów</a></li>
                <li><a href="#2.3.4.tty">2.3.4. Identyfikacja urządzenia terminala</a></li>
                <li><a href="#2.3.5.uptime">2.3.5. Czas systemowy oraz załadowanie procesora</a></li>
                <li><a href="#2.3.6.clear">2.3.6. Czyszczenie ekranu powłoki</a></li>
                <li><a href="#2.3.7.which">2.3.7. Określanie ścieżki polecenia</a></li>
                <li><a href="#2.3.8.uname">2.3.8. Wyświetlenie informacji o systemie</a></li>
                <li><a href="#2.3.9.lscpu">2.3.9. Wyświetlenie informacji o procesorze</a></li>
              </ul>
            </li>
            <li><a href="#2.4.gettinghelp">2.4. Uzyskiwanie pomocy</a>
              <ul class="toc">
                <li><a href="#2.4.1.manpages">2.4.1. Strony podręcznika</a></li>
                <li><a href="#2.4.2.helpincommand">2.4.2. Pomoc w samym poleceniu</a></li>
                <li><a href="#2.4.3.texinfo">2.4.3. Dokumentacja texinfo</a></li>
                <li><a href="#2.4.4.usrsharedoc">2.4.4. /usr/share/doc</a></li>
                <li><a href="#2.4.5.rhdocs">2.4.5. Dokumentacja Red Hat Enterprise Linux</a></li>
              </ul>
            </li>
            <li><a href="#exec2.1">Ćwiczenie: 2-1</a></li>
            <li><a href="#exec2.2">Ćwiczenie: 2-2</a></li>
            <li><a href="#exec2.3">Ćwiczenie: 2-3</a></li>
            <li><a href="#exec2.4">Ćwiczenie: 2-4</a></li>
            <li><a href="#ch2summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#3.fileoperations">3. Operacje na plikach</a>
          <ul class="toc">
            <li><a href="#3.1.filetypes">3.1. Rodzaje plików</a>
            <li><a href="#3.2.compressionandarchiving">3.2. Kompresja i archiwizowanie</a>
              <ul class="toc">
                <li><a href="#3.2.1.gzip">3.2.1. gzip</a></li>
                <li><a href="#3.2.2.bzip">3.2.2. bzip2</a></li>
                <li><a href="#3.2.3.tar">3.2.3. tar</a></li>
              </ul>
            </li>
            <li><a href="#3.3.vim">3.3. Edycja plików za pomocą edytora Vim</a>
              <ul class="toc">
                <li><a href="#3.3.1.startingvim">3.3.1. Podstawy obsługi Vim</a></li>
                <li><a href="#3.3.2.othervimcommands">3.3.2. Pozostałe polecenia Vim</a></li>
              </ul>
            </li>
            <li><a href="#3.4.filesanddirectories">3.4. Pliki i katalogi</a>
              <ul class="toc">
                <li><a href="#3.4.1.createfilesanddirs">3.4.1. Tworzenie plików i katalogów</a></li>
                <li><a href="#3.4.2.listingfiles">3.4.2. Wyświetlanie zawartości pliku</a></li>
                <li><a href="#3.4.3.copyingandmoving">3.4.3. Kopiowanie i przenoszenie plików</a></li>
                <li><a href="#3.4.5.removefilesanddirs">3.4.5. Usuwanie plików i katalogów</a></li>
              </ul>
            </li>
            <li><a href="#3.5.links">3.5. Dowiązania</a>
              <ul class="toc">
                <li><a href="#3.5.1.hardlinks">3.5.1. Dowiązanie twarde</a></li>
                <li><a href="#3.5.2.symlinks">3.5.2. Dowiązanie symboliczne</a></li>
              </ul>
            </li>
            <li><a href="#exec3.1">Ćwiczenie 1: Archiwa</a></li>
            <li><a href="#exec3.2">Ćwiczenie 2: Praktyka z Vim-a</a></li>
            <li><a href="#exec3.3">Ćwiczenie 3: Manipulacja plikami</a></li>
            <li><a href="#ch3summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#4.advancedfilemanagement">4. Zaawansowane zarządzania plikami</a>
          <ul class="toc">
            <li><a href="#4.1.basicspermission">4.1. Uprawnienia podstawowe</a>
              <ul class="toc">
                <li><a href="#4.1.1.defaultpermissions">4.1.1. Uprawnienia domyślne</a></li>
                <li><a href="#4.1.2.changefileowner">4.1.2. Zmiana właściciela oraz grupy pliku</a></li>
              </ul>
            </li>
            <li><a href="#4.2.specialpermissions">4.2. Uprawnienia specjalne</a>
              <ul class="toc">
                <li><a href="#4.2.1.setuid">4.2.1. Uprawnienia bitu setuid</a></li>
                <li><a href="#4.2.2.setgid">4.2.2. Uprawnienia bitu setgid</a></li>
                <li><a href="#4.2.3.stickybit">4.2.3. Uprawnienia bitu sticky</a></li>
              </ul>
            </li>
            <li><a href="#4.3.find">4.3. Polecenie find</a>
              <ul class="toc">
                <li><a href="#4.3.1.actionoptions">4.3.1. Opcje akcji polecenia find</a></li>
              </ul>
            </li>
            <li><a href="#4.4.acl">4.4. Lista kontroli dostępu</a>
              <ul class="toc">
                <li><a href="#4.4.1.defaultacl">4.4.1. Domyślne listy kontroli dostępu</a></li>
                <li><a href="#4.4.2.aclbug">4.4.2. Dziwny problem z listami kontroli dostępu</a></li>
              </ul>
            </li>
            <li><a href="#exec4.1">Ćwiczenie 1: Manipulowanie uprawnieniami pliku</a></li>
            <li><a href="#exec4.2">Ćwiczenie 2: Konfiguracja katalogu do pracy grupowej</a></li>
            <li><a href="#exec4.3">Ćwiczenie 3: Wyszukiwanie plików</a></li>
            <li><a href="#exec4.4">Ćwiczenie 4: Zaawansowane wyszukiwanie plików</a></li>
            <li><a href="#exec4.5">Ćwiczenie 5: Ustawianie list dostępu</a></li>
            <li><a href="#ch4summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#5.userbasics">5. Podstawy zarządzania użytkownikami</a>
          <ul class="toc">
            <li><a href="#5.1.whoandw">5.1. Kto jest zalogowany do systemu i co robi</a>
              <ul class="toc">
                <li><a href="#5.1.1.loginattempts">5.1.1. Monitorowanie prób logowania się do systemu</a></li>
                <li><a href="#5.1.2.idandgroup">5.1.2. Informacje o użytkowniku</a></li>
              </ul>
            </li>
            <li><a href="#5.2.userauthfiles">5.2. Pliki autentykacji użytkowników</a>
              <ul class="toc">
                <li><a href="#5.2.1.passwdfile">5.2.1. Pliki /etc/passwd</a></li>
                <li><a href="#5.2.2.shadowfile">5.2.2. Plik /etc/shadow</a></li>
                <li><a href="#5.2.3.group">5.2.3. Plik /etc/group</a></li>
                <li><a href="#5.2.4.gshadowfile">5.2.4. Plik /etc/gshadow</a></li>
              </ul>
            </li>
            <li><a href="#5.3.basicsofusermanagement">5.3. Podstawy zarządzania użytkownikami</a>
              <ul class="toc">
                <li><a href="#5.3.1.usersdefaultinformations">5.3.1. Domyślnie informacje użytkownikówa</li>
                <li><a href="#5.3.2.useradd">5.3.2. Tworzenie użytowników</a></li>
                <li><a href="#5.3.3.usermod">5.3.3. Zmiana informacji użytkownika</a></li>
                <li><a href="#5.3.4.userdel">5.3.4. Usuwanie użytkowników</a></li>
                <li><a href="#5.3.5.nologinusers">5.3.5. Użytkownicy bez możliwości logowania</a></li>
              </ul>
            </li>
            <li><a href="#exec5.1">Ćwiczenie 1</a></li>
            <li><a href="#exec5.2">Ćwiczenie 2</a></li>
            <li><a href="#exec5.3">Ćwiczenie 3</a></li>
            <li><a href="#exec5.4">Ćwiczenie 4</a></li>
            <li><a href="#ch5summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#6.advancedusermanagement">6. Zaawansowane zarządzanie użytkownikami</a>
          <ul class="toc">
            <li><a href="#6.1.passwordaging">6.1. Zasady ważności hasła</a></li>
            <li><a href="#6.2.groupmanaging">6.2. Zarządzanie grupami</a>
              <ul class="toc">
                <li><a href="#6.2.1.groupadd">6.2.1. Tworzenie nowych grup</a></li>
                <li><a href="#6.2.2.groupmod">6.2.2. Zmiana informacji grupy</a></li>
                <li><a href="#6.2.3.groupdel">6.2.3. Usuwanie grup</a></li>
              </ul>
            </li>
            <li><a href="#6.3.suandsudo">Przełączanie użytkowników oraz uruchamianie poleceń jako superużytkownik</a>
              <ul class="toc">
                <li><a href="#6.3.1.su">6.3.1. Przełącznie użytkownika</a></li>
                <li><a href="#6.3.2.sudo">6.3.2. Polecenie sudo</a></li>
              </ul>
            </li>
            <li><a href="#6.4.chownchgrp">6.4. Zmiana praw własności plików i katalogów</a></li>
          </ul>
        </li>
        <li><a href="#7.bashshell">7. Powłoka BASH</a>
          <ul class="toc">
            <li><a href="#7.1.bashfeatures">7.1. Funkcje powłoki BASH</a>
              <ul class="toc">
                <li><a href="#7.1.1.variables">7.1.1. Zmienne</a></li>
                <li><a href="#7.1.2.commandsubstitution">7.1.2. Podstawienie polecenia</a></li>
                <li><a href="#7.1.3.streamredirections">7.1.3. Przekierowanie strumieni</a></li>
                <li><a href="#7.1.4.history">7.1.4. Historia poleceń</a></li>
                <li><a href="#7.1.5.editingcli">7.1.5. Edycja wiersza polecenia</a></li>
                <li><a href="#7.1.6.commandcompletion">7.1.6. Uzupełnianie poleceń</a></li>
                <li><a href="#7.1.7.tilde">7.1.7. Podstawienie tyldy</a></li>
                <li><a href="#7.1.8.alias">7.1.8. Aliasy</a></li>
                <li><a href="#7.1.9.metacharacters">7.1.9. Metaznaki oraz nazwy wieloznaczne</a></li>
                <li><a href="#7.1.10.pipes">7.1.10. Potoki i polecenia potokowe</a></li>
                <li><a href="#7.1.11.quoting">7.1.11. Cytowanie</a></li>
                <li><a href="#7.1.12.regex">7.1.12. Wyrażenia regularne</a></li>
                <li><a href="#7.1.13.jobmanaging">7.1.13. Zarządzanie zadaniami</a></li>
              </ul>
            </li>
            <li><a href="#7.2.startupscripts">7.2. Pliki startowe powłoki</a>
              <ul class="toc">
                <li><a href="#7.2.1.systemwidefiles">7.2.1. Globalne pliki startowe powłoki</a></li>
                <li><a href="#7.2.2.usersfiles">7.2.2. Pliki startowe powłoki użytkownika</a></li>
              </ul>
            </li>
            <li><a href="#exec7.1">Ćwiczenie 1</a></li>
            <li><a href="#exec7.2">Ćwiczenie 2</a></li>
            <li><a href="#ch7summary">Podsumowanie</a></li>
          </ul>
        </li>
      </ul>
      <h1 id="1.introduction">1. Wstęp</h1>
      <p>
        Chcąc zmienić coś w swoim życiu postanowiłem, że zacznę od pracy.
        Dalej chciałem pracować w IT, tylko na innym stanowisku (praca 
        szkolnego administratora
        jest porównywalna z pracą technika IT, tu ma ktoś problem z systemem,
        tu trzeba podłączyć rzutnik, szczerze to znudziła się praca tego 
        typu).  Dobrze czułem się pracując z
        Linuksem, to była moja pasja. Znałem dwa stanowiska na których 
        mógłbym pracować: Linux System Administrator lub Linux System
        Engineer. Teraz na rynku pracy jeśli chodzi o IT ważniejsze są 
        uzyskane certyfikaty i odbyte kursy niż wykształcenie. Szukając 
        certyfikatów,
        które spowodują większe szanse na zatrudnienie, znalazłem dwa.
        Linux Fundation oraz Red Hat. Po przeczytaniu postu a na Reddit
        doszedłem do wniosku, że lepszym wyborem będzie Red Hat. Jeśli
        chodzi o produkcyjne wykorzystanie Linuksa to prym wśród firm
        wiedzie Red Hat lub jego darmowy odpowiednik. Kiedyś CentOS ale
        obecnie może być to zarówno Rocky Linux lub Alma Linux, oba są
        pochodnymi Red Hat. Szukając jakiś materiałów w internecie, które
        pomogły by mi się przygotować natrafiłem na Amazonie na książke
        Asghara Ghori pt. <em>RHCSA Red Hat Enterprise Linux 8 (UPDATED): 
        Training and Exam Preparation Guide (EX200), Second Edition</em>
        zamówiłem ją na swojego Kindla i zacząłem przygotowywać się do
        egzaminu. 
      </p>
      <h2 id="1.1.exam">1.1. Egzamin</h2>
      <p>
        Egzamin EX200 dający uprawnienia Red Hat Certified System
        Administrator jest egzamin praktycznym sprawdzającym umiejętność
        instalacji, konfiguracji oraz rozwiązywania podstawowych problemów
        administracyjnych na dystrybucji Red Hat. Egzamin będzie odbywać
        się w postaci elektronicznej i zdający będzie mięć do dyspozycji
        dwie maszyny wirtualne do wykonania zadań egzaminacyjnych. Takie
        też środowisko przygotujemy sobie do nauki. Na dzień 11 listopada
        2020 (tak jak podaje książka) egzamin obejmować 69 zagadnień jednak
        ta liczba, ze względu na rozwój technologii jak i samego Red Hata
        mogła ulec już zmianie.
      </p>
      <h2 id="1.2.examobjectives">1.2. Zagadnienia</h2>
      <p>
        Zagadnienia używane na egzaminie mogą cały czas ewoluować. Odnośnik
        obok przedstawia aktualne zagadnienia egzaminacyjne.
        <a href="http://www.redhat.com/training/courses/ex200/examobjective">http://www.redhat.com/training/courses/ex200/examobjective</a>. Obecnie egzamin zadawany jest na
        RHEL 9, wydany 17 maja 2022. Dość istotną zmianą w produkcji tego
        systemu jest zmiana <em>upstreamu</em>. Ta wersja Red Hat nie jest
        już oparta na Fedorze tak jak wszystkie do tej pory, ale na CentOS
        Stream (nowa wersja non-stream tej dystrybucji nie jest już dostępna 
        stąd
        rozbicie społeczonościowych dystrybucji do zastosowań produkcyjnych na
        Rocky oraz Alma Linux) i tej wersji będziemy użwać na maszynach
        wirtualnych.
      </p>
      <h2 id="1.3.exampreparation">1.3. Przygotowania</h2>
      <p>
        Kiedy uznałem, że chce zdobyć RHCSA, uzyskałem Red Hat na zasadzie
        <em>Non-cost RHEL Individual Developer Subscription</em>, gdzie
        istotne informacje znajdują się w odnośniku obok.
        <a href="https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux">https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux</a>
        Przy użyciu tej subskrypcji uzyskamy dostęp do Red Hat przez rok na
        16 instalacji (bez znaczenia czy to fizyczny komputer, czy maszyna
        wirtualna). Po tym czasie należy zalogować się ponownie, zakceptować
        warunki umowy i po 15 do 30 minut powinnimy uzyskać ponowny rok
        subskrypcji i tak co roku. Wszystko jest opisane na powyższej stronie.
        System w wersji 8.6 (ponieważ na wersję 9.0, moim zdaniem jest
        za wcześnie, kiedyś zainstalowałem RHEL 8 na laptopie to non stop
        otrzymywałem jakieś raporty o błedach) zainstalowałem na komputerze
        codziennego użytku w pracownii. Najlepszym sposobem na nauczenie się
        administracji systemu jest jego używanie, a że jest entuzajstą a nie
        profesjonalistą, mój kontakt z systemami tego typu jest raczej dość
        mocno ograniczony. Dlatego też przesiadłem się na RHEL, póki co ten
        system poprostu działa, wcześniej korzystałem z Fedory 35 oraz
        Debiana 11. Do celów dydaktycznych potrzebujemy peceta lub laptopa
        z min. dwurdzeniowym procesorem, 8GB pamięci operacyjnej oraz 27GB
        wolnej przestrzeni na dysku na potrzeby utworzenia maszyn wirtualnych
        z wymagną przez ćwiczenia przestrzenią dyskową oraz możliwością
        wirtualizacji 64-bitowych systemów. Do tego celu 
        użyjemy oprogramowania Oracle VirtualBox, dającego najprostszy
        interfejs do interakcji z maszynami, gdyż przy późniejszych
        zagadnieniach będziemy musieli zmienić jej ustawienia lub dodać kilka
        urządzeń, oczywiście jeśli ktoś czuje się mocny w innych środowiskach
        może użyć swojego ulubionego, nie mniej jednak w trakcie nauki będzie
        trzeba dokonać kilku zmian w na tych maszynach, a opisy zamieszczone
        tutaj będą dotyczyć głównie VirtualBox. Czy ktoś zainstaluje na swoim 
        komputerze RHEL czy nie to,
        już indywidualna sprawa i nie wypłynie ona wykonanie ćwiczeń. Nie
        mniej jednak, w podpunkcie odnośnie maszyn wirtualnych tego rodziału
        przedstawie skrypt powłoki, który po uruchomieniu utworzy
        automatycznie maszyny wymagane do wykonania ćwiczeń. Ale póki co 
        przedstawie teraz instalacje Oracle VirtualBox na RHEL 8.6.
      </p>
      <h3 id="1.3.1.vboxinstallationonrhel">1.3.1. Instalacja Oracle VirtualBox 
        na RHEL 8.6</h3>
      <p>
        Pierwszą czynnością jest uruchomienie przeglądarki i przejście pod
        adres: <a href="https://www.virtualbox.org/wiki/Linux_Downloads">https://www.virtualbox.org/wiki/Linux_Downloads</a>, na samym dole strony znajdują się pliki repozytorium
        dla kilku dystrybucji Linuksa. Pobieramy ten przeznaczony dla RHEL
        następnie przenosimy go do wskazanego na stronie katalogu. Następnie
        możemy wydać polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        Po instalacji, przełączamy się w terminalu na użytkownika <em>root</em>.
        Następnie wydajemy poniższe polecenia:
      </p>
<pre class="code-block">
$ sudo su
# akmods
Checking kmods exist for 4.18.0-372.9.1.el8.x86_64         [  OK  ]
# systemctl restart vboxdrv.service
</pre>
      <p>
        Teraz Oracle VirtualBox jest gotów do działania.
      </p>
      <p>
        W przypadku RHEL 9, jeśli ktoś używa, to instalacja wydaje się jeszcze
        prostsza, gdyż do instalacji możemy użyć <strong>RPMFusion</strong>. Po 
        załadowaniu tych repozytoriów do swojego systemu możemy od razu wydać
        polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        W wersji 8.6, zapewne również możemy skorzystać z <em>RPMFusion</em>.
        Ja zanim się dowiedziałem że VirtualBox jest dostępny w tych
        repozytoriach, instalowałem go za pomocą instrukcji zawartej na stronie
        Virtualbox, do której link znajduje się powyżej.
      </p>
      <h3 id="1.3.2.gettingrheliso">1.3.2. Pozyskanie obrazu ISO z Red Hat 
        Enterprise Linux 9</h3>
      <p>
        Aby uzyskać takowy obraz musimy zarejestrować się w subskrypcji dla
        indywidualnych deweloperów. Przechodzimy na stronę <a href="https://developers.redhat.com/register">https://developers.redhat.com/register</a> i rejestrujemy się. Następnie
        logujemy i po zalogowaniu przechodzimy na stronę: <a href="https://developers.redhat.com/products/rhel/download">https://developers.redhat.com/products/rhel/download</a>.
        w sekcji <em>All Downloads</em> znajdują się wszystkie dostępne wersje
        Red Hat objęte jeszcze wsparciem. Nas będzie interesować wyłącznie
        wersja 9 i tą też pobieramy, oczywiście dla architektury <em>x86_64</em>
        w wersji DVD.
      </p>
      <h3 id="1.3.3.createvmwithrhel">1.3.3. Tworzenie maszyn wirtualnych 
        VirtualBox z RHEL</h3>
      <p>
        Tworzenie maszyn wirtualnych VirtualBox, nie jest zaganieniem
        egzaminacyjnym. Na egzaminie dostaniemy dostęp do dwóch zdalnych
        maszyn. Teoretycznie można by użyć fizycznych maszyn o ile ktoś ma
        do takowych dostęp, jednak do drugiej maszyny trzeba dodać aż 7 dysków,
        więc użycie wirtualnej maszyny, to chyba jedyne efektywne rozwiązanie. 
        Poniżej znajdują się wymagania jakie powinna spełniać każda z nich:
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
          <ul>
            <li>64-Bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor,</li>
            <li>1024 MB pamięci operacyjnej,</li>
            <li>10GB dysk twardy, wyłącznie na instalacje systemu,</li>
            <li>Karta sieciowa ustawiona na bridged.</li>
            <li>Nazwa hosta ustawiona na server1.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
        <li><strong>RHEL9-VM2</strong>:
          <ul>
            <li>64-bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor</li>
            <li>2048 MB pamięci operacyjnej</li>
            <li>10 GB dysk twardy, na instalacje systemu</li>
            <li>4 x 250 MB dysk twardy, dla ćwiczeń z LVM</li>
            <li>1 x 4 GB dysk twardy, dla ćwiczeń z VDO</li>
            <li>1 x 1 GB dysk twardy, dla ćwiczeń ze Stratis</li>
            <li>Nazwa hosta ustawiona na server2.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
      </ul>
      <p>
        Maszyny możemy utworzyć ręcznie, podążając za wskazówkami przewodnika,
        w przypadku drugiej maszyny dodatkowe dyski trzeba będzie dodać z
        poziomu ustawień maszyny. Drugą możliwością jest skorzystanie z dwóch
        poniższych skryptów kolejno dla
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM1";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;
$vboxmanage storagectl $vmname --name SATA0 --add sata;

$vboxmanage modifyvm $vmname --memory 1024;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";
</pre>
        </li>
        <li><strong>RHEL9-VM2</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM2";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/VDO.vdi" --size \
4096 --format VDI --variant Standard;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/Stratis.vdi" \
--size 1024 --format VDI --variant Standard;

$vboxmanage storagectl $vmname --name SATA0 --add sata;
$vboxmanage modifyvm $vmname --memory 2048;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";

$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";

i=2;
while [ $i -le 5 ]; do
  $vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi" --size \
  250 --format VDI --variant Standard;
  $vboxmanage storageattach $vmname --storagectl SATA0 --port $i --type hdd --medium \
  "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi";
  i=$((i + 1));
done

$vboxmanage storageattach $vmname --storagectl SATA0 --port 6 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/VDO.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 7 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/Stratis.vdi";
</pre>
        </li>
      </ul>
      <p>
        Powyższe skrypt są również dostępne na moim profilu na github-ie. Pod
        poniższymi linkami.
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh</a></li>
        <li><strong>RHEL9-VM2</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh</a></li>
      </ul>
      <p>
        Korzystając ze skryptów <strong>należy pamiętać o zmianie intefejsu
        sieciowego</strong> wykorzystywanego do mostkowania. Zmienna
        <code class="code-inline">bridge_if</code>.
      </p>
      <p>
        Po utworzeniu maszyn przyszedł czas na instalację.
      </p>
      <h3 id="1.3.4.rhelinstallation">1.3.4. Instalacja Red Hat Enterprise 
        Linux 9.0</h3>
      <p>
        Zaraz po uruchomieniu maszyny rozpocznie się proces ładowania
        zawartości płyty. Menu bootowania płyty zawiera trzy opcje. 
      </p>
      <ol>
        <li><em>Install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Test this media & install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Troubleshooting</em></li>
      </ol>
      <p>
        Domyślnie zaznaczoną jest opcja numer 2. Mamy minutę na zmianę
        decyzji. Naciśnięcie dowolnego klawisza zatrzymuje odliczanie. Dając
        nam czas do namysłu, jednak na ten moment nie co za bardzo rozmyślać
        dlatego też wybieramy opcję numer 1. Po wybraniu tej opcji nastąpi
        uruchomienie systemu oraz instalatora. Instalator używany przez RHEL 
        oraz dystrybucje z nim związane
        nazywa się <strong>Anaconda</strong>. Swoje działanie
        rozpoczyna jeszcze w trybie tekstowym, następnie domyślnie uruchamia
        tryb graficzny, gdzie odbywa się konfiguracja instalcji a następnie 
        już właściwa instalacja.
        Nie mniej jednak instalacja w trybie tekstowym jest również możliwa.
        Podczas instalacji, poza głównym instalatorem będziemy mieć do
        dyspozycji 
        multipekser terminala, który do momentu uruchomienia właściwego 
        instalatora (w wersji graficznej) był główną konsolą. W multiplekserze
        będzie my mieć dostęp do komunikatów diagnostyczny, które w wersji 8
        RHEL był wyświetlane na oddzielnych konsolach; kilka powłok z
        uprawnieniami superużytkownika (uruchomione na konsolach 2, 3 i 5) 
        oraz konsolę z komunikatami przechwytywanymi przez główny 
        rejestrator systemu <em>syslog</em>. Udostępnienie tych funkcjonalności
        podczas instalacji systemu, może pomóc w ewentualnym namierzeniu i
        naprawie problemów z instalacją.
        Pliki z komunikatami na czas instalacji przechowywane są w katalogu 
        <em>/tmp</em>, po instalacji zostaną one przeniesione do katalogu
        <em>/var/log/anaconda</em>. Według mnie jest dość przydatna
        funkcjonalność, ponieważ na podstawie czasu modyfikacji tych plików
        możemy dowiedzić się kiedy system został zainstalowany. Poniżej
        znajduje się lista, opisująca za co odpowiada konkretna konsola
        (kolejny ekran, dostępny po naciśnięciu klawiszy Ctrl + Alt + F1 - F6).
      </p>
      <ul>
        <li><strong>CTLR + ALT + F1</strong> - multiplekser terminala,</li>
        <li><strong>CTRL + ALT + F2</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F3</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F4</strong> - komunikaty diagnostyczne
            rejestratora <em>syslog</em>.</li>
        <li><strong>CTRL + ALT + F5</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F6</strong> - tryb graficzny.</li>
      </ul>
      <p>
        Instalacja Red Hat Enterprise Linux rozpoczyna się od wyboru języka
        procesu instalacji. Chcąc pracować już w takim prawowitym IT, należy
        posługiwać się językiem angielskim i to technicznym. Systemy z którymi
        zderzmy się w potencjalnej pracy raczej będą systemami o zasięgu
        międzynarodowym, prawdopodobnie już o tym wspominałem ale egzamin
        pozwalający uzyskać certyfikacje RHCSA również będzie po angielsku.
        Dlatego też instalować jak i korzystać z systemu będziemy w języku
        angielskim, na pierwszym ekranie wybieramy <em>English</em>
        pozostawiając wariant <em>English (United States)</em>. Następnym
        ekranem jest <em>Installation Summary</em> (lewy górny róg), jest tak
        jakby pulpit programu instalacyjnego, na nim występują komponenty,
        które możemy skonfigurować. W wersji 9.0, te komponenty są podzielone
        na 4 sekcje: <em>Localization</em>, <em>Software</em>, <em>System</em>
        oraz <em>User Settings</em>. W pierwszym procesie instalacji,
        przejdziemy przez wszystkie z nich.
      </p>
      <p>
        Zwróć my uwagę na to, iż system sam dokonał wstępnej konfiguracji
        instalatora, na pozostało jedynie sprawdzić oraz skonfigurować tylko
        te opcje oznaczone znakiem ostrzegawczym oraz czerwoną podpowiedzią. Po
        ich konfiguracji program umożliwi nam zainstalowanie systemu.
      </p>
      <p>
        W sekcji lokalizacyjnej do ustawienia są takie opcje, układ klawiatury,
        język, oraz data i czas. Podczas ładowania pierwszego okna (moment 
        wybrania języka instalacji), instalator na podstawie informacji GeoIP
        postara się określić naszą przybliżoną lokalizację, o ile posiada on
        na tym momencie połączenie z internetem. Dlatego też możemy
        spotkać się z samoinstnie wybranym języku instalacji ustawionym na
        Polski. Język został zmieniony, ale wybrana strefa czasowa może
        pozostać, wręcz powinna. Dzięki tej funkcji możemy zaoszczędzić czas,
        i przejść do kolejnej sekcji.
      </p>
      <p>
        Kolejną sekcja dotyczy oprogramowania, tutaj konfigurowane będzie
        na przykład połączenie z firmą Red Hat. RHEL jest system 
        licencjonowanym i jeśli chcemy skorzystać z oficjalnych repozytoriów
        należy "podłączyć" system do naszego konta założonego w celu
        pozyskania obrazu płyty. Jednak na razie nie trzeba tego, będzie to
        do zrobienia na późniejszych etapach nauki administracji systemem.
        Kolejną opcją jest <em>Installation Source</em> (Źródło instalacji),
        konfigurąc tę opcję możemy
        wybrać czy będziemy korzystać pod czas instalacji z obrazu płyty lub
        sieciowego repozytorium lub Red Hat CDN. Z racji tego, iż ściągneliśmy 
        pełny obraz
        ważący kilka gigabajtów, nie ma sensu używać instalacji sieciowej.
        Tego typu źródło instalacji należy wybrać w momencie gdy pobraliśmy
        minimalistyczną wersję obrazu, dlatego też zostaniemy przy standardowym
        wyborze <em>Local media</em>. Ta opcja pozwala też na dodanie podczas
        instalacji dodatkowego repozytorium, jednak na tym etapie nie będziemy
        się tym zajmować. Ostanią opcją z tej sekcji jest <em>Software
        selection</em>, ta opcja daje nam możliwość, wyboru rodzaju instalacji.
        Na potrzeby nauki, wybierzemy opcję <em>Server with GUI</em>, jeśli
        będziemy instalować RHEL na naszym komputerze do codziennego użytku
        możemy wybrać <em>Workstation</em>. Wybierając rodzaj instalacji po
        lewej stronie, po prawej wyświetają się dodatkowe pakiety lub
        warianty do zainstalowania.
      </p>
      <p>
        Sekcja <em>System</em>, służy głównie do wyboru docelowego miejsca dla
        instalacji. W opcji <em>Instalation Destination</em>,
        wskazujemy docelowy dysk do instalacji, możemy go spartycjonować 
        ręcznie lub automatycznie możemy również zaszyfrować instalacje,
        jeśli jest taka potrzeba. W przypadku szyfrowania danych 
        bardzo ważny jest układ klawiatury. Innymi opcjami
        póki co dla nas ważnymi jest <em>Network &amp; Host name</em>, w
        założeniach zadania, może być wymagane ustawienie odpowiedniego adresu
        oraz nazwy dla maszyny. Tak jest w naszym przypadku, to te opcje
        ustawiamy właśnie tam. Pozostałe opcje tej sekcji, poki co nie są
        dla nas istotne.
      </p>
      <p>
        Ostatnia sekcja ustawia hasło dla superużytkownika oraz tworzy konto
        dla pierwszego użytkownika. Nie musi on posiadać uprawnień
        administratora i nie będzie ich miał. Opcja utworzenia użytkownika
        może się nie mieścić na ekranie, podczas instalacji systemu maszynie
        witualnej, dlatego nie należy przejmować, że jej nie ma.
      </p>
      <p>
        Teraz kiedy wszyskie (te istotne dla instalacji) zostały opisane możemy
        zainstalować system zgodnie założeniami pierwsze maszyny i powtorzyć
        to na drugiej. I to jest pierwsze ćwiczenie.
      </p>
      <h3 id="exec1.1">Ćwiczenie 1: Instalacja Red Hat Enterprise Linux 9</h3>
      <p>
        Zainstaluj zgodnie założeniami podanymi w podrozdziale 
        <em>Tworzenie maszyn wirtualnych VirtualBox z RHEL</em> oraz sugestiami
        podanymi podczas opisu procesu instalacji. Red Hat
        Enterprise Linux 9 na maszynie wirtualnej <em>RHEL-VM1</em>. Następnie
        powtórz tę czynność drugiej maszynie przeznaczonej do laboratorium.
        Pamiętaj, że założenia dla drugiej maszyny różnią się.
      </p>
      <h3 id="exec1.2">Ćwiczenie 2: Logowanie zdalne do RHEL</h3>
      <p>
        Wykorzystując program do obsługi protokołu SSH dla twoje systemu
        operacyjnego zaloguj się na superużytkownika. Pamiętaj o tym, że
        bezpośrednie logowanie na superużytkownika wymagało zaznaczenia opcji
        podczas ustawiania hasła dla niego.
      </p>
      <h2 id="ch1summary">Podsumowanie</h2>
      <p>
        W tym rozdziale przezszliśmy przez proces instalacji RHEL.
        Dowiedzielśmy się, że możliwe jest instalacja w trybie tekstowym oraz
        oraz, że nienależy ona do najtrudniejszych. Warto zwrócić uwagę na to
        iż jeśli do tej pory korzystaliśmy z jakiś materiałów to dotyczą one
        wersji 8 RHEL, my będziemy korzystać z wersji 9, bo to na niej w 2022
        roku będziemy zdawać egzamin, a między tymi wersjami jest kilka zmian.
        W następnym rozdziale zapoznamy się z środowiskiem graficznym,
        strukturą katalogów oraz podstawowym narzędziami do pracy w powłoce.
      </p>
      <h1 id="2.firststepsinRHEL9">2. Poruszenia się po systemie RHEL 9</h1> 
      <p>
        Wykonując ćwiczenia z pierwszego rozdziału, zainstalowaliśmy sobie
        Red Hat w wersji 9 na maszynie wirtualnej. Jako wariant wyboru
        oprogramowania wybraliśmy <em>Server with GUI</em> i od drobnego
        omówienia środowiska graficznego rozpocznę ten rodział.
      </p>
      <h2 id="2.1.serverwithgui">2.1. Środowisko graficzne RHEL 9</h2>
      <p>
        Red Hat jest dystrybucją Linuksa przeznaczoną do zastosowań
        produkcyjnych, więc system tego typu musi wykazywać się dużą
        stabilnością. Znaczące zmiany są wprowadzane raczej w dużych wydania
        jak RHEL 9, takim znaczącym przeskokiem jest zmiana linii jądra z
        4.18 (w przypadku RHEL 8) na 5.14 (w przypadku RHEL 9) oraz zastąpienie
        klasycznego serwera X Window protokołem Wayland, to jednak nastąpiło z
        wydaniem RHEL 8. Zmiany w RHEL 9, odnośnie środowiska graficznego
        to przejście z Gnome 3.38 na Gnome 40, ta zmiana przyniosła również
        odświerzenie menedżera wyświetlania lub menedżera logowania czym w
        przypadku środowiska Gnome jest GDM. Większość elementów pozostała
        taka sama na górnej belce mamy datę oraz czas w prawyn górnym rogu
        do wyboru opcje ułatwień dostępu, wskaźnik połączenia sieciowego oraz
        porozwinięciu możliwość regulacji głośności i jasności ekranu oraz 
        wyłączenia komputera. Wiecej opcji w tym miejscu będzie dostępne dopiero 
        po zalogowaniu. Będzie można zmienić kilka ustawień jak np. sieć
        bezprzewodwą. Zmianie uległ również sposób prezentacji kont użytkownika.
        Z racji tego iż <em>root</em> nie jest zwykłym użytkownikiem nie będzie
        pojawiać się na liscie, ale zalogowanie na niego jest możliwe za pomocą
        kliknięcia w "Not Listed?" pod listą użytkowników, wówczas będzie mogli
        ręcznie podać nazwę użytkownika oraz hasło. Ekranem startowym po
        zalogowaniu jest ekran <em>Activities</em>, który pozwala na podgląd
        wykonywanych czynności, rozpoczęcie nowych (wybierają aplikacje z 
        z doka lub z pełnej listy aplikacji, która jest dostępna po kliknięciu
        na ikonę 9 kropek w doku) oraz przełacznie się między obszarami
        roboczymi. Domyślnie GNOME daje dostęp do dwóch przestrzeni roboczych,
        gdy tylko przeniesiemy aplikację do na nowy obszar, GNOME udostępni
        nam kolejny i tak dalej. Wyszukiwarka nad podgląd obszaru roboczego
        daje możliwość wyszukiwania nie tylko aplikacji ale także ustawień co
        jest normą w GNOME od wersji 3. Na doku znajdują się ulubione
        aplikacje, które możemy usuwać i dodawać za pomocą PPM i następnie
        wybierając dodaj lub usuń z ulubionych.
      </p>
      <h2 id="2.2.hfs">2.2. Struktura katalogowa w Uniksach</h2>
      <p>
        Zanim jednak przejedziemy do obsługi wiersza poleceń omówimy sobie
        hierachiczną strukturę katalogów, która występuje nie tylko w RHEL ale
        i w innych Uniksach, ponieważ HFS (<em>ang. Hierarchy File System</em>)
        jest ogólnym standardem. Na Uniksach możemy spotkać się z trzema typami
        systemów plików.
      </p>
      <ul>
        <li><strong><em>Disk-based</em> - dyskowe</strong> - są to klasyczne
          pliki i katalogi przechowywane bezpośrednio na dysku.</li>
        <li><strong><em>Network-based</em> - sieciowe</strong> - są to udziały
          podmontowane w naszych systemach za pomocą róznych protokołów, nie
          tylko SMB. Plik <em>network-based</em> są plikami <em>disk-based</em>,
          ale na innych komputerach.</li>
        <li><strong><em>Memory-based</em> - wirtualne</strong> - te systemy
          plików są tworzone przez procesy na potrzeby działania systemu, takim
          systemem może być katalog <em>/dev</em> lub <em>/tmp</em>. Ich
          trwałość często zależy od tego jak długo system pozostaje włączony
          lub od wewnętrznych ustaleń samego systemu.</li>
      </ul>
      <p>
        Struktura plików i katalogów na Uniksach ma postać odwróconego drzewa.
        Korzeń (katalog główny) znajduje się na szczycie struktury i odniego
        rozchodzą się poszczególne gałęzie (podkatalogi), gałęzię mogą zawierać
        kolejne rozgałezienia i tworzyć całe struktury, na gałęziach
        znajdują się również liscie czyli pliki i na liściach struktura się
        kończy.
      </p>
      <p>
        Dostęp do konkretnych plików i katalogów w strukturze określany jest
        za pomocą ścieżek. Scieżki określają położenie plików i katalogów
        wewnątrz HFS.
        Separatorem elementów ścieżki (posczególnych podkatalogów), jest
        ukośnik, slash (<strong>/</strong>).
      </p>
      <p>
        Podczas pracy z elementami jak foldery oraz pliki możemy używać
        <strong>scieżęk bezwzględnych</strong> zaczynające się od
        katalogu głównego, lub <strong>ścieżek względnych</strong>
        zaczynających
        się od elementu znajdującego w obecnym katalogu robocznym
        (tym katalogu, w którym się obecnie znajdujemy).
      </p>
      <p>
        Katalog główny jest miejscem do przechwywania wszystkich plików, jakie
        znajdują się w systemie, jest pierwszy element znajdujący się na
        ścieżce (bezwzględnej) i oznaczny jest on poprostu ukośnikiem
        (<strong>/</strong>), od tego katalogu zaczyna się cała struktura.
        Poniżej znajduje się lista najważniejszych podkatalogów katalogu
        głównego, każdy z nich ma swoje znaczenie w systemie.
      </p>
      <ul>
        <li><strong>/boot</strong> (<em>disk-based</em>) - katalog ten
            przechowuje jądro, <em>initramfs</em> oraz konfiguracje programu
            rozruchowego.</li>
        <li><strong>/dev</strong> (<em>memory-based</em>) - katalog ten
            przechowuje pliki urządzeń służące do odwoływania się do
            rzeczywistego sprzętu podczas komunikacji. Pliki te są tworzone
            przez usługę <em>udevd</em> podczas podłączania urządzenia oraz
            rozruchu systemu.</li>
        <li><strong>/etc</strong> (<em>disk-based</em>) - skrót <em>etc</em>
            możemy rozwinąć do <em>ang. etcetera</em> lub <em>ang. extended
            text configration</em>. Jest to miejsce do przechowywania plików
            konfiguracyjnych różnych programów.</li>
        <li><strong>/home</strong> (<em>disk-based</em>) - ten katalog
            przechowuje, katalogi domowe użytkowników.</li>
        <li><strong>/opt</strong> (<em>disk-based</em>) - katalog przeznaczony
            na dodatkowe oprogramowanie instalowane w systemie.</li>
        <li><strong>/proc</strong> (<em>memory-based</em>) - wirtualna 
            struktura podkatalogów, zawierająca informacje o procesach oraz
            różne informacje o systemie, np. informacje o procesorze.</li>
        <li><strong>/run</strong> (<em>memory-based</em>) - katalog
            przechowywujący pliki wykorzystywane przez procesy podczas
            wykonywania ich czynności. W tym katalogu znajduje się również
            podkatalog <em>media</em> zawierący punkt monotowania automatycznie
            montowanych w systemie dysków wymiennych.</li>
        <li><strong>/sys</strong> (<em>memory-based</em>) - katalog
            przechowuje informacje o urządzeniach, sterownikach. Pewne
            funkcjonalności jądra również są zawarte w tym katalogu. Informacje
            z tego katalogu są używane przez jądro do obsługi urządzeń.</li>
        <li><strong>/tmp</strong> (<em>disk-based</em>) - miejsce 
            przechowywania plików tymczasowych, plik złożone w tym katalogu
            przetrwają ponowne uruchomienie komputera. Okres przechowywania 
            tych plików to 10 dni.</li>
        <li><strong>/usr</strong> (<em>disk-based</em>) - skrót <em>usr</em>,
            należy rozwinąć jako <em>ang. UNIX System Resources</em>. Ten
            katalog jest kolejną dużą strukturą katalogów w systemie. W tym
            katalog przechowywane są wszystkie programy, więc wiekszość 
            systemu. Na poniższej liście znajdują się rozpisane podkatalogi
            tego katalogu:
            <ul>
              <li><strong>/usr/bin</strong> - katalog przechowuje większosć
                  plików binarnych, wykorzystywanych w systemie, programów oraz
                  poleceń.</li>
              <li><strong>/usr/sbin</strong> - narzędzia administracyjne
                  niedostępne dla zwykłych użytkowników, poza kilkoma
                  programami. Ten katalog często nie jest ujęty podczas 
                  wyszukiwania poleceń.</li>
              <li><strong>/usr/lib</strong>, <strong>/usr/lib64</strong> - 
                  biblioteki współdzielone oraz pliki statyczne, nie których
                  programów typu init.</li>
              <li><strong>/usr/include</strong> - pliki nagłówkowe języka C</li>
              <li><strong>/usr/local</strong> - miejsce przechowywania
                  zewnętrznych programów instalowanych i
                  wykorzystywanych przez administatorów, ten katalog zawiera w
                  sobie podobną strukturę katalogową jak sam <em>/usr</em>.</li>
              <li><strong>/usr/share</strong> - miejsce przechowywania stron
                  podręcznika, dokumentacji czy przykładowych plików 
                  konfiguracyjnych.</li>
            </ul>
        </li>
        <li><strong>/var</strong> (<em>disk-based</em>) - katalog na zmienne
            dane, katalog podobnie do <em>/usr</em> ma wewnątrz wiele znaczący
            podkatalogów, których opis znajduje się poniżej:
            <ul>
              <li><strong>/var/log</strong> - katalog na pliki dzienników,
                zbierane nie tylko z głównego rejestratora, ale i funkcji
                rejestrowania samych usług.</li>
              <li><strong>/var/opt</strong> - katalog na zmienne dane
                oprogramowania instalowanego w katalogu <em>/opt</em></li>
              <li><strong>/var/spool</strong> - katalog ten przechowuje dane
                zanim zostaną przekazane lub pobrane przez właściwe komponenty.</li>
              <li><strong>/var/tmp</strong> - katalog przechowuje duże pliki
                tymczasowe. Pliki przeżywają uruchomienie ponowne systemu.
                Czas ich istnienia w tym katalog to 30 dni.</li>
            </ul>
        </li>
      </ul>
      <p>
        Za pomocą polecenia <strong>tree</strong>, możemy wyświetlić strukturę
        katalogą w postaci drzewa, jednak najpierw nauczymy się korzystać z
        poleceń w RHEL.
      </p>
      <h2 id="2.3.usingcli">2.3. Obsługa wiersza poleceń i najprostsze 
      polecenia</h2>
      <p>
        Obsługa wiersza poleceń zależy w znacznym stopniu od powłoki, ponieważ
        to ona zajmuj się jego interpretacją i koniec końców wykonaniem
        programu, którego nazwę podaliśmy chcą wykonać polecenie. Aby móc
        skorzystać w RHEL z wiersza poleceń musimy albo uruchomić w środowisku
        graficznym aplikację <strong>Terminal</strong>, lub zalogować się
        zdalnie za pomocą protokołu SSH. Uruchomienie terminala lub zalogowanie
        się przez SSH uruchomi powłokę, która swoją gotowość na otrzymywanie
        poleceń obwieści wyświetleniem <strong>znaku zachęty</strong>.
      </p> 
      <p>
        Znak zachęty jest wskaźnikiem za kursorem po którym możemy wprowadzać 
        do systemu
        polecenia. Kiedyś znaki zachęty były pojedyńczymi znakmi informującymi
        o uprawnieniach z jakimi działa proces powłoki (o tym za chwilę). Teraz
        znaki zwracają nazwę użytkownika, nazwę komputera oraz obecny katalog
        roboczy wewnątrz nawiasu kwadratowego, następnie zanim znajduje się
        znak krzyżyka (<strong>#</strong>) mówiący, że powłoka działa
        uprawnieniami użytkownika <em>root</em> lub symbol dolara 
        (<strong>$</strong>) mówiący, że połoka działa z uprawnieniami zwykłego
        użytkownika. Poniżej przedstawiłem oba znaki:
      </p>
<pre class="code-block">
[root@server1 ~]#

[user@server1 ~]$
</pre>
      <p>
        W różnych dystrybucjach, znak zachęty może różnorako wyglądąć. Możemy
        dostować go do własnych potrzeb, wiele osób korzysta z jak 
        najmniejszych
        znaków zachęty, aby zaoszczedzić miejsce w wierszu polecenia. Teraz
        możemy już wydawać polecenia.
      </p>
      <p>
        Kazde polecenie w jakimkolwiek Uniksie, składa się z nazwy polecenia,
        ewentualnych opcji oraz ewentualnych argumentów. Nie wszystkie
        polecenia do uzyskania żądanych przez nas efektów wymagają opcji czy
        argumentów.  
      </p>
<pre class="code-block">
$ nazwa_polecenia [opcje] [argumenty]
</pre>
      <p>
        Każde polecenie przed zatwierdzeniem możemy edytować, za pomocą
        strzałek lub skrótów klawiszowych dostarczanych przez bibliotekę
        <em>GNU Readline</em>. Więcej na ten temat znajdziemy w internecie.
      </p>
      <p>
        Przez cały kurs będziemy poznawać jakieś polecenia ale w tym momencie
        nauczymy się najprostszych z nich.
      </p>
      <h3 id="2.3.1.ls">2.3.1. Listowanie zawartości katalogu</h3>
      <p>
        Aby wyświetlić zawartość katalogu w powłoce, możemy użyć polecenia
        <strong>ls</strong>. Polecenie bez podania argumentu w postaci
        katalogu wyświetli zawartość folderu, w którym się znajdujemy.
        Najważniejszymi opcjami między innymi są:
      </p>
      <ul>
        <li><strong>-a</strong> - wyświetlanie wszystkich, elementów w katalogu
            także tych, które normalnie nie są wyświetlane (plik i foldery,
            których nazwa rozpoczyna się od kropki).</li>
        <li><strong>-l</strong> - wyświetlenie szczegółowych informacji na
            temat elementów. Informacja zwracana przez polecenie jest wówczas
            podzielona na 9 pól, które kolejno oznaczają: typ pliku oraz
            uprawnienia; liczbę dowiązań; nazwę użytkownika (właściciela pliku);
            nazwę grupy do której należy ten plik; rozmiar w bajtach; czas
            modyfikacji oraz nazwę elementu.</li>
        <li><strong>-ld</strong> - wyświetla szczegółową informacje na temat
            podanego jak argument katalogu, bez wyświetlania jego zawartości.
            Jeśli nie podamy argumentu polecenie wyświetli informacje na temat
            bierzącego katalogu.</li>
        <li><strong>-lh</strong> - wyświetli szczegółowo informacje
            na temat elementów w katalogu, wyświetlając ich rozmiar w
            przeskalowanych wartościach, co ułatwi odczytanie go przez 
            człowieka.</li>
        <li><strong>-lt</strong> - wyświetli szczegółową listę elementów
            posortową względem czasu modyfikacji od najnowszego pliku.</li>
        <li><strong>-ltr</strong> - działanie podobne to <em>-lt</em>, ale
            odwrócone, elementy zostaną wyświetlone od najstarszego.</li>
        <li><strong>-R</strong> - wyświetlenie elementów w sposób 
            rekurencyjny. Polecenie z tą opcją wyświetli zawartość katalogów
            wraz z zawartością ich podkatalogów itd.</li>
      </ul>
      <p>
        Poniżej znajduje się przykład najczęściej wykorzystywanego polecenia
        <em>ls</em> wraz z opcjami:
      </p>
<pre class="code-block">
[root@server1 ~]# ls -al
total 10576
dr-xr-x---. 17 root root    4096 Jun 16 18:49 .
dr-xr-xr-x. 18 root root     235 Jun  9 19:46 ..
-rw-------.  1 root root    1197 Jun  9 19:59 anaconda-ks.cfg
-rw-------.  1 root root    3908 Jun 16 18:50 .bash_history
-rw-r--r--.  1 root root      18 Aug 10  2021 .bash_logout
-rw-r--r--.  1 root root     141 Aug 10  2021 .bash_profile
-rw-r--r--.  1 root root     429 Aug 10  2021 .bashrc
drwxr-xr-x.  3 root root      17 Jun 16 18:14 bzipped
drwx------.  8 root root     120 Jun 13 10:55 .cache
-rw-r--r--.  1 root root      11 Jun 16 13:10 catfile1
drwx------.  9 root root    4096 Jun 13 13:42 .config
-rw-r--r--.  1 root root     100 Aug 10  2021 .cshrc
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Desktop
drwxr-xr-x.  4 root root      30 Jun 16 16:44 dir20
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Documents
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Downloads
drwxr-xr-x.  3 root root      55 Jun 16 11:34 etc
-rw-r--r--.  1 root root 4986788 Jun 16 18:13 etc-bzipped.tar.bz2
-rw-r--r--.  1 root root 5772869 Jun 16 18:12 etc-gzipped.tar.gz
-rw-r--r--.  2 root root       0 Jun 16 17:26 file10
-rw-r--r--.  2 root root       0 Jun 16 17:26 file20
-rw-r--r--.  1 root root     579 Jun 16 11:07 fstab
drwxr-xr-x.  3 root root      17 Jun 16 18:14 gzipped
-rw-------.  1 root root      42 Jun 16 18:22 .lesshst
drwx------.  3 root root      19 Jun 13 10:55 .local
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Music
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Pictures
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Public
lrwxrwxrwx.  1 root root       6 Jun 16 17:30 soft10 -&gt; file10
-rw-r--r--.  1 root root     129 Aug 10  2021 .tcshrc
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Templates
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Videos
-rw-------.  1 root root    8264 Jun 16 18:38 .viminfo
-rw-r--r--.  1 root root     464 Jun 16 18:38 vipractice
</pre>
      <p>
        Podczas korzystania z wielu programów możemy natknąć się na wiele opcji.
        Dzielą się one na długie i krótkie, opcje krótkie występują w
        postaci pojedyńczego znaku poprzedzonego jednym myślnikiem
        (<strong>-</strong>). Opcje długie występuje w postaci pojedyńczego
        (najczęsciej, ponieważ to zależy od programu) słowa poprzedzonego dwoma 
        myślnikami (<strong>--</strong>). W przypadku tak prostych poleceń jak
        <em>ls</em> również możemy użyć długich opcji np. zamiast
        <em>-a</em> możemy użyć <em>--all</em>.
      </p>
      <h3 id="2.3.2.pwd">2.3.2. Wyświetlenie bierzącego katalogu roboczego</h3>
      <p>
        Na pierwszy rzut oka mogłoby się wydawać po co nam to polecenie,
        skoro w znaku zachęty na RHEL jest wyświetlona nazwa bierzącego
        katalogu. Polecenie <strong>pwd</strong> wyświetla ścieżkę bezwzględną 
        do bierzącego katalogu, a po drugie to polecenie ma bardzo ważną cechę
        związaną z dowiązaniami, ale o tym będzie przy dowiązaniach. Do
        normalnych zastosować <em>pwd</em> nie potrzebuje żadnej opcji, ani
        żadnego argumentu.
      </p>
<pre class="code-block">
[root@server1 ~]# pwd
/root
</pre>
      <h3 id="2.3.3.cd">2.3.3. Poruszanie się wśrod katalogów</h3>
      <p>
        Generalnie do zmiany bierzącego katalogu, czy przejścia z/do 
        innego katalogu służy polecenie <strong>cd</strong>. Pozwala on na
        kilka sztuczek.
      </p>
      <ul>
        <li>Powrót do katalogu domowowego nie wymaga przy tym poleceniu żadnego
          argumentu ani opcji, wystarczy wydać polecenie <em>cd</em>.</li>
        <li>Polecenie zapamiętuje poprzedni katalog roboczy i powrót do niego
          wymaga podania polceniu <em>cd</em> myślnika (<strong>-</strong>)
          jako argumentu</li>
        <li>W ścieżka chcąć skrócić sobie pisanie, możemy użyć tyldy
          (<strong>~</strong>) jako przedstawienia katalogu domowego.</li>
        <li>Chcąc przenieść się do katalogu nadrzędnego względem bierzącego
          nie musimy znać jego nazyw wystarczy że poleceniu <em>cd</em> podamy
          dwie kropki (<strong>..</strong>)</li>
      </ul>
      <p>
        Poniżej zamieściłem przykłady kilku z nich.
      </p>
<pre class="code-block">
[root@server1 ~]# cd -
/home/user
[root@server1 user]# cd ..
[root@server1 home]# cd 
</pre>
      <h3 id="2.3.4.tty">2.3.4. Identyfikacja urządzenia terminala</h3>
      <p>
        Czasmi może zajść potrzeba zidentyfikowania własnego urządania 
        terminalowego służy do tego polecenie <strong>tty</strong>. Jeśli 
        wynikiem działania tego polecenie będzie <em>/dev/pts*</em> oznacza to,
        że korzystamy z emulatora terminala np. programu Terminal w środowisku
        GNOME lub połączenia zdalnego za pomocą protokołu SSH. 
        Jeśli naszę urządzenie to <em>/dev/tty*</em> oznacza to, że
        korzystamy z jednej wirtualnych konsol dostępnych na komputerze.
      </p>
<pre class="code-block">
[root@server1 ~]# tty
/dev/pts/0
</pre>
      <h3 id="2.3.5.uptime">2.3.5. Czas systemowy oraz załadowanie procesora</h3>
      <p>
        W większości dostępnych Uniksów zapewne dostępne będzie polecenie 
        <strong>uptime</strong>. To niepozorne polecenie zawraca dużą ilość
        informacji.
      </p>
      <ul>
        <li>Czas systemowy,</li>
        <li>Ilość czasu jaka upłyneła od uruchomienia systemu (tzw. 
            <em>uptime</em>),</li>
        <li>Ilość zalogowanych do systemu użytkowników,</li>
        <li>Średnie załadowanie procesora w przeciągu minuty, 5 i 15 minut, ta
            wartość pokazuje zużycie procesora, podając wartości ułamkowe jeśli
            np. w ciągu jednej minuty jeden z wątków procesora był wykorzystany
            w 50% otrzymamy wynik 0.50. Jeśli posiadamy procesor wielordzeniowy, 
            ten wskaźnik może
            wskazywać wartości powyżej 1, oznacza to że procesy wykorzystują
            już więcej niż jeden wątęk/rdzeń.</li>.
      </ul>
<pre class="code-block">
[root@server1 ~]# uptime
 13:28:40 up 8 min,  1 user,  load average: 0.00, 0.12, 0.12
</pre>
      <h3 id="2.3.6.clear">2.3.6. Czyszczenie ekranu powłoki</h3>
      <p>
        Do czyszczenia terminala ze zbędnego wyjścia poleceń służy polcenie
        <strong>clear</strong> lub kombinacja klawiszy <em>CTRL+l</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# clear
</pre>
      <h3 id="2.3.7.which">2.3.7. Określanie ścieżki polecenia</h3>
      <p>
        Czasami w pewnych konfiguracjach lub też w skryptach powłoki niezbędne
        będzie podanie ścieżki do konkretnego programu kryjącego się za nazwą
        polecenia, w RHEL możemy zrobić to na trzy sposoby wykorzystując do
        tego różne polecenia. Polecenia podałem w przykładzie w raz z
        informacją zwracaną przez polecenie.
      </p>
<pre class="code-block">
$ which ls
alias ls='ls --color=auto'
	/usr/bin/ls

$ whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz

$ type ls
ls jest aliasem do ls --color=auto'
</pre>
      <p>
        Które z tych poleceń będzie właściwe to już zależy, do czego będą nam
        potrzebne tego typu informacje. Polecenie <em>whereis</em> wydaje się
        szczególnie pomocne.
      </p>
      <h3 id="2.3.8.uname">2.3.8. Wyświetlenie informacji o systemie</h3>
      <p>
        Polecenie <strong>uname</strong>, należy do poleceń, które są dość
        niepozorne, ale za pomocą jego opcji możemy otrzymać wersję użytego
        jądra, archtekturę systemu i tym podobne informacje. Polecenie bez 
        podania
        żadnej z opcji zwraca wyłącznie nazwę systemu i jest to <em>Linux</em>.
        Aby otrzymać wszelkie zwracane przez to polecenie informacje możemy 
        użyć opcji <em>-a</em>. Resztę opcji znajdziemy na stronach
        podręcznika (o tym będzie w dalszej częście materiału).
      </p>
<pre class="code-block">
$ uname -a 
Linux latitude-e5270 5.14.0-70.13.1.el9_0.x86_64 #1 SMP PREEMPT Thu Apr 14 12:42:38 EDT 2022 x86_64 x86_64 x86_64 GNU/Linux
</pre>
      <h3 id="2.3.9.lscpu">2.3.9. Wyświetlanie informacji o procesorze</h3>
      <p>
        W RHEL możemy łatwo sprawdzić informacje na temat zainstalowanego w
        naszym komputerze procesora w przystępny sposób. Do dyspozycji mamy
        bowiem polecenie <strong>lscpu</strong>. Wyświetla ono wszystkie
        dostępne informacje jakie może znaleźć w systemie na temat tego
        komponentu.
      </p>
<pre class="code-block">
[root@server1 ~]# lscpu
Architecture:            x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Address sizes:         39 bits physical, 48 bits virtual
  Byte Order:            Little Endian
CPU(s):                  1
  On-line CPU(s) list:   0
Vendor ID:               GenuineIntel
  Model name:            Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
    CPU family:          6
    Model:               78
    Thread(s) per core:  1
    Core(s) per socket:  1
    Socket(s):           1
    Stepping:            3
    BogoMIPS:            5004.62
    Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush
                          mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology
                          nonstop_tsc cpuid tsc_known_freq pni pclmulqdq monitor ssse3 cx16 pcid sse4_1 
                         sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm 3dnowpre
                         fetch invpcid_single pti fsgsbase avx2 invpcid rdseed clflushopt md_clear flush
                         _l1d
Virtualization features: 
  Hypervisor vendor:     KVM
  Virtualization type:   full
Caches (sum of all):     
  L1d:                   32 KiB (1 instance)
  L1i:                   32 KiB (1 instance)
  L2:                    256 KiB (1 instance)
  L3:                    3 MiB (1 instance)
NUMA:                    
  NUMA node(s):          1
  NUMA node0 CPU(s):     0
Vulnerabilities:         
  Itlb multihit:         KVM: Mitigation: VMX unsupported
  L1tf:                  Mitigation; PTE Inversion
  Mds:                   Mitigation; Clear CPU buffers; SMT Host state unknown
  Meltdown:              Mitigation; PTI
  Spec store bypass:     Vulnerable
  Spectre v1:            Mitigation; usercopy/swapgs barriers and __user pointer sanitization
  Spectre v2:            Mitigation; Retpolines, STIBP disabled, RSB filling
  Srbds:                 Unknown: Dependent on hypervisor status
  Tsx async abort:       Not affected
</pre>
      <h2 id="2.4.gettinghelp">2.4. Uzyskiwanie pomocy</h2>
      <h3 id="2.4.1.manpages">2.4.1. Strony podręcznika</h3>
      <p>
        W dystrybucjach Linuksa nie tylko w RHEL możemy znaleźć duża bazę
        zawierającą opisy poleceń, plików konfiguracyjnych oraz innych
        komponentów takich jak biblioteki. Służą temu strony podręcznika. Aby
        uzyskać do nich dostęp wystarczy wydać polecenie <strong>man</strong>
        podając jako argument interesujący na komponent. Nie zawsze musi być
        to polecenie. Strony podręcznika są podzielone na rozdziały czy też
        sekcje ich opisy oraz numery sa zawarte w na (o ironio) stronie
        podręcznika polecenia <em>man</em>. Wydaj poniższe polecenie aby
        zapoznać się z nim oraz z ich organizacją.
      </p>
<pre class="code-block">
$ man man
</pre>
      <p>
        Różne komponenty na Linuksie mogą mieć takie same nazwy. Polecenie
        <em>man</em> zwraca pierwsze znalezione wystąpienie, jeśli wpiszemy
        polecenie <code class="code-inline">man passwd</code> to otrzymamy
        informacje na temat polecenia, ale jeśli interesowałoby nas poznanie
        szczegółów pliku <em>/etc/passwd</em> musimy podać przed nazwą, numer
        sekcji odpowiedzialny za pliki konfiguracyjne.
      </p>
<pre class="code-block">
$ man 5 passwd
</pre>
      <p>
        Strony podręcznika, możemy przeszukiwać pod kątem występowania słów
        kluczowych, w przypadku kiedy znamy zagadnienie ale nie znamy
        odpowiedniego polecenia. Do tego celu możemy użyć opcji <em>-k</em>
        polecenia <em>man</em> lub polecenia <strong>apropos</strong>. Wynik 
        działania tych programów jest taki sam.
      </p>
<pre class="code-block">
$ apropos dos
dos2unix (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
mac2unix (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
unix2dos (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
unix2mac (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
dosfsck (8)          - check and repair MS-DOS FAT filesystems
dosfslabel (8)       - set or get MS-DOS filesystem label or volume ID
fatlabel (8)         - set or get MS-DOS filesystem label or volume ID
filesystems (5)      - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdo...
fs (5)               - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdo...
fsck.fat (8)         - check and repair MS-DOS FAT filesystems
fsck.msdos (8)       - check and repair MS-DOS FAT filesystems
fsck.vfat (8)        - check and repair MS-DOS FAT filesystems
mkdosfs (8)          - create an MS-DOS FAT filesystem
mkfs.fat (8)         - create an MS-DOS FAT filesystem
mkfs.msdos (8)       - create an MS-DOS FAT filesystem
mkfs.vfat (8)        - create an MS-DOS FAT filesystem
vdosetuuid (8)       - sets a new uuid for the vdo volume stored on a backing store
vdostats (8)         - Display configuration and statistics of VDO volumes
</pre>
      <p>
        W pierwszej kolumnie znajduje się nazwa komponentu, w drugiej numer
        sekcji a następnie krótki opis.
      </p>
      <p>
        Szukając opisu polecenia możemy posiłkować się poleceniem 
        <strong>whatis</strong>. Polecenie to poszukuje konkretnego komponentu
        na stronach podręcznika, a nie słowa kluczowego.
      </p>
<pre class="code-block">
$ whatis xdg-open 
xdg-open (1)         - opens a file or URL in the user's preferred application
</pre>
      <p>
        Polecenie <em>whatis</em>, zachowuje się identycznie jak polecenie
        <em>man</em> z opcją <em>-f</em>.
      </p>
      <h3 id="2.4.2.helpincommand">2.4.2. Pomoc w samym poleceniu</h3>
      <p>
        Inny sposobem niż wertowanie stron podręcznika w celu znalezienia
        odpowiedniej opcji jest po prostu wywołanie polecenie a opcją
        <strong>--help</strong>.
      </p>
<pre class="code-block">
$ ranger --help
Usage: ranger [options] [path]

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -d, --debug           activate debug mode
  -c, --clean           don't touch/require any config files.
  --logfile=file        log file to use, '-' for stderr
  --cachedir=dir        change the cache directory.
                        (/home/xf0r3m/.cache/ranger)
  -r dir, --confdir=dir
                        change the configuration directory.
                        (/home/xf0r3m/.config/ranger)
  --datadir=dir         change the data directory.
                        (/home/xf0r3m/.local/share/ranger)
  --copy-config=which   copy the default configs to the local config
                        directory. Possible values: all, rc, rifle, commands,
                        commands_full, scope
  --choosefile=OUTFILE  Makes ranger act like a file chooser. When opening a
                        file, it will quit and write the name of the selected
                        file to OUTFILE.
  --choosefiles=OUTFILE
                        Makes ranger act like a file chooser for multiple
                        files at once. When opening a file, it will quit and
                        write the name of all selected files to OUTFILE.
  --choosedir=OUTFILE   Makes ranger act like a directory chooser. When ranger
                        quits, it will write the name of the last visited
                        directory to OUTFILE
  --selectfile=filepath
                        Open ranger with supplied file selected.
  --show-only-dirs      Show only directories, no files or links
  --list-unused-keys    List common keys which are not bound to any action.
  --list-tagged-files=tag
                        List all files which are tagged with the given tag,
                        default: *
  --profile             Print statistics of CPU usage on exit.
  --cmd=COMMAND         Execute COMMAND after the configuration has been read.
                        Use this option multiple times to run multiple
                        commands.
</pre>
      <p>
        Posiadanie tej opcji nie jest standardem, wiec nie wszystkie polecenia
        będą ją mieć.
      </p>
      <h3 id="2.4.3.texinfo">2.4.3. Dokumentacja texinfo</h3>
      <p>
        Projekt GNU, zaproponował zmianę formatu dokumentacji programów, z
        suchych stron podręcznika do dokumentów przypominających ksiązkę lub
        inne dokumenty. Strony podręcznika nadal są podstawowym i wybudowanym
        (w większość dystrybcji) źródłem  wiedzy na temat systemu i jego 
        komponentów. 
        Nie mniej jednak jeśli uznamy, że zawartość strony podręcznika nie jest
        dla zadowalająca może spojrzeć też tam, o ile ten format jest
        zainstalowany w naszym systemie. Dostęp do niego uzyskujemy za pomocą
        polecenia <strong>info</strong> lub <strong>pinfo</strong>, następnie
        podając nazwę polecenia jako argument. Wydając samo polecenie
        <em>info</em>, możemy zobaczyć ile dokumentacji w formacie
        <em>texinfo</em> znajduje się w systemie.
      </p>
      <h3 id="2.4.4.usrsharedoc">2.4.4. /usr/share/doc</h3>
      <p>
        Innym miejscem przechowującym jakieś informacje na temat poleceń czy
        też programów może być katalog <em>/usr/share/doc</em>. Możemy w nim
        znaleźć na przykład domyślne plik konfiguracyjne wielu usług 
        (oczywiście zależy to czy zostaną one dodany do paczek z 
        oprogramowaniem). Nie należy jednak
        od razu skreślać tego katalogu, często mogą znajdować się tam
        informacje, których nie znajdziemy na stronach podręcznika czy w
        formacie <em>info</em> np. tutoriale lub gotowe konfiguracje.
      </p>
      <h3 id="2.4.5.rhdocs">2.4.5. Dokumentacja Red Hat Enterprise Linux</h3>
      <p>
        Innym źródłem informacji na temat obsługi systemu jest dokumentacja
        Red Hat dostępna w internecie (dla RHEL 9) pod tym adresem:
        <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9</a>
      </p>
      <p>
        Każdy zebranych tam tematów możemy pobrać w formacie HTML, PDF oraz
        ePub (czytniki e-booków).
      </p>
      <p class="exam_tip">
        <strong>Odnośnie egzaminu:</strong><br />
        Na egzaminie możemy korzystać ze wszystkiego co jest dostępne w systemie
        warto pamiętać o tym. Jeśli będziemy mieć problemy z poleceniem
        <em>man</em>, warto wydać polecenie <strong>mandb</strong> odświeży
        to bazę danych stron podręcznika.
      </p>
      <h3 id="exec2.1">Ćwiczenie 1: Nawigacja pośród katalogów Linuksa</h3>
      <p>
        Jako zwykły użytkownik na maszynie wirtualnej <em>server1</em>, 
        wyświetl ścieżkę na której
        się znajdujesz. W tym samym katalogu wyświetl wszystkie pliki.
        Przjedź do katalogu <em>/etc</em> następnie wyświetl ścieżkę, na której
        się znajdujesz, następnie powróć do poprzedniego katalogu i jeszcze
        raz wyświetl ścieżkę.
      </p>
      <h3 id="exec2.2">Ćwiczenie 2: Rożne zadania</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em> w terminalu 
        polecenie <em>tty</em>.
        Następnie uruchom kilka kart terminala wydaj w nich to samo polecenie
        i porównaj zwracane wartości. Wyświetl czas pracy systemu oraz 
        średnie obciążenie procesora. Za pomocą trzech poznanych poleceń 
        wyświetl lokalizacje polecenia <em>vgs</em>.
      </p>
      <h3 id="exec2.3">Ćwiczenie 3: Informacje o systemie</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em>
        za pomocą poznanego polecenia wyświetl wszystkie informacje o systemie
        (oczywście w miarę możliwości polecenia). Następnie użyj innego
        polecenia aby sprawdzić informacje na temat zainstalowanego w
        komputerze procesora.
      </p>
      <h3 id="exec2.4">Ćwiczenie 4: Używanie pomocy</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em>
        Wyświetl stronę podręcznika polecenia <em>uname</em> oraz stronę
        podręcznika dla pliku <em>/etc/shadow</em>. Wykonaj trzy polecenia:
        <code class="code-inline">apropos ext4</code>,
        <code class="code-inline">man -k ext4</code>,
        <code class="code-inline">whatis group</code>. Czym różnią się
        informacje zwracane przez te polecenia?
      </p>
      <h2 id="ch2summary">Podsumowanie</h2>
      <p>
        W tym rozdziale skupiliśmy się na podstawach obsługi systemu,
        poznaliśmy środowisko graficzne. Odświerzyliśmy sobie informacje na
        temat hierachicznego systemu plików wykorzystywanego w Uniksach.
        Zapoznaliśmy się z terminalem i podstawowymi polecenia. Na koniec
        dowiedzieliśmy się gdzie możemy szukać pomocy na temat poleceń, plików
        konfiguracyjnych i tego typu rzeczy.
      </p>
      <h1 id="3.fileoperations">3. Operacje na plikach</h1>
      <p>
        W poprzedni rodziale poznaliśmy podstawy poruszania się po systemie,
        przejrzeliśmy środowisko graficzne, zapoznaliśmy się z wierszem
        polecenia oraz z najbardziej podstawowymi poleceniami. Było to swoiste
        zapoznanie się z systemem operacyjny. Teraz pora w nim trochę 
        po pracować.
        Ludzie zazwyczaj kiedy wspomagają swoją prace komputerem, pracują na
        danych. Te dane są zazwyczaj zebrane w pliki. Od omówienia rodzajów
        plików dostępnych na Linuksie rozpoczniemy ten rozdział.
      </p> 
      <h2 id="3.1.filetypes">3.1. Rodzaje plików</h2>
      <p>
        W Uniksach możemy wymienić 7 rodzajów różnych plików. W tych systemach
        nie jest istotne rozszerzenie oraz zawartość tych plików. Dla systemu
        zawsze będzie to <strong>zwykły plik</strong>. Wszystkie pliki
        niewymienione na poniższej liście, które przyjdą nam do głowy są 
        plikami zwykłymi.
      </p>
      <p>
        Zatem w Uniksach możemy wyróżnić takie rodzaje plików jak:
      </p>
      <ul>
        <li><strong>Plik zwykły</strong> - plik zwykłe przechowywują dane, są
          to wszelkiej maści pliki tekstowe, pliki binarne z programami oraz
          inne.</li>
        <li><strong>Katalog</strong> - jest struktura organizacyjna systemu
          plików, stosowana w celach porządkowych zwykłych plików w systemie
          plików.</li>
        <li><strong>Plik urządzenia znakowego</strong> - w przypadku określenia
          <em>znakowy</em> stosuje się także określenie <strong>surowy</strong>
          (ang. <em>raw</em>). Pliki te wykorzystywane są do komunikacji z
          urządzaniami wykorzysującymi interfejs szeregowy.</li>
        <li><strong>Pliki urządzeń blokowych</strong> - Pliki tych używa się
          są do komunikacji z urządzeniami wykorzystującymi interfejs
          równoległy. Głównie są to dyski.</li>
        <li><strong>Dowiązania symboliczne</strong> - przypominają skróty z
          z innych systemów operacyjnych. Jest to plik wskazujący na inny
          plik lub katalog.</li>
        <li><strong>Nazwane potoki, gniazda</strong> - są to pliki, które
          służą komunikacji miedzyprocesowej. Omawianie ich tutaj wychodzi
          poza ramy tego materiału.</li>
      </ul>
      <p>
        Nie ma się też za bardzo co rozwodzić nad każdym z tych typów plików.
        Rodzaju pliku możemy ustalić podczas wyświetlania zawartości katalogu.
        Wskaźnikiem jest pierwszy znak w pierwszej kolumnie informacji 
        zwracanej przez polecenie <em>ls -l</em>. Informacje zwracane dla 
        poszczególnych typów pliku wyglądają następująco:
      </p>
<pre class="code-block">
#Zwykły plik:
[root@server1 ~]# ls -l anaconda-ks.cfg 
-rw-------. 1 root root 1197 Jun  9 19:59 anaconda-ks.cfg

#Katalog:
[root@server1 ~]# ls -ld bzipped/
drwxr-xr-x. 3 root root 17 Jun 16 18:14 bzipped/

#Urządzenie znakowe:
[root@server1 ~]# ls -l /dev/console
crw--w----. 1 root tty 5, 1 Jun 17 15:20 /dev/console

#Urządzenie blokowe:
[root@server1 ~]# ls -l /dev/sda1
brw-rw----. 1 root disk 8, 1 Jun 17 15:20 /dev/sda1

#Dowiązanie symboliczne:
[root@server1 ~]# ls -l soft10 
lrwxrwxrwx. 1 root root 6 Jun 16 17:30 soft10 -&gt; file10
</pre>
      <p>
        Pierwsze znaki, pierwszej kolumny róznią się od siebie w zależności
        od typu plików. Jest jeszcze kilka róznic. Pliki urządzeń nie posiadają
        rozmiaru, tylko dwie liczby oddzielone od siebie przecinkiem. Te liczby
        to numer główny oraz numer poboczny. Numer główny określa rodzaj
        urządzenia, z kolei numer podobczny jest jego unikalny identyfikatorem
        w systemie. Innym rodzajem, jest dowiązanie symboliczne, które nazwa
        wskazuje na ścieżke innego pliku, ale do tego typu plików 
        wrócimy poźniej.
      </p>
      <p>
        Te informacje które są zwracane oprócz nazwy pliku przez polecenie,
        <em>ls</em> z odpowiednią opcją to tak zwane 
        <strong>meta-dane</strong>. Większą ich ilość możemy wyświetlić za
        pomocą polecenia <strong>stat</strong>. Na poniższym przykładzie
        zamieszczono więcej meta-danych zwykłego pliku z poprzedniego przykładu:
      </p>
<pre class="code-block">
[root@server1 ~]# stat anaconda-ks.cfg 
  File: anaconda-ks.cfg
  Size: 1197      	Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d	Inode: 6126703     Links: 1
Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)
Context: system_u:object_r:admin_home_t:s0
Access: 2022-06-16 10:37:11.765639347 +0200
Modify: 2022-06-09 19:59:42.592326645 +0200
Change: 2022-06-09 19:59:42.592326645 +0200
 Birth: 2022-06-09 19:59:42.237318552 +0200
</pre>
      <p>
        Zwykłe pliki na Uniksach nie muszą mieć rozszerzenia, więc aby przed
        uruchomieniem pliku upewnić się co to jest, mamy do dyspozycji takie
        narzędzie jak program <strong>file</strong>, który zbada zawartość
        podanego mu w argumencie pliku. 
      </p>
<pre class="code-block">
[root@server1 ~]# file test 
test: Bourne-Again shell script, ASCII text executable
</pre>
      <p>
        Plik nie ma rozszerzenia <em>.sh</em> a mimo to pozostaje skryptem
        powłoki.
      </p>
      <h2 id="3.2.compressionandarchiving">3.2. Kompresja i archiwizowanie</h2>
      <p>
        Kompresja pozwala na zmnieszenie objętości plików za pomocą
        zaawansowanych algorytmów, dzięki czemu możemy zaoszczędzić miejsce
        na dysku. Wadą takiego przechowywania danych jest dłuższy
        czas oczekiwania na ich gotowość do pracy, ponieważ dane przed tym
        należy zdekompresować. Archizowanie może służyć do zebrania wielu
        małych plików w jeden duży. Na Uniksach możemy wymienić dwa natywne
        narzędzia służące do kompresji i jedno do archiwizowania.
      </p>
      <h3 id="3.2.1.gzip">3.2.1. gzip</h3>
      <p>
        Natywnym i dostępnym na każdym systemie sposobem na kompresje danych
        jest <strong>gzip</strong>. Algorytmy zawarte w tym narzędziu
        kompresują dane, powodując zmniejszenie ich objętość. Narzędzie do 
        każdego skompresowanego pliku dodaje rozszerzenie <em>.gz</em>. Aby 
        skompresować plik wystarczy podać jego nazwę lub ścieżkę do niego jako
        argument poleceniu <em>gzip</em>.
      </p>
<pre class="code-block">
#Plik przed kompresją
[root@server1 ~]# ls -l fstab 
-rw-r--r--. 1 root root 579 Jun 16 11:07 fstab

#Kompresja
[root@server1 ~]# gzip fstab

#Plik po kompresji
[root@server1 ~]# ls -l fstab.gz 
-rw-r--r--. 1 root root 350 Jun 16 11:07 fstab.gz
</pre>
      <p>
        Jak możemy zauważyć rozmiar pliku zmniejszył się. Zwróćmy uwagę na to
        iż narzędzie nie działa na kopii pliki tylko kompresuje bezpośrednio
        podany plik. Aby plik zdekompresować możemy użyć polecenia 
        <strong>gunzip</strong>
      </p>
<pre class="code-block">
[root@server1 ~]# gunzip fstab.gz
</pre>
      <p>
        Dla plików skompresowanych za pomocą polecenia <em>gzip</em>, możemy
        podejrzeć listę skompresowanych plików (w przypadku jednego pliku
        może być to użyteczne do wyświetlenia statystki kompresji) 
        wykorzystując 
        opcje <em>-l</em> i podając jako argument skompresowany plik.
      </p>
<pre class="code-block">
[root@server1 ~]# gzip -l fstab.gz 
         compressed        uncompressed  ratio uncompressed_name
                350                 579  43.7% fstab
</pre>
      <h3 id="3.2.2.bzip">3.2.2. bzip2</h3>
      <p>
        Program <em>bzip2</em> jest obecnie standardem kompresji, wśród wielu
        Uniksów. Jest wolniejszy od <em>gzip</em>, ale skompresowane przez
        niego pliki są mniejsze. Więc pozostaje w naszej gestii, który z nich
        będziemy stosować. Do skompresowanych przez <em>bzip2</em> plików
        dodawane jest rozszerzenie <em>.bz2</em>. A kompresja za pomocą tego
        narzędzia wygląda następująco:
      </p>
<pre class="code-block">
[root@server1 ~]# ls -lh test
-rw-r--r--. 1 root root 250M Jun 17 17:21 test
[root@server1 ~]# bzip2 test 
[root@server1 ~]# ls -lh test.bz2 
-rw-r--r--. 1 root root 210 Jun 17 17:23 test.bz2
</pre>
      <p>
        Dekompresja takiego pliku takiego pliku wyglada analogicznie do
        narzędzia <em>gunzip</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# bunzip2 test.bz2
[root@server1 ~]# ls -lh test 
-rw-r--r--. 1 root root 250M Jun 17 17:25 test
</pre>
      <p>
        W przypadku polecenia <em>bzip2</em> nie mamy możliwośći wyświetlenia
        listy skompresowanych plików (statystyk kompresji).
      </p>
      <h3 id="3.2.3.tar">3.2.3. tar</h3>
      <p>
        Program <strong>tar</strong> nie służy do kompresji, a do archiwizcji.
        Jego zadaniem jest stworzenie jednego pliku z wielu innych plików lub 
        z całego katalogu. Na początku program swojego istnienia program 
        <em>tar</em> domyślnie tworzył archiwa na napędach taśmowych, dlatego
        też jeśli ma on tworzyć archiwum do pliku potrzebna będzie odpowiednia
        opcja, i ta funkcjonalność pozostała po dziś dzień.
      </p>
      <p>
        Opcje tego programu możemy podawać na trzy różne sposoby, wpisując
        z myślnikami każdą opcje po kolei, wypisując opcje pod jednym
        myślnikiem, lub nie używać myślnika w ogóle. Do stworzenia archiwum
        potrzebujemy dwóch opcji, pierwszej <em>-c</em> - tworzącej archiwum
        oraz drugiej <em>-f</em> - nakazujące stworzenie archiwum w podanym
        jako argument opcji pliku. Poniżej znajdują się opisane wyżej użycia
        polecenia <em>tar</em> do stworzenia archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -c -f etc_tarred.tar /etc
tar: Removing leading `/' from member names
[root@server1 ~]# tar -cf etc_tarred1.tar /etc
tar: Removing leading `/' from member names
[root@server1 ~]# tar cf etc_tarred2.tar /etc
tar: Removing leading `/' from member names
</pre>
      <p>
        Zwróćmy uwagę na komunikat programu, który usuwa ze scieżek
        wskazujących pliki (ponieważ użyłem ścieżki bezwzględnej) początkowy
        ukośnik, aby przy wypakowywaniu nie nadpisać ważnych plików 
        systemowych. Warto dodać, iż ja tworzyłem te archiwa jako 
        superużytkownik, w momencie gdy <em>root</em> używa polecenia
        <em>tar</em>, używana jest domyślnie opcja <em>-p</em>, która powoduje
        zachowanie wszystkich atrybutów plików, w przypadku zwykłego
        użytkownika ta opcja musi zostać jawnie podana.
      </p>
      <p>
        Rozpakowanie archiwum wymaga podania opcji <em>-x</em> oraz opcji
        <em>-f</em> ze wskazaniem pliku archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -xf etc_tarred1.tar -C /tmp
[root@server1 ~]# ls -ld /tmp/etc
drwxr-xr-x. 132 root root 8192 Jun 17 15:20 /tmp/etc
</pre>
      <p>
        W tym przykładzie użyłem jeszcze jednej ważnej opcji <em>-C</em>, która
        nakazuje poleceniu <em>tar</em> zmianę katalogu przed wypakowaniem
        archiwum.
      </p>
      <p>
        Za pomocą opcji <em>-t</em>, możemy podejrzeć zawartość archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -tvf etc_tarred2.tar
drwxr-xr-x root/root         0 2022-06-17 15:20 etc/
lrwxrwxrwx root/root         0 2022-06-09 19:47 etc/mtab -&gt; ../proc/self/mounts
-rw-r--r-- root/root       579 2022-06-09 19:44 etc/fstab
-rw------- root/root         0 2022-06-09 19:44 etc/crypttab
drwxr-xr-x root/root         0 2022-06-09 19:47 etc/lvm/
drwxr-xr-x root/root         0 2022-06-09 19:44 etc/lvm/devices/
-rw-r--r-- root/root       286 2022-06-09 19:44 etc/lvm/devices/system.devices
drwx------ root/root         0 2022-06-09 20:48 etc/lvm/archive/
-rw------- root/root      1891 2022-06-09 20:48 etc/lvm/archive/rhel_00000-557804270.vg
drwx------ root/root         0 2022-06-09 20:48 etc/lvm/backup/
-rw------- root/root      1890 2022-06-09 20:48 etc/lvm/backup/rhel
drwx------ root/root         0 2022-02-16 13:01 etc/lvm/cache/
-rw-r--r-- root/root    111694 2022-02-16 13:01 etc/lvm/lvm.conf
-rw-r--r-- root/root      2299 2022-02-16 13:01 etc/lvm/lvmlocal.conf
...
</pre>
      <p>
        Chcąc dodać plik do archiwum, wystarczy użyć opcji <em>-r</em> nie
        trzeba go rozpakowywać i dodawać tych plikiów wystarczy wskazać
        archiwum a następnie pliki, które chce się dodać. Plik zostanie dodany
        na koniec archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -rvf etc_tarred2.tar vipractice.bz2 
vipractice.bz2

[root@server1 ~]# tar -tvf etc_tarred2.tar
...
-rw-r--r-- root/root       208 2022-06-09 19:46 etc/.updated
-rw-r--r-- root/root       307 2022-06-16 18:38 vipractice.bz2
</pre>
      <p>
        Dodawaniu plików do archiwum nie służy wyłącznia opcja <em>-r</em>, ale
        również
        <em>-u</em>, która dodaje nowsze pliki na końcu archwium.
        Wyświetlając zawrtość takiego archiwum, możemy zobaczyć pliki o tych
        samych nazwach. Te nazwy oczywiście odpowiadają różnym wersjom tych
        plików.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -uvf etc_tarred.tar /etc/nanorc
tar: Removing leading `/' from member names
/etc/nanorc
tar: Removing leading `/' from hard link targets

[root@server1 ~]# tar -tvf etc_tarred2.tar
...
-rw-r--r-- root/root       208 2022-06-09 19:46 etc/.updated
-rw-r--r-- root/root     10373 2022-06-19 09:47 etc/nanorc
</pre>
      <p>
        Po zebraniu wszystkich plików do archiwum, może okazać się że jest to
        sporych rozmiarów plik. Polecenie <em>tar</em>, pozwala na zastosowanie
        poznanych wcześniej algorytmów kompresji podczas tworzenia archwium.
      </p>
      <ul>
        <li><strong>gzip:</strong> opcja <em>-z</em>
<pre class="code-block">
[root@server1 ~]# tar -czf etc-gzipped.tar.gz /etc
</pre>
        </li>
        <li><strong>bzip2:</strong> opcja <em>-j</em>
<pre class="code-block">
[root@server1 ~]# tar -cjf etc-bzipped.tar.bz2 /etc
</pre>
        </li>
      </ul>
      <p>
        Rozpakowując skompresowane archiwa w RHEL możemy rozpakować podając
        takie same opcje jak w przypadku nie skompresowanych archiwów.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -xf etc-gzipped.tar.gz -C /tmp
</pre>
      <p>
        Program rozpozna po zawartości pliku algortym kompresji. Wiecej
        informacji na temat polecenia <em>tar</em> znajduje na stronie
        podręcznika.
      </p>
      <p class="exam_tip">
        Na egzaminie będziemy mieć określną ilość czasu na wykonanie zadań
        egzaminacyjnych, dlatego też operacje kompresji czy archiwizacji
        plików będą przeprowadzane na małych plikach, aby nie tracić czasu.
      </p> 
      <h2 id="3.3.vim">3.3. Edycja plików za pomocą edytora Vim</h2>
      <p>
        Podczas wykonywania zadań związanych z administracją system, niezbędna
        może być edycja jakiegoś pliku. Edytor <strong>Vim</strong> jest 
        standardem jeśli
        chodzi o edycje plików. Ten edytor w wersji podstawowej jaką jest
        program <em>Vi</em> jest dostępny w większości Uniksów. W przypadku
        w wielu dystrybucji Linuksa preinstalowany jest <em>Vim</em>. Lepiej
        jest nauczyć się rozwiązania, które możemy zastosować beż żadnej
        ingerencji w system (bez instalacji ulubionego edytora, który znamy).
      </p>
      <p>
        Edytor <em>Vim</em> może działać w trzech trybach:
      </p>
      <ul>
        <li><strong>tryb poleceń</strong> - domyślny tryb pracy programu,
          <em>Vim</em> oczekuje na wprowadzenie polecenia. Ten tryb jest
          uruchamiany w momencie uruchomienia programu. Polecenia są
          przypisane do poszczególnych znaków na klawiaturze.</li>
        <li><strong>tryb wprowadzania</strong> - tryb ten służy do edycji
          tekstu, uruchamiany za pomocą polecenia <em>i</em> lub <em>a</em>.</li>
        <li><strong>tryb ostatniej lini</strong> - ten tryb możemy również
          nazwać wierszem polecenia. Urchamiany jest poprzez wciśnięcie
          dwukropka (<strong>:</strong>) w trybie poleceń. Po tym znaku
          podajemy polecenie.</li> 
      </ul>
      <h3 id="3.3.1.startingvim">3.3.1. Podstawy obsługi Vim</h3>
      <p>
        Edytor vim uruchamiamy, jak każde inne polecenie. Podając jego nazwę
        w wierszu polecenia. Podczas uruchamiania możemy podać plik jako
        argument, lub też użyć polecenia trybu ostatniej linii <em>:o</em>
        po czym podać ścieżkę do pliku.
      </p>
<pre class="code-block">
[root@server1 ~]# vim test.txt
</pre>
      </p>
        Poruszanie po tekscie odbywa się w trybie poleceń za pomocą klawiszy:
      </p>
      <ul>
        <li><strong>h</strong> - przesunięcie kursora w lewo</li>
        <li><strong>j</strong> - przesunięcie kursora w dół</li>
        <li><strong>k</strong> - przesunięcie kursora w górę</li>
        <li><strong>l</strong> - przesunięcie kursora w prawo</li>
      </ul>
      <p>
        Przejście do edycji tekstu, wymaga użycia polecenia <strong>i</strong> 
        co spowoduje rozpoczęcie edycji w pozycji kursora lub polecenia 
        <strong>a</strong>, które spowoduje przesunięcie kursora o jedną 
        pozycję i rozpoczęcie edycji, polecenie <em>a</em> możemy tłumczyć 
        jako dopisywanie (ang. <em>append</em>), a <em>i</em> jako wprowadzanie 
        (ang. <em>insert</em>).
      </p>
      <p>
        Opuszczenie trybu wprowadzania i powrót do trybu polecenia wymaga
        naciśnięcia klawisza <em>Esc</em> (<em>escape</em>). Przjście do trybu 
        polecenia
        jest wymagane, aby przenieść kursor w inne miejsce. W tym trybie 
        również poprzez polecenia ostatniej linii zapisujemy zmiany w pliku
        oraz opuszczamy edytor. Zmiany w tekscie również możemy
        porzućić, nie musimy ich zapisywać poniżej umieściłem kilka poleceń
        trybu ostatniej linii, służacych od zapisywania i opuszczania edytora.
      </p>
      <ul>
        <li><strong>:w</strong> - zapisanie zmian w pliku oraz pozostanie w
          w edytorze</li>
        <li><strong>:x</strong> - zapisanie zmian w pliku oraz opuszczenie
          <em>Vim</em></li>
        <li><strong>:q</strong> - opuszczenie <em>Vim</em>.</li>
      </ul>
      <p>
        Każdej z tych opcji może towarzyszyć wykrzyknik (<strong>!</strong>),
        więc jeśli chcielibyśmy porzucić zmiany w pliku i wyjść należy użyć
        polecenia <em>:q!</em>. Możemy czasami spotkać się z uprawnieniami,
        które nie pozwolą nam zapisać zmian w pliku. Rozwiązać tego typu
        problem możemy dwa sposoby, wymusić zapisanie zamian za pomocą
        wykrzyknika (działa to tylko w przypadku, gdy superużytkownik chce
        zapisać zmiany w pliku tylko odczytu), lub podać ścieżkę do nowego 
        pliku poleceniu <em>:w</em>.
      </p>
      <h3 id="3.3.2.othervimcommands">3.3.2. Pozostałe polecenia Vim</h3>
      <p>
        Vim posiada bogatą kolekcję poleceń trybu poleceń oraz trybu ostatniej
        linii, na poniższej liście znajdują się część z nich, możemy
        wykorzystać je do sprawniejszego używania edytora <em>Vim</em>.
      </p>
      <p><strong>Komendy trybu poleceń:</strong></p>
      <ul>
        <li><strong>^ - Shift + 6</strong> - Przeniesie kursora na początek
          linii.</li>
        <li><strong>$ - Shift + 4</strong> - Przeniesie kursora na koniec 
          linii.</li>
        <li><strong>Ctrl+f</strong> - przewinięcie tekstu o jedną stronę w
          przód.</li>
        <li><strong>Ctrl+b</strong> - przewinięcie tesktu o jedną stronę w
          tył.</li>
        <li><strong>x</strong> - usunięcie znaku wskazywanego przez kursor,
          znak tak naprawdę zostaje wycięty i poźniej może zostać wklejony.</li>
        <li><strong>dd</strong> - usunięcie/wycięcie całej linii, linia
          podobnie jak znak może zostać wklejona.</li>
        <li><strong>v</strong> - przejście <em>Vim</em> w tryb wizualny
          (tutaj nie omawiany), pozwala zaznaczać tekst co ułatwia kopiowanie
          oraz wycinanie.</li>
        <li><strong>y</strong> - kopiowanie zaznaczenia w trybie wizualnym.</li>
        <li><strong>d</strong> - wycinanie/usuwanie w trybie wizualnym.</li>
        <li><strong>p</strong> - wklejanie.</p>
        <li><strong>u</strong> - cofnięcie się o jedną zmianę, odpowiednik
          <em>Ctrl+z</em>.</li>
        <li><strong>Ctrl+r</strong> - tzw. <em>redo</em>, powrót do stanu przed
          cofnięciem zmiany. Czasami bardzo przydatna funkcja.</li>
        <li><strong>. - kropka</strong> - powtórzenie ostatniego polecenia.
          Jeśli ostatnim poleceniem było wprowadzanie, to polecenie wklei
          cały wprowadzony tekst do momentu zmiany polecenia.</li>
        <li><strong>/ - slash</strong> - przeszukiwanie tekstu w przód.</li>
        <li><strong>? - znak zapytania</strong> - przeszukiwanie tekstu w tył.</li>
        <li><strong>n</strong> - następne wystąpienie frazy w tekście</li>
        <li><strong>N</strong> - poprzednie wystąpienie frazy w tekscie. W
          przypadku przeszukiwania w tył, działanie poleceń <em>n</em> oraz
          <em>N</em> jest odwrócone.</li>
      </ul>
      <p>
        W przypadku tryb poleceń, możemy zwielokrotnić działanie tych poleceń,
        wprowadzając liczbę wykonywania tego polecenia przed poleceniem. Na 
        przykład jeśli chcemy
        usunąć 3 linie to zamiast wydawać trzykrotnie polecenie <em>dd</em>,
        możemy nacisnąć <em>3</em> następnie <em>dd</em> i trzy linie spod
        kursora zostaną usunięte/wycięte.
      </p>
      <p><strong>Polecenia trybu ostatniej linii:</strong></p>
      <ul>
        <li><strong>:set number</strong> - włącza numerowanie linii.</li>
        <li><strong>:o</strong> - otwiera plik, jako argument podajemy ścieżkę
          do pliku.</li>
        <li><strong>:%s/old/new</strong> - zamiana pierwszego wstąpienia słowa 
          <em>old</em> słowem <em>new</em>.</li>
        <li><strong>:%s/old/new/g</strong> - zamiana wszystkich wystąpień słowa
          <em>old</em> słowem <em>new</em>.</li>
        <li><strong>:6,11co4</strong> - polecenie kopiuje zawartość linii od
          6 do 11 i wkleja ją po 4 linii.</li>
        <li><strong>:3,5m6</strong> - polecenie przenosii linię od 3 do 5 na
          miejsce po linii numer 6.</li>
        <li><strong>:6,8d</strong> - polecenie usuwa linie od 6 do 8.</li>
        <li><strong>:r</strong> - polecenie wprowadza w miejscu kursora
          zawartość pliku podanego jako argument.
      </ul>
      <p>
        Podczas korzystania <em>Vim</em> istotna jest praktyka. Dlatego trzeba
        przesiąść się na niego i zacząć tworzyć w nim pliki.
      </p>
      <p class="exam_tip">
        Podczas egzaminu, możemy spotkać się z zadaniem w którym trzeba
        zmienić jakiś plik. Dostępność <em>Vim</em> na maszynie
        egzaminacyjnej jest niemal pewna, dlatego też nauczenie się jego 
        obsługi jest dość istotne.
      </p>
      <h2 id="3.4.filesanddirectories">3.4. Pliki i katalogi</h2>
      <p>
        Jaka kolwiek praca z komputerem prędzej czy poźniej będzie wymagać
        operacji na plikach i katalogach. Poniżej przedstawiam najprostsze
        czynności takie możemy wykonywać na tych elementach. 
      </p>
      <h3 id="3.4.1.createfilesanddirs">3.4.1. Tworzenie plików i katalogów</h3>
      <p>
        Tworzenie plików może zrealizować na kilka sposób. Jednym z nich jest
        wykorzystanie polecenia <strong>touch</strong>, które służy generalnie
        do uaktualnienia czasów dostępu oraz modyfikacji, jednak kiedy podany
        plik nie istnieje to zostanie on utworzony przez to polecenie.
      </p>
<pre class="code-block">
[root@server1 ~]# touch plik1
[root@server1 ~]# ls -l plik1
-rw-r--r--. 1 root root 0 Jun 19 14:52 plik1
</pre>
      <p>
        Jak widać na powyższym przykładzie został utworzony plik, którego
        wielkość to całe 0 bajtów. Innym sposobem na utworzenie katalog jest
        wykorzystanie polecenia <em>Vim</em>, w którym zapisując zmiany w 
        nowym pliku, tworzymy go mimochodem. Ostanim ze sposobów jest
        utworzenie plików ze strumienia (stumienie będą opisywane w dalszej
        części tego materiału), za pomocą polecenia <strong>cat</strong>,
        które omówimy sobie w następnym podrozdziale. Wydając następujące
        polecenie:
      </p>
<pre class="code-block">
[root@server1 ~]# cat &gt; plik2
test1
test2
test3
test4
test5
</pre>
      <p>
        Uruchamiając to polecenie przełączymy strumienie tak, aby wszystko
        co zostanie wpisane do terminala trafi do pliku (w dużym skrócie). Taką
        edycję pliku możemy zakończyć naciskając kombinacje klawiszy
        <em>Ctrl+d</em>.
      </p>
      <p>
        Za tworzenie katalogów odpowiedzialne jest polecenie 
        <strong>mkdir</strong>. Polecenie to utworzy katalog o nazwie podanej
        jako argument. Ważną opcją tego polecenia jest <em>-p</em>, za pomocą
        które jesteśmy wstanie tworzyć z poziomu pojedyńczego polecenia całe
        struktury katalogów. Opcja ta powoduje utworzenie katalogów podanych
        na ścieżce, które nie istnieją.
      </p>
<pre class="code-block">
[root@server1 ~]# mkdir dir1
</pre>
      <h3 id="3.4.2.listingfiles">3.4.2. Wyświetlanie zawartości pliku</h3>
      <p>
        Na Uniksach do wyświetlania zawartości plików mamy kilka rozwiązań
        pierwszym z nich jest wspomnianie już polecenie <strong>cat</strong>.
        Polecenie wyświetli zawartość pliku podanego jako argument w terminalu.  
      </p>
<pre class="code-block">
[root@server1 ~]# cat plik2 
test1
test2
test3
test4
test5
</pre>
      <p>
        Na Uniksach, obok polecenia <em>cat</em> występuje polecenie
        <strong>tac</strong>, które ma takie samo zastosowanie jak to wyżej
        wymienione, wyświetlając jednak zawartość plik odwrotnie od końca. 
        Poniższy przykład zaraz to zobrazuje:
      </p>
<pre class="code-block">
[root@server1 ~]# tac plik2 
test5
test4
test3
test2
test1
</pre>
      <p>
        Podczas wyświetlania dużych plików ich zawartość może mieścić się na
        ekranie, czy też w oknie terminala. Do wyświetlania tego typu plików
        wykorzystuje się takie polecenia jak <strong>more</strong> czy
        <strong>less</strong>. Oba dzielą wyświetloną treść plików na strony
        wielkości ekranu bądź terminala. Program <em>more</em> nie jest za
        bardzo zaawansowanym narzędziem, wyświetlając pliki za jego pomocą nie
        mamy zbyt dużego pola manewru. Możemy przesuwać stronę po stronie, do
        końca pliku. Dlatego też znacznie lepszym rozwiązaniem jest
        wykorzystanie polecenia <em>less</em>, który pozwala poruszać się
        po tekscie w góre i w dół, ale również pozwala na wyszukiwanie fraz 
        w tekscie, możemy również nawigować po za pomocą klawiszy znanych z 
        programu <em>Vim</em>. Program <em>less</em> uruchomi się szybciej niż,
        program <em>more</em>, ponieważ nie musi on załadować całego pliku od 
        razu.
      </p>
<pre class="code-block">
[root@server1 ~]# less /var/log/messages
</pre>
      <p>
        Ostatnim już sposobem na wyświetlenie zawartości plików jest, użycie
        polecenia <strong>head</strong> oraz <strong>tail</strong>, ich
        zadaniem jest wyświetlenie kilku początkowych (domyślnie 10) linii
        z podanego jako argument pliku - polecenie <em>head</em> lub kilku
        ostatnich (również 10) linii z podanego pliku - polecenie <em>tail</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# tail /var/log/messages
Jun 19 13:59:33 server1 systemd[1]: Finished dnf makecache.
Jun 19 14:18:23 server1 cupsd[964]: REQUEST localhost - - "POST / HTTP/1.1" 200 182 Renew-Subscription successful-ok
Jun 19 15:16:43 server1 cupsd[964]: REQUEST localhost - - "POST / HTTP/1.1" 200 182 Renew-Subscription successful-ok
Jun 19 15:28:22 server1 systemd[1]: Starting dnf makecache...
Jun 19 15:28:23 server1 dnf[2173]: Updating Subscription Management repositories.
Jun 19 15:28:23 server1 dnf[2173]: Unable to read consumer identity
Jun 19 15:28:23 server1 dnf[2173]: This system is not registered with an entitlement server. You can use subscription-manager to register.
Jun 19 15:28:23 server1 dnf[2173]: Metadata cache refreshed recently.
Jun 19 15:28:23 server1 systemd[1]: dnf-makecache.service: Deactivated successfully.
Jun 19 15:28:23 server1 systemd[1]: Finished dnf makecache.
</pre>
      <p>
        Domyślną ilość wypisywanych linii możemy regulować poprzez podanie po
        myślniku (<strong>-</strong>) żądanej liczby.
      </p>
<pre class="code-block">
[root@server1 ~]# tail -5 /var/log/messages
Jun 19 15:28:23 server1 dnf[2173]: Unable to read consumer identity
Jun 19 15:28:23 server1 dnf[2173]: This system is not registered with an entitlement server. You can use subscription-manager to register.
Jun 19 15:28:23 server1 dnf[2173]: Metadata cache refreshed recently.
Jun 19 15:28:23 server1 systemd[1]: dnf-makecache.service: Deactivated successfully.
Jun 19 15:28:23 server1 systemd[1]: Finished dnf makecache.
</pre>
      <p>
        Polecenie <em>less</em> ma jedną bardzo istoną opcję, która pozwala
        śledzić na bierząco zmiany w pliku, ta opcja to <em>-f</em>.
      </p>
      <p>
        Poleceniem związanym z zawartością plików, ale nie z jej wyświetlaniem
        może być polecenie <strong>wc</strong>, które domyślnie wyświetla
        ilość linii, liczbe słów oraz bajtów. 
      </p>
<pre class="code-block">
[root@server1 ~]# wc /var/log/messages
  639  7503 61333 /var/log/messages
</pre>
      <h3 id="3.4.3.copyingandmoving">3.4.3. Kopiowanie i przenoszenie plików
        i katalogów</h3>
      <p>
        Pracując z plikami, być może wystąpi potrzeba skopiowania danych bądź
        przeniesienia danych w inne miejsce. Za operację kopiowania
        odpowiedzialnie jest polecenie <strong>cp</strong>. Jako pierwszy
        argument przyjmuje ono ścieżkę lub plik źródłowy, jako drugi ścieżkę
        lub plik docelowy.
      </p>
<pre class="code-block">
[root@server1 ~]# cp plik2 plik3
</pre>
      <p>
        W przypadku gdy dany plik już istnieje w podanym katalogu polecenie
        zapyta się czy nadpisać docelowy plik, ale tylko w przypadku
        superużytkownika, bowiem on w konfiguracji swojej powłoki posiada 
        <em>alias</em> (nazwę zastępcza) <em>cp</em> dla polecenia 
        <em>cp -i</em>, opcja <em>-i</em> włącz tryb interaktywy, czyli właśnie
        takie pytania.
      </p>
<pre class="code-block">
[root@server1 ~]# cp plik1 plik3 
cp: overwrite 'plik3'? n
</pre>
      <p>
        Za pomocą polecenia <em>cp</em> możemy kopiować całe katalogi z
        podkatalogami przy użyciu opcji <em>-r</em>, która włącza kopiowanie
        rekurencyjne. Jeśli atrybuty plików są dla nas ważne, to żeby nie
        nadpisać ich należy użyć opcji <em>-p</em>.
      </p>
      <p>
        Za przenoszenie plików odpowiedzialne jest polecenie 
        <strong>mv</strong>, które ma jeszcze jedną ważną cechę ukrytą w
        mechanice swojego działa. Otóż jeśli będzie przenosić plik lub katalog
        w ramach tego samego katalogu, to zmieni on tylko swoją nazwę.
      </p>
      <p>
        Polecenie <em>mv</em> w przypadku superużytkownika, posiada podobny
        alias co w przypadku polecenia <em>cp</em>, polecenie jest uruchamiane
        domyślnie z opcją pytającą o nadpisanie elementu docelowego.
      </p>
<pre class="code-block">
[root@server1 ~]# mv plik1 plik3 
mv: overwrite 'plik3'? n
</pre>
      <p>
        Polecenie <em>mv</em> nie potrzebuje żadnej opcji, aby
        przenieść cały katalog wraz z podkatalogami.
      </p>
<pre class="code-block">
[root@server1 ~]# mv gzipped /tmp
[root@server1 ~]# ls -ld /tmp/gzipped/
drwxr-xr-x. 3 root root 17 Jun 16 18:14 /tmp/gzipped/
</pre>
      <h3 id="3.4.5.removefilesanddirs">3.4.5. Usuwanie plików i katalogów</h3>
      <p>
        Zbędne plik i katalogi możemy usunąć, za pomocą polecenia <em>rm</em>.
        Polecenie do usunięcie katalogu wymaga podania nazwy pliku jako
        argumentu.
      </p>
<pre class="code-block">
[root@server1 ~]# rm plik1 
rm: remove regular empty file 'plik1'? y
</pre>
      <p>
        Polecenie <em>rm</em> również jest aliasem, z tą samą opcją co
        <em>cp</em> czy <em>mv</em>. Aby usunąć cały katalog wraz
        podkatalogami, należy użyć kolejno opcji <em>-r</em> -
        uruchamiającej usuwanie rekurencjne oraz opcji <em>-f</em>,
        wymuszające odpowiedź <em>y</em> na wszystkie pytania.
      </p>
<pre class="code-block">
[root@server1 ~]# rm -rf /tmp/etc
</pre>
      <p>
        Usuwanie plików i katalogów posiadając uprawnienia superużytkownika,
        może skończyć się katastrofą. Pomyłka w tym poleceniu może uszkodzić
        system. Dlatego też należy zachować szczególną ostrożność przy
        korzystaniu z tego polecenia, a w szcególności w połączeniu z
        <strong>nazwami wieloznacznymi</strong> (będzie o tym przy okazji
        omawiania powłoki BASH).
      </p>
      <p>
        Do usuwania pustych katalogów, możemy użyć polecenia 
        <strong>rmdir</strong>, jak i opcji <em>-d</em> polecenia <em>rm</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# rm -d dir1/
rm: remove directory 'dir1/'? y
[root@server1 ~]# rmdir dir2
</pre>
      <p class="exap_tip">
        Polecenia manipulacji plikami są podstawowymi czynnościami związnymi
        z administracją każdego Uniksa, więc warto przyswoić wiedzę zebraną
        w tym podrozdziale. 
      </p>
      <h2 id="3.5.links">3.5. Dowiązania</h2>
      <p>
        Wśród systemów uniksowych, możemy w kategoriach manipulacji plikami
        wyróżnić takie elementy jak <strong>dowiązania</strong>. Dowiązania
        są najprościej rzecz biorąc są elementami, które wskazują na inne pliki.
        Dowiązania możemy podzielić na <strong>twarde</strong> oraz 
        <em>symboliczne</em>.
      </p>
      <h3 id="3.5.1.hardlinks">3.5.1. Dowiązania twarde</h3>
      <p>
        <strong>Twarde dowiązania</strong> nie są same w sobie stricte plikami.
        Pliki bowiem znajdują na urządzeniach służacych do przechowywania
        danych. Systemy plików przechowują meta-dane plików, ich atrybuty oraz
        informacje w jakich obszarch, której z pamięci masowych należy szukać
        zawartości pliku, aby ludzie mogli się nimi posługiwać używa się nazw
        plików. Taką własnie nazwą jest twarde dowiązanie. Dla eksperymentu
        utworzymy pusty plik, o nazwie <em>hard1</em>, oto jego artybuty
      </p>
<pre class="code-block">
[root@server1 ~]# ls -li hard1 
6043841 -rw-r--r--. 1 root root 0 Jun 19 17:31 hard1
</pre>
      <p>
        Pierwsza kolumna zawiera numer <strong>i-node</strong> jest to 
        identyfikator
        wpisu w bazie danych systemu plików, ktory zawiera meta-dane na
        temat pliku. W trzeciej kolumnie atrybutów znajduje się wartość
        <code class="code-inline">1</code>. Ta kolumna przedstawia ilość
        dowiązań twardych. Każdy zwykły plik posiada co najmniej jedno 
        dowiązanie - identyfikującą bezpośrednio plik nazwę. Tworząc kolejne
        twarde dowiązanie, podłączamy kolejną nazwę tego pliku. Teraz utworzmy
        dowiązanie o nazwie <em>hard2</em> do pliku <em>hard1</em>. Dowiązania
        tworzymy za pomocą polecenia <strong>ln</strong>.
      </p>
<pre class="code-block">
[root@server1 ~]# ln hard1 hard2
[root@server1 ~]# ls -li hard*
6043841 -rw-r--r--. 2 root root 0 Jun 19 17:31 hard1
6043841 -rw-r--r--. 2 root root 0 Jun 19 17:31 hard2
</pre>
      <p>
        Zwróć my uwagę na to, iż <code class="code-inline">hard2</code>
        wskazuje na ten sam numer <em>i-node</em>, czyli wskazuje na ten sam
        pliki. Liczba dowiązań uległa zmianie tak samo w przypadku
        <code class="code-inline">hard1</code> jak i 
        <code class="code-inline">hard2</code>, ponieważ na ten sam plik
        wskazują dwa dowiązania. Zawartość pliku możemy zmieniać odwołując
        czy to do <em>hard1</em> czy <em>hard2</em>, tak samo jest 
        z atrybutami, ponieważ obie nazwy wskazują na ten sam węzeł
        <em>i-node</em> (wpis w bazie danych systemu plików), jeśli usuń my 
        teraz plik <em>hard1</em>, to tak naprawdę usuniemy jedno z dowiązań.
      </p>
<pre class="code-block">
[root@server1 ~]# rm hard1
rm: remove regular empty file 'hard1'? y
[root@server1 ~]# ls -li hard*
6043841 -rw-r--r--. 1 root root 0 Jun 19 17:31 hard2
</pre>
      <p>
        Dowiązania twarde mogą powodować bałagan w plikach, ponieważ mimo
        usunięcia on dalej istnieje pod inną nazwą. Dopiero usunięcie
        wszystkich dowiązań, ostatecznie kończy egzystencje pliku w pamięci
        masowej, ponieważ systemy plików, pliki bez dowiązań uznają za
        nie potrzebne i realokują miejsce przechowania zawartości tego pliku.
      </p>
      <h3 id="3.5.2.symlinks">3.5.2. Dowiązania symboliczne</h3>
      <p>
        Innym rodzajem dowiązań jest <strong>dowiązanie symboliczne</strong>.
        Często są one porównywane do skrótów znanych z systemów Windows i tak
        na prawdę taka jest ich rola. Dowiązania symboliczne mają wskazywać
        na inne pliki. W przeciwieństwie do dowiązań twardych, te dowiązania
        są jednak odrębnymi plikami (tak jakby), posiadają one bowiem wpis
        w bazie danych systemu plików, ale w miejscu przeznaczonym na adres
        przechowywania danych pliku na dysku lub innej pamięci znajduje się
        scieżka do pliku źródłowego, na który wskazuje dowiązanie. Zatem tego
        rodzaju elementy mają własne atrybuty. Wielkość dowiązania
        symbolicznego zależy od ilość znaków na ścieżce do pliku źródłowego.
        Dowiązania symboliczne tworzymy za pomocą tego samego narzędzia co
        dowiązania twarde, dodając tylko opcję <em>-s</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ ln -s symfile symlink1
[user@server1 ~]$ ls -l symlink1
lrwxrwxrwx. 1 user user 7 Jun 20 19:28 symlink1 -&gt; symfile
</pre>
      <p>
        Dowiązania symboliczne mogą być wydawać się, że są w wstanie zastąpić
        kopiowanie. Kopiując plik, odwzrowywuje się jego zwartość w innym
        miejscu na pamięci masowej, tworząc odrębny nienaruszony plik. Tworząc
        dowiązanie, podłączamy się pod istniejący już plik, który może być
        zmieniony
        nie tylko przez użytkowników, ale też programy. Dowiązania 
        symbolicznego
        możemy użyć jak wymienionego wcześniej skrótu, chcąc zaoszczędzić
        sobie pisania długich ścieżek do odrębnych miejsc w systemie
        ewentualnie ułatwić pisanie ścieżek w skryptach oraz programach.
      </p>
      <p>
        Przechodząc do folderu wskazywanego przez dowiązanie symboliczne
        wyświetlimy scieżkę obecnego katalogu roboczego, zobaczymy ścieżkę
        z uwzględeniem tego dowiązania. Aby odkryć prawdziwą ścieżkę należy
        polecenia <strong>pwd</strong> z opcją <em>-P</em>.
      </p>
      <h3 id="exec3.1">Ćwiczenie 1: Archiwa</h3>
      <p>
        Na maszynie <em>server1</em> jako zwykły użytkownik, utwórz
        skompresowane za pomocą programu <em>gzip</em> archiwum z zawartością
        katalogu <em>/etc</em>. Powtórz czynność tym razem z użyciem programu
        <em>bzip2</em>. Porównaj wielkość tych archiwów. Na koniec rozpakuj
        oba archiwa bez zaznaczania algorytmu kompresji (bez podawania
        odpowiedniej opcji).
      </p>
      <h3 id="exec3.2">Ćwiczenie 2: Praktyka z Vim-a</h3>
      <p>
        Na maszynie <em>server1</em> jako zwykły użytkownik, utworz przepisując
        treść ćwiczenia nr. 1, każde zdanie w odrębnej linii, zapisz zmiany w 
        pliku o nazwie <em>vimpractice</em> i zamknij edytor. Otwórz plik w
        edytorze ponownie, wyświetl numery linii. Skopiuj linię 2 i 3 na koniec
        pliku, tak aby było łącznie 6 linii. Przenieś linię nr. 3 w miejsce
        pierwszej. Przejdź na koniec pliku i dodaj do niego zawartośc w pliku
        <em>.bash_profile</em> (znajdziesz go w katalogu domowym użytkownika).
        Zamień wszystkie wszystkie wystąpienia słowa <em>profile</em> na
        <em>pro file</em>. Usuń linię od 5 do 8, zapisz zmiany w pliku i
        opuść edytor. Na koniec wyświetl podsumowanie pliku za pomocą polecenia
        <em>wc</em>.
      </p>
      <h3 id="exec3.3">Ćwiczenia 3: Manipulacja plikami</h3>
      <p>
        Na maszynie <em>server1</em> jako zwykły użytkownik, utwórz jeden
        dowolny plik oraz jeden katalog, wyświetl ich atrybuty, sprawdź
        uprawnienia, nazwę właściciela oraz grupę do której ten plik należy.
        Co się stanie gdy spróbujesz przenieść utworzony wcześniej plik do
        katalogu <em>/var/log</em>. Przenieś plik oraz katalog do katalogu
        <em>/tmp</em>. Utwórz duplikat pliku i zmień jego nazwę na jakąkolwiek 
        inną. Usuń wszystkie pliki utworzone na potrzeby tego ćwiczenia.
      </p>
      <h2 id="ch3summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy się, z typowymi zadaniami związanymi z
        administracją plikami w systemie. Poznaliśmy edytor Vim, którego
        nauka wymaga zachodu, aczkolwiek nie pójdzie ona na marne. Ten edytor
        w uboższej podstawowej wersji w postaci programu <em>Vi</em> 
        spotkamy w każdym Uniksie, zatem będzie potrafili sprawnie edytować
        pliki w każdym systemie, niezależnie od tego czy nasz ulubiony edytor
        jest dostępny. Ciekawszą rzeczą w tym rodziale z pewnością były 
        dowiązania symboliczne. W następnym rodziale skupimy się na
        uprawnieniach plików i katlogów, oraz przekonamy się jak potężnym
        narzędziem jest polecenie <em>find</em>.
      </p>
      <h1 id="4.advancedfilemanagement">4. Zaawansowane zarządzanie plikami</h1> 
      <p>                                                                       
        W Uniksach możemy zabezpieczyć pliki i katalogi przed ingerencją 
        innych użytkowników. Służą temu specjalny rodzaj zabezpieczeń jakim są   
        uprawnienia.                                                            
      </p>                                                                      
      <h2 id="4.1.basicspermission">4.1. Uprawnienia podstawowe</h2>            
      <p>                                                                       
        Uprawnienia przypisywane są w trzech klasach, klasie użytkownika        
        (<strong>u</strong>) nazwywanego również właścicielem elementu; grupie  
        (<strong>g</strong>), do której należy ten plik oraz                    
        oraz innym użytkownikom systemu (<strong>o</strong>), ta klasa          
        uprawnień jest również oznaczna jako uprawnienia publiczne.             
      </p>                                                                      
      <p>                                                                       
        Każdej z tych klas możemy przypisać odpowiednie uprawniania takie jak:  
        prawo do odczytu (<strong>r</strong>), prawo do zapisu                  
        (<strong>w</strong>) oraz prawo do wykonania (<strong>x</strong>).
      </p>
      <p>
        Za nim zaczniemy zmieniać uprawnienia, nauczymy się je identyfikować.
        Uprawnienia do pliku możemy wyświetlić za pomocą polecenia <em>ls -l</em>
        lub polecenia <em>stat</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l file1
-rw-r--r--. 1 user user 0 Jun 21 14:21 file1
</pre>
      <p>
        Upraweniania znajdują się w pierwszej kolumnie:
        <code class="code-inline">-rw-r--r--.</code>, łącznie 11 znaków, ale
        nas będzie interesować tylko 9 w środku. Pierwszy znak oznacza typ 
        pliku, natomiast kropka związana jest z kontekstem <em>SELinux</em>,
        nie będziemt się teraz tym zajmować. Te dziewieć pól są to miejsca
        przeznaczone na uprawnienia poszczególnych klas. Pierwsze trzy pola 
        z lewej to uprawnienia użytkownika (właściciela), kolejne trzy pola
        to uprawnienia grupy do której należy ten plik natomiast pozostałe 
        trzy to uprawnienia publiczne, stosowane wobec użytkowników nie
        związanych z tym elementem. Uprawnienia przypisane każdej z klas
        układają się kolejno w <em>rwx</em>, myślnik na którymś z tych miejsce
        oznacza brak takiego prawa w danej klasie.
      </p>
      <p>
        Każde z określonych praw pozwala nam, na wykonanie innych czynności
        związanych z tym elementem. Prawo <em>read</em> pozwala na odczyt
        zawartości pliku oraz jego skopiowanie, w przypadku
        katalogów pozwala na wyświetlenie jego zawartości. Prawo <em>write</em>
        pozwala na modyfikowanie elementu, wraz z jego usunięciem. Ostatnie
        prawo <em>execute</em> pozwala na uruchomienie pliku o ile jest to
        plik wykonywalny, w przypadku katalogów to prawo jest niezbędne aby
        użytkownik mógł przejść do niego (za pomocą polecenia <em>cd</em>).
      </p>
      <p>
        Zatem w przypadku tego pliku, właściciel może czytać i pisać, a grupa
        oraz wszyscy inni mogą tylko czytać, dla nich wówczas ten plik jest
        plikiem tylko do odczytu.
      </p>
      <p>
        Prawdopodobnie kiedyś bedziemy chcieli ukryć jakieś pliki lub będziemy
        musieli dać uprawnienia jednemu z użytkowników do innych plików
        w systemie, wówczas wymagana będzie zmiana uprawnień.
      </p>
      <p>
        Poszczególnym klasom (<strong>u</strong>, <strong>g</strong>, 
        <strong>o</strong>) możemy nadać (<strong>+</strong>), obebrać
        (<strong>-</strong>)
        lub przypisać (<strong>=</strong>) odpowiednie uprawnienia. Do
        manipulacji uprawnieniami służy polecenie <strong>chmod</strong>, jako
        pierwszy argument przyjmuje on sekwencje zmiany uprawnień (uprawnienia)
        a jako drugi plik lub katalog, którego mają się tyczyć uprawnienia.
      </p> 
      <p>
        Załóżmy, że plik z powyższego przykładu jest skryptem i musimy nadać
        użytkownikowi prawo do wykonania, grupie prawo do zapisu i wykonania
        a pozostałym użytkownikom zabrać uprawnienia, ponieważ ten plik nie
        powinien być stosowany poza grupą. Aby zrealizować tę zmianę
        uprawnień należy wydać poniższe polecenie:
      </p>
<pre class="code-block">
[user@server1 ~]$ chmod u+x,g+wx,o-r file1
</pre>
      <p>
        Po zmianie, uprawnienia do tego pliku prezentują się w następujący
        sposób:
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l file1
-rwxrwx---. 1 user user 0 Jun 21 14:21 file1
</pre>
      <p>
        Zapis uprawnień w tej postacji, który swoją drogą nazwa sie zapisem
        symbolicznym, wymaga dużo pisania. Uprawnienia można zmieniać łatwiej
        jednak wymagać to będzie więcej myślenia. 
      </p>
      <p>
        Każde z omówionych wcześniej praw posiada swoją wagę, te wagi sumują
        się dając uprawnienia dla konkretnej klasy. A więc: prawo do odczytu
        (<strong>r</strong>) posiada wagę <strong>4</strong>, prawo do zapisu
        (<strong>w</strong> posiada wagę <strong>2</strong> a prawo do 
        wykonania (<strong>x</strong>) posiada wagę
        <strong>1</strong>. Brak prawa (<strong>-</strong>) ma wagę 
        <strong>0</strong>. Tak złożone razem sumy tych wag dają uprawnienia
        do pliku czy katalogu. Chcąc określić uprawnienia pliku z pierwszego
        przykładu jescze przed zmianą uprawnień, będą one wynosić:
        <strong>644</strong>.
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l file1
-rw-r--r--. 1 user user 0 Jun 21 14:21 file1
----------------------------------------------
u = rw- = 4 + 2 + 0 = 6
g = r-- = 4 + 0 + 0 = 4
o = r-- = 4 + 0 + 0 = 4
ugo = 644
</pre>
      <p>
        Natomiast uprawnienia po zmianie katalogo bedą wynosić:
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l file1
-rwxrwx---. 1 user user 0 Jun 21 14:21 file1
----------------------------------------------
u = rwx = 4 + 2 + 1 = 7
g = rwx = 4 + 2 + 1 = 7
o = --- = 0 + 0 + 0 = 0
ugo = 770
</pre>
      <p>
        W ten sposób przeliczonymi uprawnieniami (tzw. uprawnieniami 
        bezwględnymi, ponieważ przypisują one uprawnienia każdej z klas) możemy
        posługiwać się podczas ich zmiany przy użyciu polecenia <em>chmod</em>
      </p>
<pre class="code-block">
[user@server1 ~]$ chmod -v 644 file1
mode of 'file1' changed from 0770 (rwxrwx---) to 0644 (rw-r--r--)
[user@server1 ~]$ chmod -v 770 file1
mode of 'file1' changed from 0644 (rw-r--r--) to 0770 (rwxrwx---)
</pre>
      <p>
        Na powyższym przykładzie zastosowałem opcję <em>-v</em>, która
        wyświetla jak zmieniają się uprawnienia oraz postać symboliczną
        uprawnienień. W przypadku wyświetlonej wartości liczbowej, pierwsze
        zero z lewej strony jest miejscem na uprawnienia specjalne o których
        będzie za chwilę, w przypadku standardowych uprawnienień nie ma ono
        znaczenia.
      </p>
      <p>
        Zapis uprawnień bezwzględnych w zapisie symbolicznym wyglądał by
        następująco:
      </p>
<pre class="code-block">
[user@server1 ~]$ chmod -v u=rw,g=r,o=r file1
mode of 'file1' changed from 0770 (rwxrwx---) to 0644 (rw-r--r--)
</pre>
      <p>
        Definiując uprawnienia bezwzględne, posługujemy się cyframi od 0 do 7.
        Są to wszystkie cyfry systemu liczbowego o podstawie 8 (tzw. ósemkowy 
        lub oktalny) dlatego też często nazwa się takie ustalanie uprawnień 
        trybem oktalnym. 
      </p>
      <p>
        Podczas ustalania uprawnień dla plików lub katalogów, nie ma znaczenia
        jakiego trybu użyjemy, nie ma lepszego i gorszego. Jest tryb
        czytelniejszy oraz szybszy do zapisania.
      </p>
      <p>
        Na koniec jako ciekawostke podam iż istnieje czwarta dodatkowa klasa -
        wszystkie klasy (<strong>a</strong>), za jej pomocą można nadawać,
        odbierać i przypisywać takie same uprawnienia dla wszystkich klas.
      </p>
<pre class="code-block">
[user@server1 ~]$ chmod -v a=rwx file1
mode of 'file1' changed from 0644 (rw-r--r--) to 0777 (rwxrwxrwx)
</pre>
      <h3 id="4.1.1.defaultpermissions">4.1.1. Uprawnienia domyślne</h3>
      <p>
        Każdy nowoutworzony plik czy katalog Uniksie ma już z góry przypisane 
        uprawnienia i są nimi 666 dla plików oraz 777 dla katalogów. 
        Uprawnienia te są korygowane za pomocą wartości <strong>umask</strong>. 
      </p>
      <p>
        Wartość <em>umask</em> (ang. <em>user mask</em>) jest maską uprawnień
        stosowaną na tworzonych przez użytkowników nowych plikach i katalogach.
        Każdy użytkownik ma swoją indywidualną maskę i może ją dowolnie 
        zmieniać.
        Maska ma za zadanie usunięcie tych praw, których nie życzymy sobie
        widzieć w poszczególnych klasach. Aby wyświetlić maskę użytkownika
        należy wydać poniższe polecenie: 
      </p>
<pre class="code-block">
[user@server1 ~]$ umask
0022
</pre>
      <p>
        Maska w przypadku RHEL 9 wygląda tak jak na powyszym przykładzie. Ta
        wartość usunie z klasy grupy oraz z klasy pozostałych użytkowników
        prawo do zapisu. Rachunek uprawnień jest bardzo prosty.
      </p>
<pre class="code-block">
#W przypadku plików:

0666
0022 -
------
0644

#W przypadku katalogów:

0777
0022 -
------
0755
</pre>
      <p>
        Chcąc zmienić maskę wystarczy wydać polecenie:
      </p>
<pre class="code-block">
[user@server1 ~]$ umask 002
[user@server1 ~]$ umask
0002
</pre>
      <p>
        Tak zdefiniowana maska usunie tylko prawo do zapisu w klasie
        pozostałych użytkowników dla każdego nowego pliku i katalogu. Maska
        o tej wartości była domyślną maską dla zwykłych użytkowników w RHEL 8.
        Wartość maski zdefiniowanej z poziomu wiersza poleceń, utrzyma się
        tylko przez czas trwania otwartej sesji terminala. Po jego zamknięciu 
        lub
        wylogowaniu się maska wróci do poprzedniej wartości. Jeśli chcemy aby
        wartości tej maski została zapisana na stałe, należy umieść polecenie
        <em>umask</em> w jednym z plików uruchomieniowych powłoki, będzie o tym
        w dalszej części tego materiału.
      </p>
      <h2 id="4.1.2.changefileowner">4.1.2. Zmiana właściciela oraz grupy pliku</h2>
      <p>
        Do zmiany właściciela pliku oraz grupy, do której on należy służy
        polecenie <strong>chown</strong>, które przyjmuje jako pierwszy
        argument trzy możliwe wersje: parę <strong>właściciel:grupa</strong>;
        samego właściela lub nazwę grup poprzedzoną dwukropkiem
        (<strong>:</strong>) a następnie pliki. Poniższy przykład obrazuje
        wszystkie trzy możliwe zmiany właściciela oraz grup, do której należy
        plik.
      </p>
<pre class="code-block">
[root@server1 tmp]# chown user100:user100 acluser
[root@server1 tmp]# ls -l acluser 
-rw-rw-r--. 1 user100 user100 9 Jun 22 18:25 acluser
[root@server1 tmp]# chown user acluser
[root@server1 tmp]# ls -l acluser 
-rw-rw-r--. 1 user user100 9 Jun 22 18:25 acluser
[root@server1 tmp]# chown :user acluser
[root@server1 tmp]# ls -l acluser
-rw-rw-r--. 1 user user 9 Jun 22 18:25 acluser
</pre>
      <h2 id="4.2.specialpermissions">4.2. Uprawnienia specjalne</h2>
      <p>
        Poza podstawowym rodzajem uprawnień w Uniksach istnieją dodatkowe
        uprawnienia, których zadaniem może być podniesienie uprawnień w
        systemie, zaoszczędzenie czasu lub ochrona przed skasowaniem pliku w
        miejscach gdzie wszyscy mają uprawnienia zapisu. Teraz omówimy sobie
        każdy z nich.
      </p>
      <h3 id="4.2.1.setuid">4.2.1. Uprawnienia bitu setuid</h3>
      <p>
        Każde z podstawowych praw, możemy określić mianej bitu, z uprawnieniami
        specjalnymi jest podobnie, każde z nich jest kolejnym bitem (prawem) o
        szczególnym znaczeniu. Tak jest i tym przypadku. Bit 
        <strong>setuid</strong> służy do podniesienia uprawnień. Jest on
        oznaczany małą lub wielką literą <em>s</em> w klasie
        użytkownika/właściciela. Ma on 
        zastosowanie głównie na plikach wykonywalnych. Kiedy uruchomimy program
        z ustawionym takim bitem, program ten będzie działać z uprawnieniami
        właściciela tego pliku. Bit ten jest wykorzystywany najczęściej
        do uruchomienia programu z uprawnieniami <em>root</em> przez
        zwykłego użytkownika. Takim przykładem może być program <strong>su</strong>,
        który służy przełączaniu się miedzy użytkownikami, bez tego bitu
        przelogowanie nie było by możliwe. Dla eksperymentu możemy usunać ten
        bit, następnie spróbować jako zwykły użytkownik przelogować na kogoś
        innego. 
      </p>
<pre class="code-block">
[root@server1 ~]# chmod -v u-s /usr/bin/su
mode of '/usr/bin/su' changed from 4755 (rwsr-xr-x) to 0755 (rwxr-xr-x)
[user@server1 ~]$ su user100
Password: 
su: Authentication failure
</pre>
      <p>
        Jak widać przełączanie na użytkownika user100 nie powiodło się
        mimo iż polecenie zapytało o hasło (polecenie <em>su</em> nie pyta o
        hasło tylko superużytkownika). Zwróćmy również uwagę na to jak wygląda
        bit <em>setuid</em> w oktalnym zapisie uprawnień. Do wskazywania 
        uprawnień specjalnych wykorzystywana jest nieużywana przy zwykłych
        uprawnieniach czwarta liczba całkiem z lewej strony. Teraz przywrócimy
        <em>setuid</em> temu programowi.
      </p>
<pre class="code-block">
[root@server1 ~]# chmod -v +4000 /usr/bin/su
mode of '/usr/bin/su' changed from 0755 (rwxr-xr-x) to 4755 (rwsr-xr-x)
[user@server1 ~]$ su user100
Password: 
[user100@server1 user]$ 
</pre>
      <p>
        Podczas przywracania uprawnień, nie naruszyłem tych podstawowych
        używając wartości <code class="code-inline">+4000</code>, nie
        potrzeba wskazywać klasy, ponieważ program sam wie, że ten bit należy
        nadać w klasie właściciela. 
      </p>
      <p>
        Czasami bit <em>setuid</em> może występować w postaci wielkiej litery
        <em>S</em>, oznacza to tyle iż w klasie właściciela nie występuje
        prawo do wykonywania (bit <em>x</em>).
      </p>
      <h3 id="4.2.2.setgid">4.2.2. Uprawnienia bitu setgid</h3>
      <p>
        Zastosowania bitu <strong>setgid</strong>, mogą być dwa jedno podobne
        do bitu <em>setuid</em>, ale tyczące się grupy, drugie zaś dotyczy się
        katalogów współdzielonych. Bit <em>setgit</em> oznaczany jest
        małą lub wielką literą <em>s</em> w klasie grupy. 
      </p>
      <p>
        Kiedy katalog posiada ustawiony bit <em>setgid</em>, to grupa, która
        jest właścicielem takiego katalogu będzie przypisywana jako grupa
        każdemu nowemu elementowi utworzonemu w tym katalogu. 
      </p>
<pre class="code-block">
[user2000@server1 sdir]$ ls -ld /sdir
drwxrws--T. 3 root sgrp2 65 Jun 21 17:31 /sdir
[user2000@server1 sdir]$ mkdir user2000dir
[user2000@server1 sdir]$ ls -l
total 4
-rw-rw-r--. 1 user1000 sgrp2 5 Jun 20 16:00 user1000file
drwxrwsr-x. 2 user2000 sgrp2 6 Jun 21 17:30 user2000dir
[user2000@server1 sdir]$ touch user2000file
[user2000@server1 sdir]$ ls -l
total 4
-rw-rw-r--. 1 user1000 sgrp2 5 Jun 20 16:00 user1000file
drwxrwsr-x. 2 user2000 sgrp2 6 Jun 21 17:30 user2000dir
-rw-rw-r--. 1 user2000 sgrp2 0 Jun 21 17:31 user2000file
</pre>
      <p>
        Katalog <em>/sdir</em> jest własnością grupy <em>sgrp2</em> oraz
        posiada ustawiowiony bit <em>setgid</em> (bit <em>s</em> w miejscu
        <em>x</em> w klasie grupy). Utworzyłem katalog oraz plik, oba elementy
        odziedziczyły grupę <em>sgrp2</em> właśnie dzięki tym uprawnieniom.
        Zwróćmy uwagę również na fakt iż nowoutworzony katalog odziedziczył
        również bit <em>setgid</em>. Tego typu funkcjonalność możemy
        wykorzystać tworząc katalogi do pracy grupowej, aby zaoszczędzić
        użytkownikom grupy zmianę uprawnień przy każdym nowym pliku lub
        podkatalogu w tego typu folderach.
      </p>
      <p>
        Innym przykładem jest wykorzystanie pliku wykonywalnego z ustawionym
        bitem <em>setgid</em>. Weźmy pod lupe taki taki plik jak program
        <strong>write</strong>, ten program służy do przesyłania wiadomości
        między użytkownikami (między terminalami).
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /usr/bin/write 
-rwxr-sr-x. 1 root tty 24472 Feb 24 11:25 /usr/bin/write
</pre>
      <p>
        Posiada on bit <em>setgid</em>, którym pozwoli mu w tym przypadku
        skorzystać z uprawnień grupy na plikach urządzeń. Pierwsza konsola
        wirtualna w systemie:
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /dev/tty0 
crw--w----. 1 root tty 4, 0 Jun 21 15:13 /dev/tty0
</pre>
      <p>
        Grupa <em>tty</em> posiada prawo do zapisu na tym urządzeniu. Sprawdźmy
        jeszcze pierwsze urządzenie pseudoterminala (okno programu
        <em>Terminal</em> lub połączenie przez SSH).
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /dev/pts/0
crw--w----. 1 user tty 136, 0 Jun 21 17:51 /dev/pts/0
</pre>
      <p>
        Tutaj grupa również posiada prawo zapisu. Usuwanie i przypisywanie
        tego bitu ponownie jest analogiczne to bitu <em>setuid</em>, wymaga
        tylko zmiany kilku wartości
      </p>
<pre class="code-block">
[root@server1 ~]# chmod -v g-s /usr/bin/write
mode of '/usr/bin/write' changed from 2755 (rwxr-sr-x) to 0755 (rwxr-xr-x)
[root@server1 ~]# chmod -v +2000 /usr/bin/write
mode of '/usr/bin/write' changed from 0755 (rwxr-xr-x) to 2755 (rwxr-sr-x)
</pre>
      <p>
        Przeglądając atrybuty plików i katalogów możemy natknąć sie na bit
        <em>setgid</em> zapisany wielką literą, jest to ten sam bit, tylko że
        w klasie grupy brakuje prawa do wykonania (bitu <em>x</em>).
      </p>
      <h3 id="4.2.3.stickybit">4.2.3. Uprawnienia bitu sticky</h3>
      <p>
        Bit <strong>sticky</strong> ma za zadanie zabezpieczyć pliki i katalogi
        przed nieuprawnionym usunięciem w ogólodostępnych katalogach (tam
        gdzie wszyscy mają prawo do zapisu). Jeśli katalog ma ustawiony taki
        bit, to wówczas tylko właściciel pliku bądź podkatalogu będzie mógł go
        usunąć. Bit <em>sticky</em> oznaczany jest za pomocą małej lub
        wielkiej litery <em>t</em> w klasie publicznej 
        (pozostałych użytkowników). 
      </p>
      <p>
        Usunięcie lub przypisanie tego bitu może odbywać się tak jak w
        przypadku poprzednich bitów.
      </p>
<pre class="code-block">
[root@server1 ~]# chmod -v -o-t /sdir
mode of '/sdir' changed from 3770 (rwxrws--T) to 2770 (rwxrws---)
[root@server1 ~]# chmod -v +1000 /sdir
mode of '/sdir' changed from 2770 (rwxrws---) to 3770 (rwxrws--T)
</pre>
      <p>
        Tutaj zwróćmy uwagę na to iż bit <em>sticky</em> jest zapisany wielką
        literą, otóż działanie tego bitu się nie zmienia, jest jedynie 
        informacja, że klasie publicznej brakuje prawa do wykonania
        (<em>x</em>). Wszystkie bity specjalne umieszczane w poszczególnych
        klasach, rezydują w miejscu prawa do wykonywania.
      </p>
      <h2 id="4.3.find">4.3. Polecenie find</h2>
      <p>
        Polecenie <strong>find</strong>, jak sama nazwa wskazuje służy do
        wyszukiwania plikówi i katalogów. Najczęściej jest ono wykorzystywane 
        przez
        użytkowników w podstawowym zakresie, zwracając gigantyczną ilość danych.
        Często korzystając z tego narzędzia nie wykorzystuje się w pełni jego
        potencjału, który ukrywa się w dużej ilości opcji zawężających wyniki
        poszukiwania oraz możliwości wykonania akcji w wyszukanych plikach.
      </p>
      <p>
        Najprostszy sposób na użycie polecenia <em>find</em> znajduje się 
        poniżej:
      </p>
<pre class="code-block">
[root@server1 user]# find / -name network
/run/systemd/network
/tmp/gzipped/etc/sysconfig/network
/tmp/gzipped/etc/vmware-tools/scripts/vmware/network
/etc/sysconfig/network
/etc/vmware-tools/scripts/vmware/network
/root/bzipped/etc/sysconfig/network
/root/bzipped/etc/vmware-tools/scripts/vmware/network
/usr/lib/systemd/network
</pre>
      <p>
        Polecenie przeszukało cały główny system plików pod kątem plików
        o nazwie <code class="code-inline">network</code>. Sama opcja
        <code class="code-inline">-name</code> jest zawężeniem wyników
        wyszukiwania, bez tej opcji polecenie zwróciłoby wszystkie pliki
        znalezione w podanym katalogu czyli w tym przypadku minimum kilka 
        tysięcy.
      </p>
      <p>
        Poniżej zamiesczam najważniejsze opcje służące do bardziej
        szczegółowego wyszukiwania plików.
      </p>
      <ul>
        <li><strong>-iname</strong> - wyszukuje pliki o nazwie podanej jako
          argument tej opcji, ignorując przy tym wielkość znaków.
<pre class="code-block">
[root@server1 user]# find . -iname do*
./Downloads
./Documents
./.cache/mozilla/firefox/r7fvuapl.default-default/cache2/doomed
</pre>
        </li>
        <li><strong>-size</strong> - wyszukiwanie plików na podstawie rozmiaru.
          Jeśli chcemy aby program znalazł pliki mniejsze niż podana
          wartość stawiamy przed nią myślnik (<strong>-</strong>), a jeśli
          większe to plus (<strong>+</strong>). Poniższy przykład zaprezentuje
          wyszukiwanie plików powyżej 1G w moim katalogu domowym:
<pre class="code-block">
[xf0r3m@latitude-e5270 ~]$ find ~ -size +1G -exec ls -ldh {} \;
-rw-r--r--. 1 xf0r3m xf0r3m 2,1G 06-18 18:12 /home/xf0r3m/Pobrane/Fedora-MATE_Compiz-Live-x86_64-35/Fedora-MATE_Compiz-Live-x86_64-35-1.2.iso
-rw-r--r--. 1 xf0r3m xf0r3m 1,4G 06-18 19:44 /home/xf0r3m/Pobrane/Fedora-LXDE-Live-x86_64-35-1.2.iso
-rwxr-xr-x. 1 xf0r3m xf0r3m 11G 2017-01-25  /home/xf0r3m/Pobrane/rhel-8.6-x86_64-dvd.iso
-rwxr-xr-x. 1 xf0r3m xf0r3m 8,0G 2017-02-11  /home/xf0r3m/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso
-rwxr-xr-x. 1 xf0r3m xf0r3m 2,9G 06-21 19:50 /home/xf0r3m/Dokumenty/RHEL9-VM1_21.06.ova
-rwxr-xr-x. 1 xf0r3m xf0r3m 2,3G 06-21 19:54 /home/xf0r3m/Dokumenty/RHEL9-VM2_21.06.ova
-rwxr-xr-x. 1 xf0r3m xf0r3m 2,6G 06-21 20:00 /home/xf0r3m/Dokumenty/RHEL8-VM1_21.06.ova
-rw-------. 1 xf0r3m xf0r3m 6,2G 06-22 16:06 '/home/xf0r3m/VirtualBox VMs/RHEL9-VM1/RHEL9-VM1_21.06-disk001.vmdk'
-rw-------. 1 xf0r3m xf0r3m 4,8G 06-21 22:26 '/home/xf0r3m/VirtualBox VMs/RHEL9-VM2/RHEL9-VM2_21.06-disk001.vmdk'
-rw-------. 1 xf0r3m xf0r3m 6,3G 06-21 22:28 '/home/xf0r3m/VirtualBox VMs/RHEL8-VM1/RHEL8-VM1_21.06-disk001.vmdk'
</pre>
          Opcję <code class="code-block">-exec</code>, omówimy pod koniec
          tego podrozdziału. 
        </li>
        <li><strong>-user, -group</strong> - wyszukiwanie plików na podstawie
          nazwy właściciela oraz grupy do której plik należy. W przykładzie
          przedstawie polecenie, które wyszuka wszystkie pliki należące do
          użytkownika <em>user</em>, ale i nie należące do grupy sgrp2:
<pre class="code-block">
[root@server1 user]# find / -user user -not -group sgrp2 
/dev/pts/0
/proc/1688
/proc/1688/task
/proc/1688/task/1688
/proc/1688/task/1688/fd
/proc/1688/task/1688/fd/0
/proc/1688/task/1688/fd/1
/proc/1688/task/1688/fd/2
...
</pre>
          Aby zanegować, któreś z kryteriów należy poprzedzić je opcją
          <em>-not</em> lub wykrzyknikiem (<strong>!</strong>).
        </li>
        <li><strong>-maxdepth, -mindepth</strong> - te opcje wskazują poleceniu
          <em>find</em>, jak głęboko w strukturę katalogów ma sięgać polecenie
          podczas wyszukiwania (<em>-maxdepth</em>) lub od którego poziomu
          podkatalogów ma zacząć wyszukiwanie (<em>-mindepth</em>).
<pre class="code-block">
[root@server1 user]# find / -maxdepth 3 -name network
/run/systemd/network
/etc/sysconfig/network

[root@server1 user]# find / -mindepth 4 -name network
/tmp/gzipped/etc/sysconfig/network
/tmp/gzipped/etc/vmware-tools/scripts/vmware/network
/etc/vmware-tools/scripts/vmware/network
/root/bzipped/etc/sysconfig/network
/root/bzipped/etc/vmware-tools/scripts/vmware/network
/usr/lib/systemd/network
</pre>
          Zwróćmy uwagę na to, iż te opcje są opcjami globalnymi, nie mają
          bezpośredniego wpływu na wyszukiwanie, dlatego też należy je
          umieszczać przed opcjami mający zawęzić kryteria.
        </li>
        <li><strong>-type</strong> - wyszukiwanie na podstawie typu
          plików. Poniższy przykład pokazuje również jak zapisać różne
          wartości przy jednej opcji:
<pre class="code-block">
[root@server1 user]# find / -type p,s -exec ls -ld {} \;
srwxr-xr-x. 1 chrony chrony 0 Jun 22  2022 /run/chrony/chronyd.sock
srwxr-xr-x. 1 root root 0 Jun 22  2022 /run/mcelog-client
srw-rw-rw-. 1 root root 0 Jun 22  2022 /run/.heim_org.h5l.kcm-socket
srw-rw-rw-. 1 root root 0 Jun 22  2022 /run/avahi-daemon/socket
srw-rw-rw-. 1 root root 0 Jun 22  2022 /run/lsm/ipc/simc
srw-rw-rw-. 1 root root 0 Jun 22  2022 /run/lsm/ipc/sim
srw-rw-rw-. 1 root root 0 Jun 22  2022 /run/cups/cups.sock
prw-------. 1 root root 0 Jun 22  2022 /run/initctl
prw-------. 1 root root 0 Jun 22  2022 /run/dmeventd-client
prw-------. 1 root root 0 Jun 22  2022 /run/dmeventd-server
</pre>
        Polecenie wyszukuje w systemie wszyskie gniazda i nazwane potoki
        (typy plików, nieomawiane w tym materiale). Jak widać inną wartość dla
        tej opcji należy podać po przecinku.
      </li>
      <li><strong>-mtime, -mmin</strong> - wyszukiwanie pliku na podstawie
        ilości czasu upłyniętego od daty ostatniej modyfikacji, z czego
        opcja <em>-mtime</em> przyjmuje wartości w liczbie dni, która upłynęła
        od ostatniej modyfikacji, a <em>-mmin</em> w minutach.
<pre class="code-block">
[xf0r3m@latitude-e5270 ~]$ find ~ -maxdepth 2 -mtime -7
/home/xf0r3m
/home/xf0r3m/.mozilla/firefox
/home/xf0r3m/.local/share
/home/xf0r3m/Pobrane
/home/xf0r3m/Pobrane/Fedora-MATE_Compiz-Live-x86_64-35.torrent
/home/xf0r3m/Pobrane/Fedora-MATE_Compiz-Live-x86_64-35
/home/xf0r3m/Pobrane/Fedora-LXDE-Live-x86_64-35.torrent
/home/xf0r3m/Pobrane/Fedora-LXDE-Live-x86_64-35-1.2.iso
/home/xf0r3m/Pobrane/Fedora-Workstation-Live-x86_64-35.torrent

[xf0r3m@latitude-e5270 ~]$ find ~ -maxdepth 3 -mmin -360
/home/xf0r3m
/home/xf0r3m/.mozilla/firefox
/home/xf0r3m/.mozilla/firefox/qlw3f0ci.default-default
/home/xf0r3m/.local/share
/home/xf0r3m/.local/share/gnome-shell
/home/xf0r3m/.local/share/gvfs-metadata
/home/xf0r3m/.local/share/recently-used.xbel
/home/xf0r3m/.local/share/ranger
/home/xf0r3m/.local/state/wireplumber
/home/xf0r3m/Dokumenty/docs/.git
/home/xf0r3m/Dokumenty/docs/angielski
</pre>
        Powyższe polecenia przedstawiają pliki, które były modyfikowane w
        przeciągu ostatnich 7 dni, oraz ostatnich 6 godzin. Użyłem tutaj
        również modyfikatorów głębokości.
      </li>
      <li><strong>-perm</strong> - wyszukiwanie plików na podstawie uprawnień.
        Chcąc wyszukać pliki po konkretnych uprawnieniach pliku, podajemy je w
        wersji oktalnej po opcji. Możemy również skorzystać z innych opcji 
        wprowadzania
        uprawnień: uprawnienień minimalnych podanych po myślniku
        (<strong>-</strong>), wówczas każdy z podanych tam praw będzie musiało
        wystąpić w danej klasie lub uprawnień dowolnych podanych po ukośniku
        (<strong>/</strong>), wówczas przypasowany zostanie plik, który będzie
        posiadać, minimum jedno z praw, z minimum jednej klasy.
<pre class="code-block">
[root@server1 user]# find / -perm 111 -exec ls -ld {} \;
---x--x--x. 1 root root 87168 Aug 26  2021 /usr/bin/sudoreplay

[root@server1 user]# find /dev -type c -perm -222 -exec ls -ld {} \;
crw-rw-rw-. 1 root kvm 10, 241 Jun 22  2022 /dev/vhost-vsock
crw-rw-rw-. 1 root kvm 10, 238 Jun 22  2022 /dev/vhost-net
crw-rw-rw-. 1 root root 10, 196 Jun 22  2022 /dev/vfio/vfio
crw-rw-rw-. 1 root root 10, 200 Jun 22  2022 /dev/net/tun
crw-rw-rw-. 1 root render 226, 128 Jun 22  2022 /dev/dri/renderD128
crw-rw-rw-. 1 root root 10, 229 Jun 22  2022 /dev/fuse
crw-rw-rw-. 1 root tty 5, 2 Jun 22 17:28 /dev/ptmx
crw-rw-rw-. 1 root tty 5, 0 Jun 22  2022 /dev/tty
crw-rw-rw-. 1 root root 1, 9 Jun 22  2022 /dev/urandom
crw-rw-rw-. 1 root root 1, 8 Jun 22  2022 /dev/random
crw-rw-rw-. 1 root root 1, 7 Jun 22  2022 /dev/full
crw-rw-rw-. 1 root root 1, 5 Jun 22  2022 /dev/zero
crw-rw-rw-. 1 root root 1, 3 Jun 22  2022 /dev/null

[root@server1 user]# find /dev -type c -perm /222 -exec ls -ld {} \;
crw-rw----. 1 root dialout 4, 64 Jun 22 17:30 /dev/ttyS0
crw-rw-rw-. 1 root tty 5, 2 Jun 22 17:30 /dev/ptmx
crw-r--r--. 1 root root 10, 235 Jun 22 17:30 /dev/autofs
</pre>
        Powyżej przedstawiłem wymienione sposoby na zapis uprawnień w przy
        opcji <em>-perm</em>. Tej opcji możemy również przekazać uprawnienia
        w postaci symbolicznej na przykład:
<pre class="code-block">
[root@server1 user]# find /usr -perm -u=s -exec ls -ld {} \;
-rwsr-xr-x. 1 root root 36880 Feb 16 15:46 /usr/bin/fusermount3
-rwsr-xr-x. 1 root root 74880 Dec  3  2021 /usr/bin/chage
-rwsr-xr-x. 1 root root 78744 Dec  3  2021 /usr/bin/gpasswd
-rwsr-xr-x. 1 root root 42448 Dec  3  2021 /usr/bin/newgrp
-rwsr-xr-x. 1 root root 36872 Jan 12 18:21 /usr/bin/fusermount
-rwsr-xr-x. 1 root root 49152 Feb 24 11:25 /usr/bin/mount
-rwsr-xr-x. 1 root root 36784 Feb 24 11:25 /usr/bin/umount
-rwsr-xr-x. 1 root root 57616 Feb 24 11:25 /usr/bin/su
-rwsr-xr-x. 1 root root 32608 Mar 11 16:34 /usr/bin/pkexec
-rwsr-xr-x. 1 root root 53704 Aug  9  2021 /usr/bin/crontab
-rwsr-xr-x. 1 root root 32648 Aug 10  2021 /usr/bin/passwd
---s--x--x. 1 root root 185456 Aug 26  2021 /usr/bin/sudo
-rwsr-xr-x. 1 root root 16240 Oct 15  2021 /usr/bin/vmware-user-suid-wrapper
-rws--x--x. 1 root root 32712 Feb 24 11:25 /usr/bin/chfn
-rws--x--x. 1 root root 24464 Feb 24 11:25 /usr/bin/chsh
-rwsr-xr-x. 1 root root 57920 Aug  9  2021 /usr/bin/at
-rwsr-xr-x. 1 root root 16128 Dec  2  2021 /usr/sbin/pam_timestamp_check
-rwsr-xr-x. 1 root root 24544 Dec  2  2021 /usr/sbin/unix_chkpwd
-rwsr-xr-x. 1 root root 15608 Mar 10 18:18 /usr/sbin/grub2-set-bootflag
-rws--x--x. 1 root root 45232 Dec  9  2021 /usr/sbin/userhelper
-rwsr-xr-x. 1 root root 20416 Mar 11 16:34 /usr/lib/polkit-1/polkit-agent-helper-1
-rwsr-x---. 1 root sssd 119512 Jan 17 20:47 /usr/libexec/sssd/krb5_child
-rwsr-x---. 1 root sssd 53240 Jan 17 20:47 /usr/libexec/sssd/ldap_child
-rwsr-x---. 1 root sssd 28536 Jan 17 20:47 /usr/libexec/sssd/proxy_child
-rwsr-x---. 1 root sssd 32656 Jan 17 20:47 /usr/libexec/sssd/selinux_child
-rwsr-x---. 1 root dbus 36848 Aug  9  2021 /usr/libexec/dbus-1/dbus-daemon-launch-helper
-rwsr-xr-x. 1 root root 16104 Feb 10 11:13 /usr/libexec/Xorg.wrap
-rwsr-x---. 1 root cockpit-wsinstance 57600 Mar  3 13:28 /usr/libexec/cockpit-session
</pre>
        Powyższe polecenie szuka wszystkich programów z ustawionym bitem
        <em>setuid</em>.
      </li>
      </ul>
      <h3 id="4.3.1.actionoptions">4.3.1. Opcje akcji polecenia find</h3>
      <p>
        Na powyższych przykładach stosowałem wielkrotnie dodatkową opcję
        <code class="code-inline">-exec</code>. Jest to opcja akcji
        podejmowana na pliku gdy tylko zostanie znaleziony. Składania opcji
        <em>-exec</em> może wyglądać następująco:
      </p>
<pre class="code-block">
$ find ... -exec ls -ld {} \;
</pre>
      <p>
        Po opcji <em>-exec</em> podajemy zwykłe polecenie, tak jak gdybyśmy
        wpisywali je do wiersza polecenia. Odniesieniu do znalezionego pliku
        służy zapisana para nawiasów klamrowych 
        <code class="code-inline">{}</code> każde polecenie wydawane za pomocą
        opcji <em>-exec</em> czy innej musi zostać za terminowane
        zacytowanym średnikiem (<strong>\;</strong>), ponieważ jest koniec
        polecenia wprowadzonego to tej opcji, a nie koniec polecenia
        <em>find</em>. Wynik działania przykładowego użycia opcji 
        <em>-exec</em> znajduje sie w przykładach na początku tego 
        podrozdziału.
      </p>
      <p>
        Poza poleceniem <em>-exec</em>, istnieją jeszcze dwa polecenia akcji
        <strong>-delete</strong>, które usuwa pliki oraz <strong>-ok</strong>,
        które różni się tym od <em>-exec</em>, że pyta sie użytkownika czy
        wykonać podane polecenie na pliku.
      </p>
      <p class="exam_tip">
        Polecenie <em>find</em>, wydaje się bardzo pomocne, posiada masę opcji
        część znich znajduje się tutaj, pozostałe są rozpisane na stronach
        podręcznika. Powinniśmy umieć się posługiwać tym narzędziem, zarówno
        zaweżać obszar poszukiwania jak i prawidłowo używać opcji 
        <em>-exec</em>.
      </p>
      <h2 id="4.4.acl">4.4. Lista kontroli dostępu</h2>
      <p>
        Oprócz klasycznego zestawu uprawnień w Uniksach oraz określenia
        właściciela i grupy do której należy plik bądź katalog, w RHEL możemy
        dodatkowo wskazać innych użytkowników oraz grupy i przypisać im 
        uprawnienia
        nieżależne od tych klasycznych (<strong>standardu ugo/rwx</strong>).
        Temu właśnie służy <strong>Lista kontroli dostępu</strong>. Ten
        mechanizm obsługiwany jest za pomocą dwóch poleceń, pierwszym z nich
        jest <strong>getfacl</strong> i służy ono do wypisania listy kontroli
        dostępu. Stwórzmy w katalogu <em>/tmp</em> plik o nazwie 
        <em>aclfile</em>, następnie wykonajmy polecenie <em>getfacl</em>
        podając ten plik jako argument.
      </p>
<pre class="code-block">
[user@server1 ~]$ cd /tmp
[user@server1 tmp]$ touch acluser
[user@server1 tmp]$ getfacl acluser 
# file: acluser
# owner: user
# group: user
user::rw-
group::rw-
other::r--

[user@server1 tmp]$ ls -l acluser
-rw-rw-r--. 1 user user 9 Jun 22 18:25 acluser
</pre>
      <p>
        Kiedy plik niema zdefiniowanych żadnych dodatkowych użytkowników oraz
        grup, jego lista kontroli dostępu jest równoznaczna z klasycznymi 
        uprawnieniami Uniksa i te listy oznaczają kolejno właściciela, grupę
        do której należy ten plik oraz pozostałych użytkowników.
        Listy kontroli dostępu możemy modyfikować 
        za pomocą polecenia <strong>setfacl</strong>. Zanim jednak poznamy
        jak należy modyfikować ACL, poniżej znajduje się lista najważniejszych
        opcji tego polecenia. Są one dość istotne, ponieważ pozwalają na 
        manipulowanie listami elementu.
      </p>
      <ul>
        <li><strong>-b</strong> - usuwa wszystkie listy dostępowe,</li>
        <li><strong>-d</strong> - ustawia listy jako domyślne,</li>
        <li><strong>-k</strong> - usuwa wszystkie listy domyślne,</li>
        <li><strong>-m</strong> - modyfikuje lub ustawia listy,</li>
        <li><strong>-n</strong> - chroni przed automatycznym przeliczaniem
          maski,</li>
        <li><strong>-R</strong> - ustawia listy rekurencyjnie, listy katalogu
          są stosowane na elementy w nim zawarte,</li>
        <li><strong>-x</strong> - usuwa pojedyńczą listę.</li>
      </ul>
      <p>
        Listy kontroli możemy zastoswać dla trzech podmiotów:
      </p>
      <ul>
        <li><strong>użytkownika</strong>:
          <code class="code-inline">u[ser]:nazwa/uid:uprawnienia</code></li>
        <li><strong>grupy</strong>:
          <code class="code-inline">g[roup]:nazwa/gid:uprawnienia</code></li>
        <li><strong>innych</strong>:
          <code class="code-inline">o[ther]:uprawnienia</code></li>
      </ul>
      <p>
        To co zostało ujęte w nawiasach kwadratowych, jest zapisem opcjonalnym.
        Identyfikator podmiotu możemy zapisać albo za pomocą numerów <em>UID</em>
        oraz <em>GID</em>, lub za pomocą nazw. Jeśli nazwa lub 
        <em>UID</em>/<em>GID</em> zostaną pominiete to listy <em>user</em>
        oraz <em>group</em> będą tyczyć się właściciela oraz grupy, do której
        należy dany element. Uprawnienia mogą być podane
        za pomocą symboli lub sumy wag dla pojedyńczej klasy. Ustawię teraz
        listę dla jednego z użytkowników w systemie.
      </p>
<pre class="code-block">
[user@server1 tmp]$ setfacl -m u:user100:rw acluser
[user@server1 tmp]$ ls -l acluser
-rw-rw-r--+ 1 user user 9 Jun 22 18:25 acluser
</pre>
      <p>
        Pierwsze polecenie ustawia prawo do czytania oraz pisania użytkownikowi
        <code class="code-inline">user100</code> za pomocą list dostępu.
        Wyświetliłem szczegóły pliku. Zwróćmy uwagę na to, iż kropka na końcu
        uprawnień została zastąpiona plusem (<strong>+</strong>), taki zapis
        informuje użytkowników, że uprawnienia tego pliku są rozszerzone za
        pomocą ACL. Teraz przyjrzymy sie jak wygląda taka lista w ujęciu ACL:
      </p>
<pre class="code-block">
[user@server1 tmp]$ getfacl -c acluser
user::rw-
user:user100:rw-
group::rw-
mask::rw-
other::r--
</pre>
      <p>
        W tym przykładzie użyłem opcji <em>-c</em>, która nie wyświetla
        wcześniej pokazywanego nagłówka. Nie jest on nam potrzebny. Nowy wpis
        pojawia się pod wpisem właśiciela. Mówi on wprost, że użytkownik
        <code class="code-inline">user100</code> posiada prawo do czytania oraz
        modyfikowania pliku <code class="code-inline">acluser</code>, mimo iż
        na podstawie klasycznych uprawnień oraz praw własności nie jest on 
        nijak związany z tym plikiem.
      </p>
      <p>
        Poza uprawnienia dla użytkownika pojawi się wpis oznaczony słowem
        <code class="code-inline">mask</code>. Jest to maska list kontroli
        i wyznacza ona maksymalne uprawnienia jakie można dać danemu
        podmiotowi. Przy każdej zmianie list kontroli dostosowuje się ona do
        najwyższych uprawnień na liście. Dodam teraz drugiego użytkownika z
        wyższymi od <em>user100</em> uprawnieniami, bedziemy mogli wówczas
        zaobserowować jak zmienia się maska.
      </p>
<pre class="code-block">
[user@server1 tmp]$ setfacl -m u:user200:7 acluser
[user@server1 tmp]$ getfacl -c acluser
user::rw-
user:user100:rw-
user:user200:rwx
group::rw-
mask::rwx
other::r--
</pre>
      <p>
        Maska została ponownie przeliczona i wskazuje teraz uprawnienia o
        sumie wag równej 7 (<em>rwx</em>). Teraz wymuszę inną wartość dla
        maski:
      </p>
<pre class="code-block">
[user@server1 tmp]$ setfacl -m m:4 acluser 
[user@server1 tmp]$ getfacl -c acluser
user::rw-
user:user100:rw-		#effective:r--
user:user200:rwx		#effective:r--
group::rw-			    #effective:r--
mask::r--
other::r--
</pre>
      <p>
        Teraz przy zdefiniowanych przez nas listach użytkowników, pojawił się
        komentarz <code class="code-inline">#effective:r--</code>. Oznacza to,
        iż uprawnienia zostały zmniejszone ponieważ, przekraczają nałożoną na 
        plik maskę list kontroli. Zrócmy uwagę, ze to ograniczenie
        uprawnień maską dotknęło grupę, do której należy plik. Aby wyłączyć
        automatyczne przeliczanie maski, należy użyć opcji <em>-n</em>. Usunę 
        teraz
        jedną z list, aby zaprezentować jak można to zrobić kiedy listy dla
        poszczególnych użytkowników nie będą nam potrzebne:
      </p>
<pre class="code-block">
[user@server1 tmp]$ getfacl -c acluser 
user::rw-
user:user100:rw-
user:user200:rwx
group::r--
mask::rwx
other::r--

[user@server1 tmp]$ setfacl -x u:user200 acluser 
[user@server1 tmp]$ getfacl -c acluser 
user::rw-
user:user100:rw-
group::r--
mask::rw-
other::r--
</pre>
      <p>
        Teraz oczyszcze plik z list, ponieważ nie są nam już one potrzebne.
      </p>
<pre class="code-block">
[user@server1 tmp]$ setfacl -b acluser
[user@server1 tmp]$ getfacl -c acluser
user::rw-
group::r--
other::r--
</pre>
      <p>
        Po usunięciu list z tak rygorystczną maską możemy zaobserwować, że 
        zostały zmodyfikowane uprawnienia grupy. Przed usunięciem
        list należy ustawić maskę aby odzworowywała wcześniejsze uprawnienia.
      </p>
      <h3 id="4.4.1.defaultacl">4.4.1. Domyślne listy kontroli dostępu</h3>
      <p>
        Domyślne listy kontroli dostępu są stosowane w udostępnionych
        katalogach, aby zapewnić spójny zestaw uprawnień dla elementów w nim
        zawartych. Listy kontroli zdefiniowane dla takiego katalogu są
        dzieczone przez elementy, które się w nim znajdują. Dzięki czemu
        nie trzeba poprawiać uprawnień przy każdym nowym pliku lub katalogu.
        Dziedziczenie nieco różni się w przypadku plików i podkatalogów:  
      </p>
      <ul>
        <li>Pliki otrzymują domyślne listy katalogu nadrzędnego jako zwykłe
          listy kontoli dostępu (<em>access ACL</em>, poznaliśmy je na
          początku tego podrozdziału).</li>
        <li>Podkatalogi przyjmują od katalogu nadrzędnego zarówno, zwykłe jak
          i domyślnie listy kontroli.</li>
      </ul>
      <p>
        Domyślnie listy definiuje się tak samo jak zwykłe, jednak robi się to
        tylko na katalogach wraz z dodatkową opcją polecenia <em>setfacl</em>
        <em>-d</em>. Utworze teraz podkatalog o nazwie <em>projekty</em> w 
        katalogu
        <em>/tmp</em>, następnie nadamu mu dwie domyślnie listy dając dwóm
        użytkownikom systemu pełne uprawnienia do niego.
      </p>
<pre class="code-block">
[user@server1 tmp]$ mkdir projekt
[user@server1 tmp]$ setfacl -dm u:user100:7,u:user200:7 projekt/
[user@server1 tmp]$ getfacl -c projekt/
user::rwx
group::r-x
other::r-x
default:user::rwx
default:user:user100:rwx
default:user:user200:rwx
default:group::r-x
default:mask::rwx
default:other::r-x
</pre>
      <p>
        Następnie utworzę plik o nazwie <em>zalozenia_projektu.txt</em>,
        poniżej znajdują sie jego szczegóły:
      </p>
<pre class="code-block">
[user@server1 projekt]$ touch zalozenia_projektu.txt
[user@server1 projekt]$ ls -l
total 0
-rw-rw-r--+ 1 user user 0 Jun 23 15:56 zalozenia_projektu.txt
</pre>
      <p>
        Jak widzimy posiada on już jakieś zdefiniowane listy. Są to listy
        odziedziczone po katalogu nadrzędnym. Oto listy tego pliku:
      </p>
<pre class="code-block">
[user@server1 projekt]$ getfacl -c zalozenia_projektu.txt 
user::rw-
user:user100:rwx		#effective:rw-
user:user200:rwx		#effective:rw-
group::r-x			#effective:r--
mask::rw-
other::r--
</pre>
      <p>
        Zauważmy, że odziedziczona maska jest równa uprawnieniom właściela
        pliku i do tego poziomu zostaną sprowadzone wszystkie uprawnienia,
        nawet bit wykonania ustawiony w przypadku grupy, nie jest on ustawiony
        na masce więc jest to przekroczenie maski i patrząc na uprawnienia
        rzeczywiste, grupa nie ma bitu wykonania. Teraz do zwykłych list
        katalogu <em>projekty</em> dodam listy dwóch użytkowników dodanych jako
        listy domyślnie i utworze podkatalog.
      </p>
<pre class="code-block">
[user@server1 tmp]$ setfacl -m u:user100:7,u:user200:7 projekt
[user@server1 tmp]$ getfacl -c projekt/
user::rwx
user:user100:rwx
user:user200:rwx
group::r-x
mask::rwx
other::r-x
default:user::rwx
default:user:user100:rwx
default:user:user200:rwx
default:group::r-x
default:mask::rwx
default:other::r-x

[user@server1 tmp]$ cd projekt/
[user@server1 projekt]$ mkdir commonfiles
[user@server1 projekt]$ getfacl -c commonfiles/
user::rwx
user:user100:rwx
user:user200:rwx
group::r-x
mask::rwx
other::r-x
default:user::rwx
default:user:user100:rwx
default:user:user200:rwx
default:group::r-x
default:mask::rwx
default:other::r-x
</pre>
      <p>
        Jak możemy zauważyć, listy kontroli są identyczne. Teraz dwaj pozostali
        użytkownicy posiadają możliwości zapisywania oraz odczytywania, w
        przypadku katalogów i plików stworzynych przeze mnie. Jednak ja jako
        <em>user</em> będę chciał zapisać coś w plikach innych 
        użytkowników to nie mam takich uprawnień, ponieważ listy dotyczą tylko 
        tych dwóch widocznych na listach.
      </p>
      <h3 id="4.4.2.aclbug">4.4.2. Dziwny problem z listami kontroli dostępu</h3>
      <p class="exam_tip">
        Zapoznając się ze zwykłymi listami dostępu po zdefiniowaniu list o 
        uprawnieniach
        dających pełne prawa jednemu z użytkowników nie mogłem
        (jako on), zapisać nic do pliku za pomocą jakiego kolwiek edytora. Dane 
        mogłem zapisać natomiast przekierowując strumień na przykład z 
        polecenia <em>echo</em>. Ten problem zauważyłem w RHEL 9, w wersji 8.6 
        nie występował. Problem nie występuje na RHEL 9, gdy plik odziedziczy 
        listy
        od katalogu, a uprawnienia zostaną zmniejszone przez maskę, wówczas
        użytkownicy z mogą zapisywać zmiany za pomocą edytorów.  
      </p>
      <h3 id="exec4.1">Ćwiczenie 1: Manipulowanie uprawnieniami pliku</h3>
      <p>
        Jak zwykły użytkownik na maszynie server1, stwórz dwa pliki 
        <em>file11</em> oraz <em>dir11</em>. Uruchom polecenie 
        <em>umask</em> aby określić obecną maskę użytkownika. Używając 
        zapisu symbolicznego ustaw maskę użytkownika na wartość 0035. Utwórz
        plik o nazwie <em>file22</em> oraz katalog o nazwie <em>dir22</em> 
        w katalogu domowym. Sprawdź i porównaj uprawnienia plików i katalogów
        utworzonych na potrzeby tego ćwiczenia. Używając polecenia
        <em>chmod</em> zmień uprawnienia pliku <em>file11</em> aby były takie
        jak uprawnienia pliku <em>file22</em> oraz zmień uprawnienia katalogu
        <em>dir22</em> tak aby identyczne jak uprawnienia folderu 
        <em>dir11</em>. Nie usuwaj jeszcze tych plików.
      </p>
      <h3 id="exec4.2">Ćwiczenie 2: Konfiguracja katalogu do pracy grupowej</h3>
      <p>
        Jako superużytkownik na maszynie <em>server1</em>, utwórz katalog
        <em>/sdir</em> następnie utwórz grupę (<em>groupadd</em>) <em>sgrp</em>
        oraz dwóch użytkowników <em>user1000</em> oraz <em>user2000</em> 
        (<em>useradd</em>). Ustaw właściela katalogu na użytkownika
        <em>root</em> oraz <em>sgrp</em> jako grupę do której należy, następnie
        ustaw odpowiednie uprawnienia: grupa=rwx; inni=--- poza tym ustaw bity
        <em>setgid</em> oraz <em>sticky</em>. Zaloguj się jako <em>user1000</em>
        i utwórz w wyżej wspomnianym katalogu plik, następnie zaloguj się jako
        <em>user2000</em> dokonaj zmian w utworzonym przez <em>user1000</em>
        pliku. Na koniec spróbuj go usunąć. Zapisanie zmian powinno się
        zakończyć się sukcesem, ale próba usunięcia już nie.
      </p>
      <h3 id="exec4.3">Ćwiczenie 3: Wyszukiwanie plików</h3>
      <p>
        Jako superużytkownik na maszynie <em>server1</em>, wyszukaj wszystkie
        pliki w całej strukturze katalogu głównego, które zostały zmodyfikowane
        w ciągu ostatnich 300 minut i wyświetl ich typ. Wyszukaj w całej
        strukturze katalogu głównego pliki nazwanych potoków oraz gniazd.
      </p>
      <h3 id="exec4.4">Ćwiczenie 4: Zaawansowane wyszukiwanie plików</h3>
      <p>
        Jak superużytkownik na maszynie <em>server1</em>, wyszukaj katalogu
        <em>/usr</em> zwykłe pliki z czasem dostępu starszym niż 100 dni oraz
        rozmiarem nie przekraczającym 5 MB, których właścicielem jest 
        <em>root</em>.
      </p>
      <h3 id="exec4.5">Ćwiczenie 5: Ustawianie list dostępu</h3>
      <p>
        Jako superużytkownik na maszynie <em>server1</em>, utwórz plik
        <em>testfile</em> w katalogu <em>/tmp</em>. Utwórz uzytkowników
        <em>user3000</em> oraz <em>user4000</em>. Stwórz na wszcześniej
        utworzonym pliku listy kontroli, ustawiając użytkownikowi 
        <em>user2000</em> uprawnienia równe 7, dla <em>user3000</em>
        uprawnienia równe 6, a dla użytkownika <em>user4000</em> uprawnienia
        równe 4. Usuń listę użytkownika user2000 i wyświetl pozostałe listy.
        Następnie oczyść plik z list dostępu oraz sprawdź czy nie pozostały
        żadne listy.
      </p>
      <h2 id="ch4summary">Podsumowanie</h2>
      <p>
        W tej części materiału zapoznaliśmy się z podstawowymi uprawnieniami
        plików i katalogów, nauczyliśmy się je ustawiać w dwóch różnych
        formach zapisu. Poznaliśmy uprawnienia specjalne oraz jak je
        przypisywać. Dowiedzielśmy się jak ważnym narzędziem jest polecenie 
        <em>find</em>. Na koniec poznaliśmy sposób na rozszerzenie uprawnień
        poza standard <em>ugo/rwx</em> za pomocą list kontroli dostępu. W 
        następnym rozdziale zajmiemy się użytkownikami.
      </p>
      <h1 id="5.userbasics">5. Podstawy zarządzania użytkownikami</h1>
      <p>
        Użytkownik jest encją, czyli odwzrowaniem rzeczywistego elementu.
        Obecność użytkowników w systemie ma jeden cel - wyznaczać granice,
        bowiem każdy z użytkowników posiada swój katalog domowy, w którym
        przechowuje swoje pliki osobiste oraz programy. W tym rozdziale
        nauczymy się tworzyć użytkowników oraz modyfikować ich podstawowe
        informacje, jak np. położenie katalogu domowego czy zmianę numeru
        <em>UID</em>. Na początku jednak zapoznamy się z metodami sprawdzenia
        aktywności użytkowników w systemie, prześledzimy ich próby uzyskania
        dostępu do systemu.
      </p>
      <h2 id="5.1.whoandw">5.1. Kto jest zalogowany do systemu i co robi</h2>
      <p>
        Za pomocą polecenia <strong>who</strong>, możemy sprawdzić kto jest
        zalogowany w systemie, na jakim terminalu pracuje, o której się
        zalogował, jeśli jest połączenie zdalne wówczas po czasie zalogowania
        zobaczymy adres IP w nawiasie. W moim systemie obecnie zalogowanych
        jest dwoje użytkowników:
      </p>
<pre class="code-block">
[user@server1 ~]$ who
root     pts/0        2022-06-25 15:06 (192.168.8.192)
user     pts/1        2022-06-25 15:06 (192.168.8.192)
</pre>
      <p>
        Innym poleceniem zwracającym bierzącą aktywność użytkowników systemie
        jest polecenie <strong>w</strong>. Poniżej znajduje się wynik 
        uruchomienia polecenia na jednym z moich systemów.
      </p>
<pre class="code-block">
user@server1 ~]$ w
 15:09:43 up 4 min,  2 users,  load average: 0.11, 0.23, 0.12
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0     15:06    7.00s  0.10s  0.09s /usr/bin/python3 -s /usr/bin/ranger
user     pts/1     15:06    1.00s  0.00s  0.00s w
</pre>
      <p>
        Pierwszą linia informacji zwracanych przez to polecenie jest identyczna
        z informacjami, które zwraca polecenie <em>uptime</em>. Następnie
        zwraca ono tabele z nazwą użytkownika 
        (<code class="code-inline">USER</code>), nazwą terminala
        (<code class="code-inline">TTY</code>), czasem zalogowania się
        (<code class="code-inline">LOGIN@</code>), czasem bezczynności
        (<code class="code-inline">IDLE</code>), czasem procesora zużytym na
        wykonanie wszystkich zadań po podłączeniu się do terminala wraz z
        zadaniami wykonywanymi w tle (<code class="code-inline">JCPU</code>),
        czasem procesora zużytym na wykonanie bierzącego procesu
        (<code class="code-inline">PCPU</code>) oraz nazwę procesu, która jest
        obecnie wykonywana (<code class="code-inline">WHAT</code>).
      </p>
      <h3 id="5.1.1.loginattempts">5.1.1. Monitorowanie prób logowania się do
        systemu</h3>
      <p>
        Monitorując aktywność systemu nie należy zapominać o sprawdzaniu
        prób zalogowania się do niego. W dystrybucjach Linuksa istnieją trzy
        polecenia przeznaczone do tego celu. Pierwszym z nich jest polecenie
        <strong>last</strong>, które zwraca listę ostatnio zalogowanych
        użytkowników.
      </p>
<pre class="code-block">
[root@server1 ~]# last
user     pts/1        192.168.8.192    Sat Jun 25 15:06   still logged in
root     pts/0        192.168.8.192    Sat Jun 25 15:06   still logged in
reboot   system boot  5.14.0-70.13.1.e Sat Jun 25 17:05   still running
user     pts/0        192.168.8.182    Fri Jun 24 14:20 - 17:14  (02:53)
reboot   system boot  5.14.0-70.13.1.e Fri Jun 24 16:19 - 17:14  (00:54)
root     pts/1        192.168.8.182    Thu Jun 23 15:54 - 17:27  (01:32)
user     pts/0        192.168.8.182    Thu Jun 23 14:18 - 17:27  (03:08)
user     pts/0        192.168.8.182    Thu Jun 23 11:04 - 14:17  (03:13)
...
</pre>
      <p>
        Polecenie poza tym kto się zalogował, do jakiego terminala, czy
        zdalnie czy lokalnie, zwraca również informacje, o której system
        został uruchomiony - wpisy rozpoczynające się od 
        <code class="code-block">reboot</code>. Nieścisłości czasowe
        wynikają z tego iż, zegar RTC na serwerze ustawiony jest z
        uzględniem strefy czasowej oraz zmian czasu lokalnego (powinien
        wskazywać na czas UTC), poźniej te dane są skorygowane po
        skomunikowaniu się z serwerami czasu. Chcąc wyświetlić tylko listę,
        kiedy dokonano startu systemu wydajemy to polecenie z
        argumentem <em>reboot</em>, ten argument jest tak naprawdę nazwą
        użytkownika.
      </p>
<pre class="code-block">
[root@server1 ~]# last reboot
reboot   system boot  5.14.0-70.13.1.e Sat Jun 25 15:42   still running
reboot   system boot  5.14.0-70.13.1.e Sat Jun 25 17:05 - 15:42  (-1:23)
reboot   system boot  5.14.0-70.13.1.e Fri Jun 24 16:19 - 17:14  (00:54)
reboot   system boot  5.14.0-70.13.1.e Thu Jun 23 11:23 - 17:27  (06:03)
reboot   system boot  5.14.0-70.13.1.e Wed Jun 22 17:30 - 00:17  (06:47)
reboot   system boot  5.14.0-70.13.1.e Tue Jun 21 15:13 - 18:14  (03:00)
reboot   system boot  5.14.0-70.13.1.e Mon Jun 20 21:11 - 19:47  (-1:23)
reboot   system boot  5.14.0-70.13.1.e Mon Jun 20 11:54 - 16:18  (04:24)
...
</pre>
      <p>
        Dane wyświetlane przez to polecenie przechowywane są w pliku
        <em>/var/log/wtmp</em>.
      </p>
      <p>
        Alternatywnie do listy ostatnio zalogowanych użytkowników, możemy
        przejrzeć listę prób logowania się do systemu, które się nie powiodły.
        Temu służy polecenie <strong>lastb</strong>.
      </p>
<pre class="code-block">
[root@server1 ~]# lastb
user     ssh:notty    192.168.8.182    Thu Jun 23 14:18 - 14:18  (00:00)
user     ssh:notty    192.168.8.182    Thu Jun 23 14:18 - 14:18  (00:00)
user1000 pts/0                         Tue Jun 21 17:28 - 17:28  (00:00)
user     ssh:notty    192.168.8.182    Mon Jun 20 19:27 - 19:27  (00:00)
user100  pts/1                         Mon Jun 20 13:00 - 13:00  (00:00)
user     ssh:notty    192.168.8.182    Mon Jun 20 10:44 - 10:44  (00:00)
root     pts/0                         Fri Jun 10 17:59 - 17:59  (00:00)
</pre>
      <p>
        W przypadku połączeń SSH oznaczenie 
        <code class="code-inline">notty</code>, mówi nam że nie przydzielono
        terminala z powodu niepowodzenia logowania. Kiedy w drugiej kolumnie 
        zobaczymy oznaczenie <em>pts/X</em> (X oznacza numer urządzenia), to
        możemy stwierdzić, że nie powiodło się przełączenie na wskazanego w
        pierwszej kolumnie użytkownika. Na serwerach, które mają otwarty port
        22 oraz pozwalają na zalogowanie się za pomocą hasła polecenie będzie
        zwracać zazwyczaj bardzo długą listę. Wiele automatów na całym świecie
        próbuje zalogować się na serwer poprzez zagdywanie użytkownika i hasła.
      </p>
      <p>
        Plikiem, który przechowuje informacje zwracane przez to polecenie
        jest <em>/var/log/btmp</em>.
      </p>
      <p>
        Ostanim narzędziem pozwalającym na sprawdzenie kto logował się do
        systemu jest polecenie <strong>lastlog</strong>, wyświetla ono 
        ostatnie logowanie na podstawie listy użytkowników. 
      </p>
<pre class="code-block">
[root@server1 ~]# lastlog
...
user             pts/1    192.168.8.192                             Sat Jun 25 15:06:16 +0200 2022
vboxadd                                                             **Never logged in**
user100          pts/1                                              Thu Jun 23 15:55:01 +0200 2022
user200          pts/0                                              Fri Jun 24 16:55:08 +0200 2022
user1000         pts/0                                              Tue Jun 21 17:28:44 +0200 2022
user2000         pts/0                                              Tue Jun 21 17:28:50 +0200 2022
user3000                                                            **Never logged in**
user4000                                                            **Never logged in**
user3            pts/0                                              Thu Jun 23 12:13:34 +0200 2022
user4            pts/0                                              Thu Jun 23 12:33:09 +0200 2022
user4100                                                            **Never logged in**
user4200                                                            **Never logged in**
user4300         pts/0                                              Thu Jun 23 13:01:04 +0200 2022
</pre>
      <p>
        Napis <code class="code-inline">**Never logged in**</code> oznacza, że
        użytkownik nie logował się do systemu. Informacje zwracane przez to
        polecenie są przechowywane w pliku <em>/var/log/lastlog</em>.
      </p>
      <h3 id="5.1.2.idandgroup">5.1.2. Informacje o użytkowniku</h3>
      <p>
        Podczas pracy z użytkownikami, możemy potrzebować informacji na jego
        temat. Równie dobrze moglibyśmy sprawdzić go w pliku 
        <em>/etc/passwd</em>, ale jest lepszy sposób. Na Linuksach dostępne
        jest polecenie <em>id</em>, które zwraca <em>UID</em>, <em>GID</em>
        podstawowej grupy oraz grupy, do których należy użytkownik podany jak
        argument tego polecenia:
      </p>
<pre class="code-block">
[root@server1 ~]# id user100
uid=1001(user100) gid=1001(user100) groups=1001(user100),9999(sgrp)
</pre>
      <p>
        Wówczas jeśli jako my sami potrzebuje wyświetlić, grupy do których
        należymy możemy użyć polecenia <strong>groups</strong>.
      </p>
<pre class="code-block">
[user100@server1 ~]$ groups
user100 sgrp
</pre>
      <h2 id="5.2.userauthfiles">5.2. Pliki autentykacji użytkowników</h2>
      <p>
        Każdy użytkownik, chcący skorzystać z systemu musi się uwierzytelnić
        za pomocą tylko jemu znanych poświadczeń, wówczas zostaje on
        autoryzowany do wykonywania różnych czynności w systemie. Sam system
        do uwierzytelniania użytkowników stosuje kilka plików. 
      </p>
      <h3 id="5.2.1.passwdfile">5.2.1. Pliki /etc/passwd</h3>
      <p>
        Ten plik jest swoistą bazą danych o użytkownikach w systemie. Każdy
        jeden wpis to jeden użytkownik.
      </p>
<pre class="code-block">
[root@server1 ~]# tail -5 /etc/passwd
user:x:1000:1000:user:/home/user:/bin/bash
user100:x:1001:1001::/home/user100:/bin/bash
user200:x:1002:1002::/home/user200:/bin/bash
user1000:x:1003:1003::/home/user1000:/bin/bash
user2000:x:1004:1004::/home/user2000:/bin/bash
</pre>
      <p>
        Każdy z tych wpisów zawiera kilka pól oddzielonych od siebie
        dwukropkiem (<strong>:</strong>). Natomiast same pola oznaczają
        kolejno:
      </p>
      <ul>
        <li><strong>Nazwę użytkownika</strong> - 
          <code class="code-inline">user</code>. Nazwy użytkowników na
          Linuksie nie powinny przekraczać 255 znaków oraz zawierać innych
          znaków specjalnych niż podkreślnik (<strong>_</strong>) lub 
          myślnik (<strong>-</strong>) i niepowinny zawierać z wielkich liter,
        </li>
        <li><strong>Hasło</strong> - <code class="code-inline">x</code>,
          w tym przypadku <em>x</em> oznacza, że hasło jest zaszyforwane w 
          pliku <em>/etc/shadow</em>, w tym polu może znajdować się również
          gwiazdka (<strong>*</strong>), która oznacza że konto jest wyłączone.
        </li>
        <li><strong>UID</strong> - <code class="code-inline">1000</code>, jest
          identyfikator użytkownika, jądro odwołując się do użytkowników
          używa tych identyfikatorów. W systemie istnieją zakresy 
          <em>UID</em>, które są przypisywane poszczególnym użytkownikom.
          Identyfikator 0, jest zarezerwowany dla <em>root</em>, identyfikatory
          do 1 do 999 są przeznaczone dla użytkowników systemowych (przeważnie
          tworzonych na potrzeby usług, w RHEL istnieje podział, iż
          <em>UID</em>-y od 1 do 200 są przeznaczone dla użytkowników
          przypisanych do wewętrznych usług systemowych a <em>UID</em>-y od 201 
          do 999 dla pozostałych).</li>
        <li><strong>GID</strong> - <code class="code-inline">1000</code>, jest
          to identyfikator grupy podstawowej użytkownika (podczas tworzenia
          użytkownika, tworzona jest także grupa o takiej samej nazwie jak
          użytkownik i jest ona nazywana podstwową grupą użytkownika. Istnienie
          takiej grupy zapewnia spójność uprawnień plików).</li>
        <li><strong>Komentarz</strong> - <code class="code-inline">user</code>,
          Komentarz, dawniej pole <em>GECOS</em>, jest miejscem na dodatkowe
          informacje o użytkowniku, np. numer telefonu lub adres e-mail.</li>
        <li><strong>Katalog domowy</strong> -
          <code class="code-inline">/home/user</code>, to pole zawiera ścieżkę
          do katalogu domowego.</li>
        <li><strong>Powłoka</strong> -
          <code class="code-inline">/bin/bash</code>, miejsce dla domyślnego
          programu uruchamianego zaraz po zalogowaniu najczęsciej jest to
          jedna z dostępnych w systemie powłok.</li>
      </ul>
      <h3 id="5.2.2.shadowfile">5.2.2. Plik /etc/shadow</h3>
      <p>
        Plik <em>/etc/shadow</em>, koreluje z plikem <em>/etc/passwd</em> ich
        wspólnym kluczem jest nazwa użytkownika. Plik ten zamiast ogólnych
        informacji o użytkowniku zawiera jego hasło oraz zasady związane z
        hasłami. Tak jak w przypadku pliku <em>passwd</em> każdy wpis
        odpowiada jedemu użytkownikowi.
      </p>
<pre class="code-block">
[root@server1 ~]# tail -5 /etc/shadow
user:$6$bNlZFNZV/wWKGQU8$DgIHeUdALGWs7bZ7Foet2UeHFSANSvYcEtLmn6aLm5QxLcx10jZNkUg.dphdmizej/k5Xe.oEqSCeHAf5/7Gv0::0:99999:7:::
user100:$6$N3norXlohg0yE1pi$FyeKcBNl4mj/nLbNRlx7KaAQnddG0y/kXpQ9pbgjTV9ti3dQ5q3pIpXm1poa85oxFHFVT9HPTyBmaRNkrSJPX.:19163:0:99999:7:::
user200:!!:19163:0:99999:7:::
user1000:!!:19163:0:99999:7:::
user2000:!!:19163:0:99999:7:::
</pre>
      <p>
        Każdy z tych wpisów zawiera kilka pól oddzielonych od siebie
        dwukropkiem (<strong>:</strong>). Natomiast same pola oznaczają
        kolejno:
      </p>
      <ul>
        <li><strong>Nazwę użytkownika</strong> -
          <code class="code-inline">user</code>, odpowiadającą nazwie
          użytkownika z pliku <em>/etc/passwd</em>.</li>
        <li><strong>Zaszyfrowane hasło</strong> -
          <code class="code-inline">$6$bNlZFNZV/wWKGQU8$DgIHeUdALGWs7bZ7Foet2UeHFSANSvYcEtLmn6aLm5QxLcx10jZNkUg.dphdmizej/k5Xe.oEqSCeHAf5/7Gv0</code>, utworzone na podstawie hasła wpisanego
          przez użytkownika. RHEL w przypadku przesłonionych haseł używa
          algorytmu SHA-512. Jeśli to pole zawiera wykrzyknik
          (<strong>!</strong>), to wówczas użytkownik nie może zalogować się
          do systemu za pomocą hasła. Puste pole oznacza, że uzytkownik może
          zalogować się bez wprowadzania hasła.</li>
        <li><strong>Ostatnia zmiana hasła</strong> - 
          <code class="code-inline">19163</code>, to pole zawiera liczbę
          dni, która upłyneła od północy 1 stycznia 1970r. (początku czasu
          Uniks) do momentu zmiany hasła. To pole można uznać za liczbową
          datę.</li>
        <li><strong>Minimalny wiek hasła</strong> -
          <code class="code-inline">0</code>, wyznacza liczbę dni, która może
          upłynąć przed następną zmianą hasła. Puste pole lub zero oznacza
          iż, nie ustalono minimalnego wieku dla hasła tego użytkownika.</li>
        <li><strong>Maksymalny wiek hasła</strong> -
          <code class="code-inline">99999</code>, wyznacza liczbę dni, po
          której należy zmienić hasło. Hasła, których ważność osiągnie tę 
          wartość mogą być dalej ważne, jednak system przy następnym logowaniu
          będzie wymagał jego zmiany.</li>
        <li><strong>Okres ostrzegania</strong> - 
          <code class="code-inline">7</code>, określa ilość dni, w których
          użytkownik będzie informowany o tym, że mija termin ważności jego
          hasła i musi je zmienić, aby dalej móc się logować do systemu.</li>
        <li><strong>Okres nieaktywności hasła</strong> - określa ilość dni,
          przez które przeterminowane hasło będzie jescze akceptowane. Po
          zalogwaniu system będzie żądać zmiany hasła. W przypadku naszego
          przykładu, to pole jest puste, a więc nie ma zdefiniowanego tego
          okresu.</li>
        <li><strong>Data wygaśnięcia konta</strong> - określa ilość dni od
          północy 1 stycznia 1970r., po których nie będzie można używać
          konta do logowania się. Zero bądź puste pole (tak jak na
          przykładzie) oznacza iż konto nigdy nie wygaśnie.</li>
        <li><strong>Pole zarezerowane</strong> - pole zarezerowowane do użycia
          w przyszłości.</li> 
      </ul>
      <p>
        W przypadku pól od zaszyfrowanego hasła do pola zarezerowanego. Puste
        pole lub 0 wyłącza przeznaczone im właściwości. Część z tych opcji 
        ustawiana jest w pliku <em>/etc/login.defs</em> i nazwane są 
        <strong>zasadami ważności haseł</strong> lub ang.
        <em>pasword aging</em>. Na koniec zwróćmy uwagę na szczegóły tego pliku:
      </p>
<pre class="code-block">
[root@server1 ~]# ls -l /etc/shadow
----------. 1 root root 2012 Jun 25 18:53 /etc/shadow
</pre>
      <p>
        Nikt nie ma żadnych uprawnień do tego pliku. Możliwa jest jego
        modyfikacja za pomocą specjalnego mechanizmu, który będzie omawiany
        przy okazji <em>SELinux</em>.
      </p>
      <h3 id="5.2.3.group">5.2.3. Plik /etc/group</h3>
      <p>
        Plik <em>/etc/group</em> jest odpowiednikiem dla pliku 
        <em>/etc/passwd</em> tylko, że dla group. Ten plik ma podobną budową
        do plików <em>/etc/passwd</em> lub <em>/etc/shadow</em> posiada jednak
        mniejszą ilość pól.
      </p>
<pre class="code-block">
[root@server1 ~]# tail -5 /etc/group
user:x:1000:
user100:x:1001:
user200:x:1002:
sgrp:x:9999:user100,user200
sgrp2:x:8888:user1000,user2000
</pre>
      <p>
        A każde z pół przechowuje kolejno:
      </p>
      <ul>
        <li><strong>Nazwę grupy</strong> - 
          <code class="code-inline">sgrp</code>.</li>
        <li><strong>Hasło grupy</strong> -
          <code class="code-inline">x</code>, oznacza że hasło jest
          zaszyfrowane w pliku <em>/etc/gshadow</em>. Hasła grupy służą
          zablokowaniu przełączania się między grupami za pomocą polecenia
          <strong>newgrp</strong>, aby użytkownicy nie mogli uzyskać dostępu
          plików innych grup.</li>
        <li><strong>GID</strong> -
          <code class="code-inline">9999</code>, identyfikator grupy.</li>
        <li><strong>Lista członków grupy</strong> -
          <code class="code-inline">user100,user200</code>, lista użytkowników
          oddzielonych przecinkami przypisanych do tej grupy. W przypadku
          podstawowych grup użytkowników (nazwa grupy jest identyczna z nazwą
          użytkownika), a członek jest domyślny i nie widnieje na liście.</li>
      </ul>
      <h3 id="5.2.4.gshadowfile">5.2.4. Plik /etc/gshadow</h3>
      <p>
        Grupy jak i użytkownicy również mają swoje hasła. W opisie pola hasła
        przy okazji pliku <em>/etc/group</em> wyjaśniłem dlaczego tak jest. Te
        hasła muszą być gdzieś składowane i to w bezpieczny sposób. Hasła grup
        również są przesłonione jak hasła użytkowników. Miejscem składowania
        haseł grup jest jest plik <em>/etc/gshadow</em>, zawiera on podobne
        wpisy jak plik <em>/etc/group</em> i jest z nim powiązany wspólnym
        kluczem jakim jest nazwa grupy.
      </p>
<pre class="code-block">
[root@server1 user]# tail /etc/gshadow
user:!::
user100:!::
user200:!::
dba:!::
user1000:!::
user2000:!::
dbagrp:!::
user90:!::
g1:!::
</pre>
      <p>
        Plik <em>/etc/gshadow</em> zawiera 4 pola tak jak plik 
        <em>/etc/group</em>, każde z tych pól oznacza kolejno:
      </p>
      <ul>
        <li><strong>Nazwa grupy</strong> -
          <code class="code-inline">user</code>, identyczna z nazwą zawartą w
          we wpisach w pliku <em>/etc/group</em>.</li>
        <li><strong>Zaszyforwane hasło</strong>, jeśli tym polu pojawia się
          inny znak taki jak <code class="code-inline">!</code> lub gwiazdka
          (<strong>*</strong>) oznacza to, że użytkownicy nie mogą za pomocą
          hasła uzyskać dostępu do grupy.</li>
        <li><strong>Administratorz grupy</strong>, lista użytkowników mogących
          zarządzać grupą, mogą oni dodawać i usuwać członków przy użyciu 
          polecenia <strong>gpasswd</strong>.</li>
        <li><strong>Członkowie grupy</strong>, oddzielona przecinkami lista
          użytkowników należąca do tej grupy.</li>
      </ul>
      <h2 id="5.3.basicsofusermanagement">5.3. Podstawy zarządzania użytkownikami</h2>
      <p>
        W tym podrozdziale poznamy podstawy zarządzania użytkownikami. Będziemy
        tworzyć użytkowników, zmieniać informacje o nich oraz ich usuwać. 
        Tworząc nowego 
        użytkownika wydajemy proste polecenie i podajemy jego nazwę. Taki 
        użytkownik tworzony jest z domyślnymi wartościami. Zanim zaczniemy
        tworzyć użytkowników poznamy dwa miejsca, skąd mogą brać się te
        domyślne wartości.
      </p>
      <h3 id="5.3.1.usersdefaultinformations">5.3.1. Domyślnie informacje
        użytkowników</h3>
      <p>
        Informacje o tym jaką przydzielić użytkownikowi powłokę, czy między
        jakimi wartościami powinien znajdować się jego <em>UID</em> są w
        systemie z góry określone. Takimi miejscami, w których możemy szukać
        domyślnych wartości jest plik <em>/etc/default/useradd</em>,
        którego zawartość dostępna jest po wydaniu poniższego polecenia:
      </p>
<pre class="code-block">
[user@server1 ~]$ useradd -D
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes
</pre>
      <p>
        Z tych informacji możemy wynioskować początkowy <em>GID</em>
        (<code class="code-inline">GROUP</code>), jednak
        ta opcja używana jest gdy opcja <em>USERGROUPS_ENAB</em>, w pliku
        <em>/etc/login.defs</em> (drugim z plików) jest ustawiona na <em>NO</em>.
        Poza tym znamy domyślną lokalizację tworzenia katalogów domowych
        (<code class="code-inline">HOME</code>), czas nieaktywność
        (<code class="code-inline">INACTIVE</code>), który określa liczbę dni
        pomiędzy wygaśnięciem hasła a trwałym zablokowaniem konta, domyślną
        datę wygaśnięcia konta (<code class="code-inline">EXPIRE</code>), 
        domyślną powłokę (<code class="code-inline">SHELL</code>), lokalizację
        katalogu szkieletowego (<code class="code-inline">SKEL</code>) - 
        katalog ten przechowuje pliki kopiowane do każdego katalogu domowego
        nowego użytkownika w momencie jego utworzenia. Ostatnią wartością jest
        zmienną określająca czy tworzyć pliki skrzynki mailowej każdemu 
        użytkownikowi
        (<code class="code-inline">CREATE_MAIL_SPOOL</code>). Nie które z tych
        wartości możemy modyfikować używając tego samego polecenia, więcej
        informacji na ten temat znajduje się na stronie podręcznia polecenia
        <em>useradd</em>.
      </p>
      <p>
        Innym źródłem wartości domyślnych wykorzystywanych podczas tworzenia
        użytkowników jest plik <em>/etc/login.defs</em>. Zawartość tego pliku
        najlepiej jest wyświetlić za pomocą poniższego polecenia, które
        odfiltruje komentarz i puste linie:
      </p>
<pre class="code-block">
[user@server1 ~]$ grep -v ^# /etc/login.defs | grep -v ^$
MAIL_DIR	/var/spool/mail
UMASK		022
HOME_MODE	0700
PASS_MAX_DAYS	99999
PASS_MIN_DAYS	0
PASS_WARN_AGE	7
UID_MIN                  1000
UID_MAX                 60000
SYS_UID_MIN               201
SYS_UID_MAX               999
SUB_UID_MIN		   100000
SUB_UID_MAX		600100000
SUB_UID_COUNT		    65536
GID_MIN                  1000
GID_MAX                 60000
SYS_GID_MIN               201
SYS_GID_MAX               999
SUB_GID_MIN		   100000
SUB_GID_MAX		600100000
SUB_GID_COUNT		    65536
ENCRYPT_METHOD SHA512
USERGROUPS_ENAB yes
CREATE_HOME	yes
HMAC_CRYPTO_ALGO SHA512
</pre>
      <p>
        Wewnątrz tego pliku znajdują się definicje takich wartości jak
        maska użytkownika (<code class="code-inline">umask</code>), elementy
        polityki haseł (<code class="code-inline">PASS_...</code>) czy zakresy
        wartości <em>UID</em> oraz <em>GID</em>. W tym pliku również znajduje
        się nazwa algorytmu używanego do przesłaniania haseł. Opisy
        poszczególnych wartości zawartych w tym pliku znajdują się na
        stronie podręcznika.
      </p>
      <h3 id="5.3.2.useradd">5.3.2. Tworzenie użytowników</h3>
      <p>
        Do tworzenia użytkowników systemie służy polecenie 
        <strong>useradd</strong>,
        domyślnie wymaga on wyłącznie podania nazwy użytkownika. Podczas tej
        czynności zostaną dodane wpisy do plików autentykacyjnych, które 
        omwialiśmy
        wcześniej, zostanie utworzony katalog domowy i przekopiowane zostaną
        do niego pliki z katalogu szkieletowego (<em>/etc/skel</em>). Utworzymy
        sobie teraz testowego użytkownika.
      </p>
<pre class="code-block">
[root@server1 user]# useradd user1
</pre>
      <p>
        To polecenie utworzy użytkownika z domyślnymi wartościamy identyfkatora,
        powłoki oraz innymi. Polecenie to daje możliwość zmiany tych wartości
        podczas tworzenie nowego użytkownika. Poniżej znajduje się lista, na 
        której zawarto najważniejsze z nich:
      </p>
      <ul>
        <li><strong>-d</strong>, pozwala na podanie ścieżki do katalogu
          domowego użytkownika.</li>
        <li><strong>-g</strong>, pozwala na podanie <em>GID</em>-u lub nazwy
          podstawowej grupy użytkownika.</li>
        <li><strong>-G</strong>, pozwala na wprowadzenie grup, do których ma
          należeć użytkownik, nazwy podajemy po przecinku (o ile więcej niż
          jedna)</li>
        <li><strong>-o</strong>, każdy identyfikator czy to użytkownika czy
          grupy musi być unikatowy. Ta opcja pozwala na współdzielenie
          (w tym przypadku) <em>UID</em>-u, choć konieczność użycia tej opcji
          zachodzi tylko w specyficznych przypadkach.</li>
        <li><strong>-s</strong>, pozwala na ustalenia domyślnego programu,
          który uruchamiany jest zaraz po zalogowaniu się użytkownika. Tym
          programem najczęściej jest powłoka.</li>
        <li><strong>-u</strong>, pozwala na podanie identyfikatora użytkownika
          <em>UID</em>, identyfikator powinien być unikatory w cały systemie,
          chyba że podano opcję <em>-o</em>.</li>
      </ul>
      <p>
        Chcąc użyć tych opcji podaje się je po nazwie polecenia przed nazwą
        użytkownika. W ramach ćwiczeń możemy utworzyć kilku użytkowników z
        losowymi wartościami opcji podanych powyżej. W tym rozdziale poznamy
        narzędzie, które służy usuwania użytkowników, ale za nim to zrobimy
        poznamy polecenie, dzięki któremu będziemy mogli zmienić opcje już
        utworzonych użytkowników.  
      </p>
      <p>
        Tak utworzonym użytkowników pozostało tylko nadać hasło, przy użyciu
        polecenie <strong>passwd</strong>.
      </p>
      <p>
        Tutaj podano tylko część opcji tego polecenia, więcej znajduje się
        na stronie podręcznika. Nie uczmy się także opcji na pamięć, raczej
        zawsze będziemy mieć dostęp do stron podręcznika.
      </p>
      <h3 id="5.3.3.usermod">5.3.3. Zmiana informacji użytkownika</h3>
      <p>
        Zmianie informacji użytkownika służy polecenie <strong>usermod</strong>,
        ma ono prawie identyczne opcje jak polecenie <em>useradd</em>. Poza
        kilkoma wyjątkami.
      </p>
      <ul>
        <li><strong>-l</strong> - opcja pozwala na podanie nowej nazwy
          użytkownika.</li>
        <li><strong>-d</strong> - opcja pozwala na zmianę katalogu domowego.
          Nie było by tej opcji na tej liście gdyby nie fakt, iż aby katalog
          został utworzony na podanej ścieżce, ta opcją musi zostać użyta w
          raz z opcją <em>-m</em>, której zadaniem jest przeniesienie danych
          z poprzedniego katalogu.</li>
      </ul>
      <p>
        Na poniższym przykładzie pokazano zmianę katalogu domowego użytkownika
        <em>user90</em>:
      </p>
<pre class="code-block">
[root@server1 ~]# tail /etc/passwd
...
user90:x:5003:5003::/home/user90:/bin/bash

[root@server1 ~]# usermod -d /usr/home90 -m user90
[root@server1 ~]# tail /etc/passwd
...
user90:x:5003:5003::/usr/home90:/bin/bash

[root@server1 ~]# ls -al /usr/home90
total 12
drwx------.  3 user90 user90  78 Jun 26 16:06 .
drwxr-xr-x. 13 root   root   158 Jun 27 14:31 ..
-rw-r--r--.  1 user90 user90  18 Nov  5  2021 .bash_logout
-rw-r--r--.  1 user90 user90 141 Nov  5  2021 .bash_profile
-rw-r--r--.  1 user90 user90 492 Nov  5  2021 .bashrc
drwxr-xr-x.  4 user90 user90  39 Jun 26 13:48 .mozilla
</pre>
      <p>
        Pozostałe opcje, które znajdują się na stronie podręcznika tego
        polecenia możemy używać w ten sam sposób jak w przypadku
        <em>useradd</em>.
      </p>
      <h3 id="5.3.4.userdel">5.3.4. Usuwanie użytkowników</h3>
      <p>
        Kiedy użytkownicy przestają być potrzebni, ze względów bezpieczeństwa
        można, albo ich zablokować albo usunąć. W tym rodziale zajmiemy się
        wyłącznie usuwaniem. Polecenie do usuwania użytkowników to
        <strong>userdel</strong>. Jest ono prostolinijne i niewymaga 
        dodatkowych przełączników, wystarczy podać nazwę użytkownika jako
        argument polecenia i użytkownik zostanie usunięty, jednak jego dane
        pozostaną w systemie. Użytkownika wraz z danymi możemy usunąć za
        przy użyciu opcji <em>-r</em>.
      </p> 
<pre class="code-block">
[root@server1 ~]# userdel -r user90
[root@server1 ~]# tail /etc/passwd
chrony:x:986:981::/var/lib/chrony:/sbin/nologin
dnsmasq:x:985:980:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
systemd-oom:x:978:978:systemd Userspace OOM Killer:/:/usr/sbin/nologin
user:x:1000:1000:user:/home/user:/bin/bash
user100:x:1001:1001::/home/user100:/bin/bash
user200:x:1002:1002::/home/user200:/bin/bash
user5000:x:5000:7000::/home/user5000:/bin/bash
user1000:x:5001:5001::/home/user1000:/bin/bash
user2000:x:5002:5002::/home/user2000:/bin/bash
[root@server1 ~]# ls -al /usr/home90
ls: cannot access '/usr/home90': No such file or directory
</pre>
      <h3 id="5.3.5.nologinusers">5.3.5. Użytkownicy bez możliwości logowania</h3>
      <p>
        Tak jak na początku powiedzieliśmy sobie, że użytkownicy w systemie
        istnieją, po to aby wyznaczać granice. Takim użytkownikami
        są najczęściej są użytkownicy systemowi, którzy są związani z róznego
        rodzaju usługami. Cechą która ich wyróżnia jest fakt, iż nie mają
        oni możliwości logowania do systemu, inaczej mówiac są 
        <strong>użytkownikami nieinteraktywnymi</strong>. Użytkownicy tego 
        typu w miejscu powłoki mają
        wskazany program <strong>/sbin/nologin</strong>. Ten mały program przy
        próbie zalogowania zwróci informacje o tym, że to konto jest obecnie
        niedostępne. Treść tego komunikatu możemy zmieniać, wpisująć nasz
        komunikat do pliku <em>/etc/nologin.txt</em>. Użytkownikiem bez
        możliwości logowania może być każdy, kto ma zamiast powłoki ustawiony
        właśnie ten program. Poniżej znajduje się polecenie, które zmieni
        użytkownika <em>user2000</em> w użytkownika nieinteraktywnego.
      </p>
<pre class="code-block">
[root@server1 ~]# usermod -s /sbin/nologin user2000
[root@server1 ~]# tail /etc/passwd
chrony:x:986:981::/var/lib/chrony:/sbin/nologin
dnsmasq:x:985:980:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
systemd-oom:x:978:978:systemd Userspace OOM Killer:/:/usr/sbin/nologin
user:x:1000:1000:user:/home/user:/bin/bash
user100:x:1001:1001::/home/user100:/bin/bash
user200:x:1002:1002::/home/user200:/bin/bash
user5000:x:5000:7000::/home/user5000:/bin/bash
user1000:x:5001:5001::/home/user1000:/bin/bash
user2000:x:5002:5002::/home/user2000:/sbin/nologin
</pre>
      <p>
        Kiedy spróbuje się na niego zalogować otrzymam wspomniany komunikat.
      </p>
<pre class="code-block">
[root@server1 ~]# su - user2000
This account is currently not available.
</pre>
      <p class="exam_tip">
        Jeśli w systemie użytkownik, który teoretycznie nie powinien mieć
        możliwości logowania zaloguje się do systemu to znaczy, że mamy
        poważny problem z bezpieczeństwem. Wówczas należy sprawdzić 
        w pliku <em>/etc/passwd</em> czy wszyscy użytkownicy nieinteraktywni 
        mają ustawiony domyślny program na <em>/sbin/nologin</em>.
      </p>
      <h3 id="exec5.1">Ćwiczenie 1: Sprawdzenie prób logowania użytkowników</h3>
      <p>
        Jako superużytkownik na maszynie <em>server1</em>. Zapisz przy użyciu
        polecenia <em>Vim</em> ostaniego użytkownika, któremu udało się
        zalogować oraz ostatniego którego logowanie nie powiodło się. Zapisz 
        ostatnie
        uruchomienie systemu, poza obecnym włączniem oraz listę użytkowników, 
        którzy nigdy się nie logowali do systemu.
      </p>
      <h3 id="exec5.2">Ćwiczenie 2: Weryfikacja użytkownika oraz grupy</h3>
      <p>
        Jako superużytkownik na maszynie <em>server1</em>, uruchom polecenie
        <em>who</em> oraz <em>w</em> porównaj wyniki ich działania. Uruchom
        polecnia <em>id</em> oraz <em>groups</em> następnie omów informacje
        zwracane przez nie.
      </p>
      <h3 id="exec5.3">Ćwiczenie 3: Tworzenie użytkowników</h3>
      <p>
        Jak superużytkownik na maszynie <em>server1</em>, utwórz użytkownika o
        nazwie <em>user4100</em>, o identyfikatorze <em>4100</em>, katalogu
        domowym znajdującym się katalogu <em>/usr</em>. Następnie utworz
        użytkownika <em>user4200</em> z domyślnymi ustawieniami. Przypisz obu
        hasło. Następnie wyświetl dotyczące ich wpisy w plikach autentykacji
        (<em>/etc/{passwd,shaddow,group,gshadow}</em>).
      </p>
      <h3 id="exec5.4">Ćwiczenie 4: Tworzenie użytkowników nieinteraktywnych</h3>
      <p>
        Jako superużytkownik na maszynie <em>server1</em>, utwórz użytkownika
        <em>user4300</em>, następnie zmień informacje o nim tak, aby stał sie
        użytkownikiem nieinterkatywnym. Ustaw mu hasło i spróbuj się zalogować
        na niego. Jaki komunikat został wyświetlony? Wyświetl wpis użytkownika
        w pliku <em>/etc/passwd</em>. Co spowodowało, że użytkownik nie może
        się zalgować?
      </p>
      <h2 id="ch5summary">Podsumowanie</h2>
      <p>
        W tym rozdziale dowiedzieliśmy się w jaki sposób możemy sprawdzić
        próby logowania się do systemu, kto jest zalgowany i co robi. 
        Poznaliśmy zestaw plików odpowidzialnych za autentykacje, a także
        nauczyliśmy w podstawowym stopniu zarządzać użytkownikami. W następnym
        rozdziale skupimy się na zasadach haseł i przełączaniu użytkowników.
      </p>
      <h1 id="6.advancedusermanagement">6. Zaawansowane zarządzanie użytkownikami</h1>
      <p>
        W poprzednim rozdziele nauczyliśmy się tworzyć, usuwać użytkowników oraz
        edytować informacje o nich. Poznaliśmy plik uwierzytelniania, którym
        między innymi jest plik <em>/etc/shadow</em>, w nim przechowywane są
        przesłonione hasła oraz zasady ważności haseł oraz kont i tym
        zajmiemy sie na początku.
      </p>
      <h2 id="6.1.passwordaging">6.1. Zasady ważności hasła</h2>
      <p>
        Każdy administrator systemu, który wykorzystuje intensywnie użytkowników, 
        powinien
        wdrożyć zasady bezpieczeństwa z nimi związane. Może wymusić na osobach 
        korzystających z kont ich zabezpieczenie po przez regularną zmianę hasła, 
        zablokować nieużywane konta czy utworzyć dla użytkowników tylko konta
        tymczasowe, które po upływie określonego czasu zostaną automatycznie
        zablokowane. Te zasady mieszczą w się 
        w dziedzinie ustawień ważności hasła i są realizowane w dystrybucjach
        Linuksa za pomocą dwóch poleceń: <strong>chage</strong> oraz
        <strong>passwd</strong>. Poniżej w tabeli skumulowałem opcje 
        tych dwóch poleceń odpowiadające za konkrentą czynność.
      </p>
      <table>
        <thead>
          <tr>
            <th></th>
            <th>chage</th>
            <th>passwd</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Data ostatniej modyfikacji hasła</strong></td>
            <td style="text-align: center"><em>-d</em></td>
            <td style="text-align: center"><em>X</em></td>
          </tr>
          <tr>
            <td><strong>Data wygaśnięcia konta</strong></td>
            <td style="text-align: center"><em>-E</em></td>
            <td style="text-align: center"><em>X</em>
          </tr>
          <tr>
            <td><strong>Czas nieaktywności hasła</strong></td>
            <td style="text-align: center"><em>-I</em></td>
            <td style="text-align: center"><em>-i</em></td>
          </tr>
          <tr>
            <td><strong>Informacje o zasadach użytkownika</strong></th>
            <td style="text-align: center"><em>-l</em></td>
            <td style="text-align: center"><em>-S</em></td>
          </tr>
          <tr>
            <td><strong>Minimalna ważność hasła</strong></td>
            <td style="text-align: center"><em>-m</em></td>
            <td style="text-align: center"><em>-n</em></td>
          </tr>
          <tr>
            <td><strong>Maksymalna ważność hasła</strong></th>
            <td style="text-align: center"><em>-M</em></td>
            <td style="text-align: center"><em>-x</em></td>
          </tr>
          <tr>
            <td><strong>Okres ostrzegania</strong></th>
            <td style="text-align: center"><em>-W</em></td>
            <td style="text-align: center"><em>-w</em></td>
          </tr>
        </tbody>
      </table>
      <p>
        Po za tymi wspólnymi cechami, polecenie <em>passwd</em>, jest wstanie:
      </p>
      <ul>
        <li><strong>usunąć hasło</strong> - <em>-d</em>, takie konto, wówczas
          staje się kontem bez hasła.</li>
        <li><strong>wymusić utratę ważności hasła</strong> - <em>-e</em>, po
          zalogowaniu na takie konto, wymagana będzie zmiana hasła. Ustawienie
          opcji <em>-d</em> polecenia <em>chage</em>, daje ten sam efekt.</li>
        <li><strong>zablokować konto</strong> - <em>-l</em>, użytkownik nie
          będzie mieć możliwości zalogowania się do systemu.</li>
        <li><strong>odblokować konto</strong> - <em>-u</em>, przywraca
          możliwość logowania się zablokowanemu kontu.</li>
      </ul>
      <p>
        Stosując <em>chage</em> lub <em>passwd</em> nazwę użytkownika podajemy
        po opcjach i ich wartościach. Na poniższym przykładzie za preznetowałem
        w jaki sposób możemy ustawić wszystkie pozostałe pola we wpisie w pliku
        <em>/etc/shadow</em> za pomocą powyższych poleceń.
      </p>
<pre class="code-block">
#chage:
[root@server1 ~]# chage -m 7 -M 28 -W 5 -I 7 -E 2022-12-31 user3000
[root@server1 ~]# chage -l user3000
Last password change					: Jun 28, 2022
Password expires					: Jul 26, 2022
Password inactive					: Aug 02, 2022
Account expires						: Dec 31, 2022
Minimum number of days between password change		: 7
Maximum number of days between password change		: 28
Number of days of warning before password expires	: 5
[root@server1 ~]# grep 'user3000' /etc/shadow
user3000:$6$AjNe9ajpYrZ1Sjld$NN36zAMKPlnJElCvuUX1UM0fc6Ymc5pLY4medoHRMCWJhnsoiuKSpjbo7uwTZVkVlv.swqQJ5Dxoa2QZyjsXO.:19171:7:28:5:7:19357:

#passwd:
[root@server1 ~]# passwd -n 5 -x 28 -w 5 -i 7 user4000
Adjusting aging data for user user4000.
passwd: Success
[root@server1 ~]# passwd -S user4000 
user4000 PS 2022-06-28 5 28 5 7 (Password set, SHA512 crypt.)
[root@server1 ~]# grep 'user4000' /etc/shadow
user4000:$6$29yZ7yqj2lWdSoQE$AMp2ZXAqxa.wWMA88dINDdogjych/Yshnip1whwaqymLTS4ALW9UGx9406tZmsghOTXptBIFrq4UvDF/.sl2f0:19171:5:28:5:7::
</pre>
      <p>
        Za pomocą polecenia <em>passwd</em>, nie możemy dodać daty wygaśnięcia
        konta. Jednak to polecenie wraz z poleceniem, które znamy z
        poprzednie rozdziału <em>usermod</em>, może blokować i odblokowywać
        konta. Zablokujemy i odblokumjemy oba wcześniej wykorzystwane konta.
      </p>
      <p>
        Blokowanie kont za pomocą polecenia <em>passwd</em>:
      </p>
<pre class="code-block">
[root@server1 ~]# passwd -l user3000
Locking password for user user3000.
passwd: Success
[root@server1 ~]# grep 'user3000' /etc/shadow
user3000:!!$6$AjNe9ajpYrZ1Sjld$NN36zAMKPlnJElCvuUX1UM0fc6Ymc5pLY4medoHRMCWJhnsoiuKSpjbo7uwTZVkVlv.swqQJ5Dxoa2QZyjsXO.:19171:7:28:5:7:19357:
[root@server1 ~]# passwd -u user3000
Unlocking password for user user3000.
passwd: Success
[root@server1 ~]# grep 'user3000' /etc/shadow
user3000:$6$AjNe9ajpYrZ1Sjld$NN36zAMKPlnJElCvuUX1UM0fc6Ymc5pLY4medoHRMCWJhnsoiuKSpjbo7uwTZVkVlv.swqQJ5Dxoa2QZyjsXO.:19171:7:28:5:7:19357:
</pre>
      <p>
        Jak możemy zauważyć po zablokowaniu konta przed przesłonionym hasłem
        zostały umieszczone dwa wykrzykniki, które po odblokowaniu konta
        zostały usunięte. Poniżej znajdują się te same czynności wykonane
        przy użyciu polecenia <em>usermod</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# usermod -L user4000
[root@server1 ~]# grep 'user4000' /etc/shadow
user4000:!$6$29yZ7yqj2lWdSoQE$AMp2ZXAqxa.wWMA88dINDdogjych/Yshnip1whwaqymLTS4ALW9UGx9406tZmsghOTXptBIFrq4UvDF/.sl2f0:19171:5:28:5:7::
[root@server1 ~]# usermod -U user4000
[root@server1 ~]# grep 'user4000' /etc/shadow
user4000:$6$29yZ7yqj2lWdSoQE$AMp2ZXAqxa.wWMA88dINDdogjych/Yshnip1whwaqymLTS4ALW9UGx9406tZmsghOTXptBIFrq4UvDF/.sl2f0:19171:5:28:5:7::
</pre>
      <p>
        W przypadku polecenia <em>usermod</em>, umieszczony został tylko jeden
        wykrzyknik przed hasłem, jednak nie ważne czy został umieszczony jeden
        czy dwa, wykrzyknik przed przesłonionym hasłem oznacza, że konto jest
        zablokowane.
      </p>
      <h2 id="6.2.groupmanaging">6.2. Zarządzanie grupami</h2>
      <p>
        Podobnie tak jak w przypadku użytkowników, w poprzednim rozdziale 
        tak i grupami możemy zarządać w podobny sposób. Możemy je dodwać z
        dostoswanymi do potrzeb informacjami, zmieniać ich informacje oraz
        usuwać. 
      </p>
      <h3 id="6.2.1.groupadd">6.2.1. Tworzenie nowych grup</h3>
      <p>
        Do tworzenia nowych grup służy polecenie <strong>groupadd</strong>,
        które do utworzenia grupy z domyślnymi wartościami wymaga jedynie jej
        nazwy. Poniżej znajdują się najważniejsze opcje tego polecenia:
      </p>
      <ul>
        <li><strong>-g</strong>, pozwala na podanie własnego identyfikatora
          grupy <em>GID</em>, identyfikator powinien być unikatowy, chyba że
          podano opcję <em>-o</em>.</li>
        <li><strong>-o</strong>, pozwala na współdzielenie identyfikatora z
          inną groupą.</li>
        <li><strong>-r</strong>, tworzy grupę systemową z identyfikatorem w
          zakresie podanym w pliku <em>/etc/login.defs</em>, przeważnie 
          między 201 a 999.</li>
        <li><strong>-U</strong>, pozwala podać listę użytkowników, którzy będą
          należeć do grupy, nazwy użytkowników są oddzielone od siebie
          przecinkiem.</li>
      </ul>
<pre class="code-block">
[root@server1 ~]# groupadd -g 9999 sgrp
[root@server1 ~]# grep 'sgrp' /etc/group
sgrp:x:9999:
</pre>
      <p>
        Na powyższym przykładzie utworzyłem grupę z niestandardowym 
        identyfikatorem, następnie wyświetliłem jej wpis w pliku 
        <em>/etc/group</em>.
      </p>
      <h3 id="6.2.2.groupmod">6.2.2. Zmiana informacji grupy</h3>
      <p>
        Polecenie <strong>groupmod</strong>, posiada takie samo zastosowanie
        dla grup, jak polecenie <em>usermod</em> dla użytkowników. Część opcji
        <em>groupmod</em> odpowiada opcjom z polecenia <em>groupadd</em>.
        Na wyszczególnienie zasługuje opcja <strong>-n</strong>, która pozwala
        na zmianę nazwy grupy.
      </p>
<pre class="code-block">
[root@server1 ~]# groupmod -g 8888 -n sysadm sgrp
[root@server1 ~]# grep 'sgrp' /etc/group
[root@server1 ~]# grep 'sysadm' /etc/group
sysadm:x:8888:
</pre>
      <p>
        Jak możemy zobaczyć na przykładzie grupie 
        <code class="code-inline">sgrp</code> został zmieniony identyfikator
        oraz nazwa. Teraz ta grupa widnieje pod <em>GID</em>-em
        <code class="code-inline">8888</code> oraz pod nazwą
        <code class="code-inline">sysadm</code>.
      </p>
      <h3 id="6.2.3.groupdel">6.2.3. Usuwanie grup</h3>
      <p>
        Jeśli grupa nie jest już potrzebna w systemie możemy ją usunąć. Do
        usuwania grup służy polecenie <strong>groupdel</strong>. Polecenie jest
        bardzo proste w użyciu, jedyny wymagany argument to nazwa grupy.
      </p>
<pre class="code-block">
[root@server1 ~]# groupdel sysadm
[root@server1 ~]# grep 'sysadm' /etc/group
</pre>
      <p>
        Grupa została usunięta. Polecenie <code class="code-inline">grep</code>
        nie mogło odnaleźć wzorca <code class="code-inline">sysadm</code> w
        pliku <em>/etc/group</em>.
      </p>
      <h2 id="6.3.suandsudo">6.3. Przełączanie użytkowników oraz uruchamianie
        poleceń jako superużytkownik</h2>
      <p>
        Wykonywanie zadań administracyjnych najczęściej będzie wymagać
        podniesienia uprawnień do poziomu superużytkownika - <em>root</em>.
        Do tej pory wszystkie polecenia w tym materiale wykonywałem z poziomu
        konta <em>root</em> (wyjątkowowo kilka poleceń zostało wykonanych jako
        zwykły użytkownik), więc aby wykonywać zadania administracyjne
        należy się zalogować jak superużytkownik. Logowanie bezpośrednie na to
        konto nie jest dobrą praktyką. A do dyspozycji mamy dwa rozwiązania.
        Pierwszym z nich jest przełączenie użytkownika. 
      </p>
      <h3 id="6.3.1.su">6.3.1. Przełącznie użytkownika</h3>
      <p>
        Pierwszą z metod jest zalogwanie się na nasze konto (konto dostępowe,
        zwykły użytkownik), a następnie przełącznie się na konto <em>root</em>
        za pomocą polecenia <strong>su</strong>. To polecenie pozwala na
        przełączenie się na dowolne konto, jeśli jak pierwszy argument podamy
        myślnik (<strong>-</strong>) przed nazwą użytkownika podczas
        przełączania zostaną uruchomione skrypty startowe, które stworzą nam
        środowisko jak najbardziej zbliżone do bezpośredniego logowania.
      </p>
<pre class="code-block">
[user@server1 ~]$ su - root
Password: 
[root@server1 ~]# 
</pre>
      <p>
        Za pomocą tego polecenia możemy przełączyć się na dowolne konto, jeśli
        zwykli użytkownicy przełączają się między kontami wymagane będzie
        podanie hasła dla docelowego konta, wyjątkiem tutaj jest
        superużytkownik, który nie musi podawać żadnych haseł.
      </p>
      <p>
        Aby korzystać z tej metody nie trzeba nawet otwierać sesji powłoki jako
        przełączony użytkownik, możemy po prostu wykonać polecenie jako on za
        pomocą opcji <em>-c</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ su root -c 'vgs'
Password: 
  VG   #PV #LV #SN Attr   VSize   VFree
  rhel   1   2   0 wz--n- &lt;19.00g    0 
</pre>
      <p>
        Korzystanie z polecenia <em>su</em>, nie jest zbyt elastycznym
        rozwiązaniem, daje pełen dostęp do superużytkownika gdzie nie jest to
        konieczne. Ten rodzaj podniesienia uprawnień w systemie używany jest
        przez kilka dystrybucji w jednym celu aby pobrać i skonfigurować 
        to drugie rozwiązanie.
      </p>
      <h3 id="6.3.2.sudo">6.3.2. Polecenie sudo</h3>
      <p>
        Użycie polecenia <strong>sudo</strong> jest znacznie lepszym
        rozwiązaniem. Głównym argumentem jest fakt, iż możemy skonfigurować
        to polecenie w taki sposób, aby dać użytkownikom dostęp tylko do
        tych poleceń których naprawdę potrzebują. Jednak na początku zajmiemy 
        się prostszą konfiguracją, czyli stworzeniem lokalnego administratora,
        którego konto dalej będzie zwykłym użytkownikiem. 
      </p>
      <p>
        Do konfiguracji tego narzędzia służy plik <em>/etc/sudoers</em> oraz
        katalog <em>/etc/sudoers.d</em>, w którym wystarczy umieścić plik z
        konfiguracją. Plik <em>/etc/sudoers</em>, możemy edytować dowolnym
        edytorem, jednak pakiet <em>sudo</em> posiada specjalne polecenie
        <strong>visudo</strong>, które stworzy kopie tymczasową pliku, której
        będziemy dokonywać zmian (polecenie samoczynnie uruchomi edytor), 
        następnie polecenie nadpisze oryginalny plik i usunie plik tymczasowy. 
        Najprostszą konfiguracją jaką możemy
        wykonać jest nadanie zwykłemu użytkownikowi uprawnień do wszystkich
        funkcji administracyjnych. Zmian możemy dokonać w dowolnym miejscu w 
        pliku, jednak nalepiej
        znaleźć odpowiednie do tego miejsce. Możemy je namierzyć wyszukując
        linię <code class="code-inline">root ALL=(ALL)  ALL</code>, skopiować 
        ją, wkleić pod nią i zmienić tylko nazwę użytkownika na początku linii:
      </p>
<pre class="code-block">
user ALL=(ALL)  ALL
</pre>
      <p>
        Ten wpis zapewni użytkownikowi <code class="code-inline">user</code>
        dostęp do wszystkich funkcji administracyjnych w systemie. Oprócz
        użytkownikom, dostęp do wszystkich lub określonych funkcji możemy nadać
        grupie. Kiedy zajdzie taka potrzeba wystarczy dopisać użytkownika do
        grupy i nie trzeba już edytować pliku. Konfiguracja grupy różni się od
        konfiguracji użytkownika tym, że nazwę grupy poprzedza się znakiem
        procentu (<strong>%</strong>)
      </p>
<pre class="code-block">
%sysadms ALL=(ALL)  ALL
</pre>
      <p>
        We wpisach konfiguracyjnych znajdują się aż trzy słowa 
        <code class="code-block">ALL</code>, każde z nich ma oddzielne
        znacznie. Pierwsze słowo <em>ALL</em> po nazwie użytkownika oznacza
        nazwę komputera (lub adres IP), ponieważ plik <em>/etc/sudoers</em> 
        może być współdzielony między innymi komputerami, jednak ten plik 
        będzię dotyczyć tylko tego systemu dlatego też może pozostać 
        <em>ALL</em>. Drugie słowo <em>ALL</em> w nawiasie oznacza jako kto
        będzie wykonywać te polecenie, ta lista pozwala wybrać
        użytkownika (po zastosowaniu opcji <em>-u</em>) do wykonania polecenia.
        W nie których systemach możemy spotkać się z zapisem 
        <em>(ALL:ALL)</em>, zapis <em>ALL</em> po dwukropku oznacza listę grup.
        Grupę możemy wybrać z pomocą opcji <em>-g</em>. Ostanie <em>ALL</em>
        jest listą programów do których użytkownik poprzedzający polecenie
        narzędziem <em>sudo</em> będzie mieć dostęp. Poniżej przykładowe użycie
        polecenia <em>sudo</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ sudo vgs
[sudo] password for user: 
  VG   #PV #LV #SN Attr   VSize   VFree
  rhel   1   2   0 wz--n- &lt;19.00g    0
</pre>
      <p>
        Podczas uruchamia programu <code class="code-inline">vgs</code>, 
        <em>sudo</em>, po prosiło o hasło - hasło użytkownika, który wydaje 
        to polecenie.
        Narzędzie <em>sudo</em> możemy skonfigurować w taki sposób aby nie
        wymagało hasła podczas uruchamiania programu. We wcześniejszej 
        dyrektywie, konfigurującej użytkownika przed ostatnim słowem <em>ALL</em>
        dopisujemy <em>NOPASSWD:</em>.
      </p>
<pre class="code-block">
user ALL=(ALL)  NOPASSWD:ALL
</pre>
      <p>
        Najczęściej naszym zadaniem związanym z poleceniem <em>sudo</em> będzie
        przypisanie konkretnym użytkownikom dostępu do określonych poleceń.
        Jeśli do skonfigrowania mamy wiele takich elementów za równo poleceń
        jak i użytkowników, to aby zrobić to jak najefektywniej należy użyć
        aliasów. <em>Sudo</em> swojej konfiguracji wyróżnia aliasy przeznaczone
        dla użytkowników jak i dla poleceń. Alias z listą użytkowników tworzymy
        tak jak na przykładzie:
      </p>
<pre class="code-block">
User_Alias  PKGADM = user1, user100, user200
</pre>
      <p>
        Po słowie <code class="code-inline">User_Alias</code> zapisujemy nazwę
        aliasu, w tym przypadku jest <code class="code-inline">PKG_ADM</code>
        po znaku równości (<strong>=</strong>) podajemy listę użytkowników
        tak jak na przykładzie powyżej. Ze zbiorem poleceń jest podobnie ale
        zmienia się dyrektywa inicjująca alias.
      </p>
<pre class="code-block">
Cmnd_Alias PKGCMD = /usr/bin/yum, /usr/bin/rpm
</pre>
      <p>
        Po zdefiniowaniu obu aliasów, możemy przejść do przypisnia aliasowi
        <code class="code-inline">PKGADM</code> (określonym użytkownikom) 
        dostępu do poleceń zapisanych w 
        <code class="code-inline">PKGCMD</code>.
      </p>
<pre class="code-block">
PKGADM ALL = PKGCMD
</pre>
      <p>
        Teraz użytkownicy zdefiniowani w aliasie 
        <code class="code-inline">PKGADM</code> będą mogli użyć tylko i 
        wyłącznie poleceń zdefiniowanych w <code class="code-inline">PKGCMD</code>
      </p>
      <p>
        Podczas pracy będziemy zazwyczaj definiować aliasy użytkowników,
        ponieważ jeśli rozejrzymy się po pliku <em>/etc/sudoers</em>, definicje
        aliasów z pogrupowanymi poleceniami są już zapisane w komentarzach
        wystarczy usunąć znak komentarza oraz przypisać ten alias określonej
        grupie użytkowników.
      </p>
      <p>
        Użycie polecenia <em>sudo</em> jest rejestrowane. Wpisy zapisywane są
        do pliku <em>/var/log/secure</em> ich odczyt wymaga uprawnień
        superużytkownika. We wpisach znajduje się nazwa użytkownika, który
        wywołał to polecenie jak i samo polecenie.
      </p>
      <p>
        Więcej informacji na temat tego narzędzia znajduje się na stronie
        podręcznika samego polecenia jak i pliku <em>/etc/sudoers</em>. Jak
        ćwiczenie, nadajmy uprawnienia do pełnych funkcji administracyjnych
        zwykłemu użytkownikowi, którego tworzyliśmy podczas instalacji
        systemu na maszynie. Od tego momentu na wszystkich przykładach będę
        używać tego konta, a uprawnienia administracyjne będę wymuszać za 
        pomocą polecenia <em>sudo</em>.
      </p>
      <h2 id="6.4.chownchgrp">6.4. Zmiana praw własności plików i katalogów</h2>
      <p>
        Polecenie <strong>chown</strong>, omówiliśmy sobie podczas omawiania
        uprawnień plików. Polecenie to służy do zmiany właściciela oraz
        ewentualnie grupy, do której należy element. 
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l file1 
-rw-r--r--. 1 user user 0 Jun 26 15:30 file1
[user@server1 ~]$ sudo chown user100 file1
[sudo] password for user: 
[user@server1 ~]$ ls -l file1
-rw-r--r--. 1 user100 user 0 Jun 26 15:30 file1
</pre>
      <p>
        Jednak w systemie istnieje inne polecenie, dzięki któremu możemy
        zmienić grupę. Jest nim <strong>chgrp</strong>. Składania 
        polecenia identyczna do składni <em>chown</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ sudo chgrp user100 file1
[sudo] password for user: 
[user@server1 ~]$ ls -l file1 
-rw-r--r--. 1 user100 user100 0 Jun 26 15:30 file1
[user@server1 ~]$ 
</pre>
      <p>
        Jak możemy zauważyć grupa, do której należy plik została zmieniona
        w porównaniu do szczegółów z porzedniego przykładu.
      </p>
      <p>
        Polecenia <em>chown</em> możemy również używać rekurencyjnie, aby
        zmieniać prawa własności całych struktur katalogowych wraz z plikami.
        Tej czynności służy opcja <em>-R</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ sudo chown -R root:root /tmp/etc
</pre>
      <p>
        Na powyższym przykładzie zmieniłem właściciela oraz grupę do wszystkim 
        elementom w katalogu <code class="code-inline">/tmp/etc</code>.
      </p>
      <h3 id="exec6.1">Ćwiczenie 1: Utwórz użytkowników oraz skonfiguruj
        zasady haseł</h3>
      <p>
        Na maszynie <em>server1</em> utwórz grupę <em>lnxgrp</em> o numerze
        <em>GID</em> 6000. Utwórz użytkownika <em>user5000</em> o numerze
        <em>UID</em> 5000 oraz numerze <em>GID</em> 6000. Przypisz mu hasło, a
        następnie ustaw minimum 4 dni do następnej zmiany hasła, ważność hasła
        na 30 dni oraz okres ostrzegania na 10 dni. Konto tego użytkownika
        powinno wygasnąć 20 grudnia 2022 roku.
      </p>
      <h3 id="exec6.2">Ćwiczenie 2: Zablokuj i odblokuj użytkownika</h3>
      <p>
        Na maszynie <em>server1</em> zablokuj użytkownika <em>user5000</em> za
        pomocą polecenia <em>passwd</em>. Sprawdź jak zmienił się jego wpis w 
        pliku <em>/etc/shadow</em>. Spróbuj się zalogować na użytkownika.
        Odblokuj go za pomocą polecenia
        <em>usermod</em> zweryfikuj jego odblokowanie na podstawie wpisu z 
        pliku powyżej.
      </p>
      <h3 id="exec6.3">Ćwiczenie 3: Zmień dane grupy</h3>
      <p>
        Na maszynie <em>server1</em> zmień <em>GID</em> grupy <em>lnxgrp</em> 
        z 6000 na 7000, dodaj do niej użytkowników user1000 oraz user2000
        (jeśli nie istnieją utwórz ich), na koniec zmień nazwę grupy na 
        <em>dbagrp</em> i zweryfikuj zmiany.
      </p>
      <h3 id="exec6.4">Ćwiczenie 4: Konfiguracja dostępu do sudo</h3>
      <p>
        Na maszynie <em>server1</em>, skonfiguruj polecenie <em>sudo</em> dla
        użytkownika <em>user5000</em>, tak aby miał dostęp do wszystkich
        funkcji administracyjnych bez podawania hasła. W celu sprawdzenia
        wydaj polecenie <em>sudo vgs</em>.
      </p>
      <h3 id="exec6.4">Ćwiczenie 5: Zmiana praw własności do plików i katalogów</h3>
      <p>
        Na maszynie <em>server1</em>, utwórz w katalogu <em>/tmp</em> plik
        <em>f6</em> oraz katalog <em>d6</em>. Utwórz użytkownika <em>user90</em>.
        Za pomocą polecenia <em>chown</em> ustaw właściciela pliku <em>f6</em>
        na <em>user90</em>. Za pomocą polecenia <em>chgrp</em> ustaw grupę na 
        <em>dbagrp</em>. Utwórz grupę <em>g1</em>,
        następnie ustaw rekrencyjnie prawa własności dla katalogu <em>d6</em>,
        na <em>user90</em>:<em>g1</em>.
      </p>
      <h2 id="ch5summary">Podsumowanie</h2>
      <p>
        Tym rodziałem zakończyliśmy zarządzanie użytkownikami. Zapoznaliśmy
        się z narzędziami do ustalania zasad haseł w praktyce, poznaliśmy
        narzędzia do zarządzania grupami oraz efektywne sposoby na bezpieczne
        podnoszenie uprawnień za pomocą polecenia <em>sudo</em>. Na koniec 
        odświerzyliśmy informacje na temat praw własności plików i katalogów.
        W następnym rodziale poznamy podstawy powłoki BASH.
      </p>
      <h1 id="7.bashshell">7. Powłoka BASH</h1>
      <p>
        Powłoka jest to program odpowiedzialny za możliwość wprowadzania 
        poleceń
        do systemu i ich interpretowanie. Powłoka jest domyślnym interfejsem
        użytkownika w różnych wariantach systemów uniksopodobnych. To właśnie 
        proces połoki jest uruchamiany po uruchomieniu okna terminala. 
      </p>
      <p>
        Na przestrzeni lat wraz z kolenymi odłamami oryginalnego Uniksa
        powstawało wiele powłok, każda z nich miała swoje wady i zalety.
        Obecnie najpowszechniejszą wersją z nich jest <strong>BASH</strong>,
        jej główną zaletą jest zebranie większości funkcjonalność różnych
        powłok, poprawienie ich działa oraz dostosowanie do obecnych czasów.
        Ten rodzaj powłoki również domyślnie jest instalowany w wielu
        dystrybucjach Linuksa i Red Hat nie jest w tym temacie wyjątkiem.
        W tym rodziale chciałbym omówić najważnejsze funkcje tej powłoki oraz
        jej skrypty startowe, dzięki którym będziemy mogli dostować ją do
        swoich potrzeb.
      </p>
      <h2 id="7.1.bashfeatures">7.1. Funkcje powłoki BASH</h2>
      <p>
        <em>BASH</em> w swojej kolekcji posiada masę funkcjonalności, których
        próżno szukać w innych powłokach. Dla przykładu w nowszych
        dystrybucjach, skrypt powłoki zastępują podstawowe narzędzia systemowe,
        będące kiedyś pełnoprawnymi programami.
      </p>
      <h3 id="7.1.1.variables">7.1.1. Zmienne</h3>
      <p>
        Korzystając z powłoki możemy używać zmiennych, czyli opisanych miesc
        alokowanych w pamięci do przechowywania dowolnych wartości. Do
        dyspozycji mamy dwa rodzaje zmiennych - zmienne <strong>lokalne</strong>
        oraz zmienne <strong>środowiskowe</strong>.
      </p>
      <p>
        Zmienne lokalne są do naszej dyspozycji w obecnej sesji powłoki.
        Tego typu zmienne nie są dostępne dla
        uruchomionych w tej sesji skryptów czy programów, gdyż są
        przechowywane tylko i wyłącznie w obszarze pamięci należącym do tego
        procesu powłoki. Taka zmienną możemy zdefiniować podając w wierszu
        polecenia jej nazwę, następnie znak równości oraz wartość. Warto dodać
        aby nie było między tymi elementami żadnej spacji. Poniższy przykład 
        na pewno to rozświetli.
      </p>
<pre class="code-block">
[user@server1 ~]$ zmienna=2137
</pre>
      <p>
        Po wykonaniu takiego polecenia, powłoka utworzy zmienną i nada jej
        podaną wartość, po czym zwróci znak zachęty.
      </p>
      <p>
        Do takiej zmiennej możemy odwołać się podczas pisania polecenia
        wystarczy poprzedzić nazwę znakiem dolara (<strong>$</strong>).
      </p>
<pre class="code-block">
[user@server1 ~]$ echo $zmienna
2137
</pre>
      <p>
        Polecenie <code class="code-inline">echo</code> wypisuje wszystko co
        do zostanie mu podane jako argument na standardowe wyjście (o tym
        będzie w dalszej częsci materiału). Jak widzimy polecenie wypisało
        również zawartość zmiennej.
      </p>
      <p>
        Innego rodzaju zmiennymi są zmienne środowiskowe przechowują one
        różnego rodzaju wartość, które mogą wpływać na działanie programów.
        Każdy program uruchomiony na Linuksie dostaje obszar
        pamięci zmiennych środowiskowych i może z nich korzystać. Definicja
        takich zmiennych, różni się tym iż wykorzystuje się do tego celu
        polecenie <strong>export</strong>, które zadaniem jest przeniesienie
        zmiennej lokalnej do pamięci zmiennych środowiskowych. Jako argument
        polecenia podajemy definicję zmiennej.
      </p>
<pre class="code-block">
[user@server1 ~]$ export ZMIENNA=2137
</pre>
      <p>
        Nazwy zmiennych środowiskowych zapisujemy za pomocą wielkich liter aby
        odróżnić je od zmiennych lokalnych. Działanie takiej zmiennej
        zobaczymy, kiedy uruchomimy jakiś program w tej powłoce, aby otrzymał
        on od połoki, w której został uruchomiony (procesu nadrzędnego) obszar 
        zmiennych środowiskowych. Najlepiej by było aby takim programem była 
        kolejna połowka (podpowłoka).
      </p>
<pre class="code-block">
[user@server1 ~]$ bash
[user@server1 ~]$ echo $ZMIENNA
2137
</pre>
      <p>
        Po uruchomieniu podpowłoki wydałem polecenie, które wyświetliło mi
        zawartość zmiennej, którą zdefiniowałem jako zmienną środowiskową w
        poprzednim przykładzie.
      </p>
      <p>
        Wszystkie zmienne środowiskowe systemie możemy wypisać za pomocą
        polecenia <strong>env</strong> lub polecenia <strong>printenv</strong>.
        Oto fragment listingu zmiennych środowiskowych z mojego systemu:
      </p>
<pre class="code-block">
[user@server1 ~]$ env
...
TERM=xterm-256color
LESSOPEN=||/usr/bin/lesspipe.sh %s
USER=user
SELINUX_USE_CURRENT_RANGE=
ZMIENNA=2137
SHLVL=2
XDG_SESSION_ID=7
XDG_RUNTIME_DIR=/run/user/1000
SSH_CLIENT=192.168.122.1 34956 22
which_declare=declare -f
...
</pre>
      <p>
        Natomiast za pomocą polecenia <strong>set</strong> możemy wypisać
        wszystkie zmienne dostępne w systemie, łącznie z lokalnymi zmiennymi
        powłoki.
      </p>
<pre class="code-block">
[user@server1 ~]$ set
...
SHLVL=1
SSH_TTY=/dev/pts/0
TERM=xterm-256color
UID=1000
USER=user
XDG_DATA_DIRS=/home/user/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
XDG_RUNTIME_DIR=/run/user/1000
XDG_SESSION_CLASS=user
XDG_SESSION_ID=7
XDG_SESSION_TYPE=tty
ZMIENNA=2137
_=set
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
colors=/home/user/.dircolors
new_dirs=/home/user/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share
which_opt=-f
which_shell=bash
zmienna=2137
zmienna1=2137
...
</pre>
      <p>
        Zmienne, które nie są już potrzebne możemy usunąć za pomocą polecenia
        <strong>unset</strong>. 
      </p>
<pre class="code-block">
[user@server1 ~]$ set | grep 'zmienna1'
zmienna1=2137
[user@server1 ~]$ unset zmienna1
[user@server1 ~]$ echo $zmienna1

</pre>
      <p>
        Przy odwołaniu się do zmiennej, polecenie <em>echo</em> zwróciło
        pusty wiersz.
      </p>
      <p>
        Manipulując zmiennymi w powłoce może zmienić znak zachęty, ponieważ 
        jego definicja jest przechowywana w zmiennej <strong>PS1</strong>:
      </p>
<pre class="code-block">
[user@server1 ~]$ echo $PS1
[\u@\h \W]\$
</pre>
      <p>
        Te poprzedzone lewym ukośnikiem <strong>\</strong> litery są kolejnymi
        elementami znaku zachęty. Opis tych elementów znajduje się na 
        stronie podręcznika polecenia/powłoki <em>BASH</em> w rozdziale
        <em>PROMPTING</em>.
      </p>
      <h3 id="7.1.2.commandsubstitution">7.1.2. Podstawienie polecenia</h3>
      <p>
        Często wykorzystywaną funkcją wraz z zmiennymi jest
        <strong>podstawienie polecenia</strong>. Polega ono na uruchomieniu,
        przez podpowłokę polecenia ujętego albo w okrągły nawias poprzedzony
        znakiem dolara (<strong>$()</strong>) albo w ukośny cudzysłów
        (<strong>``</strong>). Informacja zwracana przez polecenie trafia albo
        do zmiennej albo bezpośrednio jak argument polecenia.
      </p>
<pre class="code-block">
[user@server1 ~]$ export KERNEL_VERSION=$(uname -r)
[user@server1 ~]$ echo $KERNEL_VERSION 
5.14.0-70.13.1.el9_0.x86_64
</pre>
      <p>
        Poniżej znajduje się przykład użycia podstawienia polecenia w innym
        poleceniu:
      </p>
<pre class="code-block">
[user@server1 ~]$ sudo find / -name *`uname -r` -print 2&gt; /dev/null
/boot/vmlinuz-5.14.0-70.13.1.el9_0.x86_64
/boot/System.map-5.14.0-70.13.1.el9_0.x86_64
/boot/config-5.14.0-70.13.1.el9_0.x86_64
/usr/lib/firmware/5.14.0-70.13.1.el9_0.x86_64
/usr/lib/modules/5.14.0-70.13.1.el9_0.x86_64
/usr/share/doc/kernel-keys/5.14.0-70.13.1.el9_0.x86_64
</pre>
      <p>
        Gwiazdka w tym przypadku oraz <code class="code-inline">2&gt;</code>,
        również są elementami połoki, które sobie omówimy.
      </p>
      <h3 id="7.1.3.streamredirections">7.1.3. Przekierowanie strumieni</h3>
      <p>
        Na Uniksach mamy doczynienia z trzema rodzajami strumieni danych,
        owe strumienie łączą ze sobą np. urządzenia z programami, dlatego
        pisząc na klawiaturze możemy wprowadzać tekst do programu, albo 
        programy
        mogą wypisać wynik swojego działnia do okna terminala. Pierszy strumień
        to strumień standardowegp wejścia źródłem jego danych jest najczęściej 
        klawiatura.
        Jego identyfikatorem jest <strong>0</strong> (programy używają
        identyfikatorów do korzystania ze strumieni, my też będziemy podłaczając
        jeden strumień do drugiego). Drugi strumień danych, to strumień
        standarowego wyjścia źródłem jego danych jest najczęściej program 
        (jądro podczas
        uruchamiania programu przekazuje mu kopie strumieni), jego
        identyfikatorem jest <strong>1</strong>, a podłączony jest on do
        terminala. Ostatnim strumieniem jest strumień błędów jego źródłem 
        danych są komunikaty diagnostyczne programów, jest on najczęciej
        podłączony razem ze strumieniem wyjścia do terminala. Identyfikatorem 
        strumienia błędów jest <strong>2</strong>.
      </p>
      <p>
        Przekierowania strumienia standardowego wyjścia dokonujemy w wierszu 
        polecenia poprzez 
        podanie znaku większości (<strong>&gt;</strong>) a następnie podajemy
        miejse docelowe na dane. Na przykład wynik listowania katalogu
        <em>/etc</em> możemy umieścić w pliku.
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /etc &gt; ls.out
[user@server1 ~]$ head -5 ls.out 
total 1320
drwxr-xr-x.  3 root root        28 Jun 26 13:50 accountsservice
-rw-r--r--.  1 root root        16 Jun 26 14:01 adjtime
-rw-r--r--.  1 root root      1529 Jun 23  2020 aliases
drwxr-xr-x.  3 root root        65 Jun 26 13:54 alsa
</pre>
      <p>
        Użycie pojedyńczego znaku większości przekieruje strumień w tym
        przypadku do pliku oraz nadpisze informacje zawarte w nim. Jeśli plik
        nie istnieje to zostanie on utworzony.
      </p>
      <p>
        Nadpisywanie danych za pomocą przekierowania strumieni nazywane jest
        <em>clobberingiem</em>. Możemy zablokować tę funkcję za pomocą
        polecenia <code class="code-inline">set -o noclobber</code>, wówczas
        gdy plik będzie istnieć pokaże nam się taki komunikat jak na poniższym
        przykładzie.
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /etc &gt; ls.out
-bash: ls.out: cannot overwrite existing file
</pre>
      <p>
        Funkcję można włączyć z powrotem za pomocą polecenia
        <code class="code-inline">set +o noclobber</code>.
      </p>
      <p>
        Chcąc dopisać do zawartości pliku, zawartość strumienia możemy użyć
        podwójnego znaku większości. Na przykład:
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /var &gt;&gt; ls.out
[user@server1 ~]$ cat ls.out
total 4
drwxr-xr-x. 2 user4000 g1         6 Jun 26 16:06 d6
srwxrwxrwx. 1 gdm      gdm        0 Jun 30 13:59 dbus-aIxoyUxXnM
srwxrwxrwx. 1 gdm      gdm        0 Jun 30 09:38 dbus-JRmt27fCi0
drwxr-xr-x. 2 user200  dba        6 Jun 26 15:33 dir10
-rw-r--r--. 1 user4000 dba        0 Jun 26 16:06 f6
-rw-r--r--. 1 user200  user100    0 Jun 26 15:33 file10
-rw-r--r--. 1 user     user    2400 Jun 30 14:57 ioerror
...
total 16
drwxr-xr-x.  2 root root   19 Jun 26 13:54 account
drwxr-xr-x.  2 root root    6 Aug 10  2021 adm
drwxr-xr-x. 18 root root 4096 Jun 26 14:12 cache
drwxr-xr-x.  2 root root    6 Mar  7 04:37 crash
drwxr-xr-x.  3 root root   18 Jun 26 13:50 db
drwxr-xr-x.  2 root root    6 Aug 10  2021 empty
...
</pre>
      <p>
        Z racji tego iż znak większości służy do przekierowania jedynie wyjścia
        to aby przekierować strumień błedów, należy podać przez znakiem jego
        identyfikator. 
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /dvd 2&gt; err.out
[user@server1 ~]$ cat err.out 
ls: cannot access '/dvd': No such file or directory
</pre>
      <p>
        Czasami może się zdarzyć, iż będzie potrzeba przekierowania obu tych
        strumieni, wówczas trzeba skorzystać z podłączenia jednego strumienia
        do drugiego.
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /tmp /sdir &gt; ls2.out 2&gt;&amp;1
[user@server1 ~]$ cat ls2.out 
ls: cannot access '/sdir': No such file or directory
/tmp:
total 4
drwxr-xr-x. 2 user4000 g1         6 Jun 26 16:06 d6
srwxrwxrwx. 1 gdm      gdm        0 Jun 30 13:59 dbus-aIxoyUxXnM
srwxrwxrwx. 1 gdm      gdm        0 Jun 30 09:38 dbus-JRmt27fCi0
drwxr-xr-x. 2 user200  dba        6 Jun 26 15:33 dir10
-rw-r--r--. 1 user4000 dba        0 Jun 26 16:06 f6
-rw-r--r--. 1 user200  user100    0 Jun 26 15:33 file10
-rw-r--r--. 1 user     user    2400 Jun 30 14:57 ioerror
...
</pre>
      <p>
        To polecenie można zapisać również w inny sposób. Na przykład:
        <code class="code-inline">ls -l /tmp /sdir &amp;&gt; ls2.out</code>.
        Obie formy są poprawne i obie robią to samo, która będzie dla nas
        lepsza musimy zdecydować sami.
      </p>
      <p class="exam_tip">
        Jednym z zadań egzaminacyjnych może być wykonanie polecenia z 
        przekierowaniem wyjścia lub/i strumienia błędów do pliku.
      </p>
      <p>
        Kolejnym rodzajem przekierowania jest przekierowanie wejścia, jednak 
        jest ono dość rzadko stosowane. Do tego rodzaju przekierowania 
        stosuje się znak mniejszości (<strong>&lt;</strong>). Jednym z
        przykładów jest polecenie użycie polecenia <em>tar</em>, jednak nie ma
        ono sensu, ponieważ istnieje opcja <em>-f</em>, która pozwala na
        podanie ścieżki do pliku.
      </p>
<pre class="code-block">
[user@server1 ~]$ tar -x -C /tmp &lt; etc.tar 
[user@server1 ~]$ ls -l /tmp
total 16
drwxr-xr-x.   2 user4000 g1         6 Jun 26 16:06 d6
srwxrwxrwx.   1 gdm      gdm        0 Jun 30 13:59 dbus-aIxoyUxXnM
srwxrwxrwx.   1 gdm      gdm        0 Jun 30 09:38 dbus-JRmt27fCi0
drwxr-xr-x.   2 user200  dba        6 Jun 26 15:33 dir10
drwxr-xr-x. 132 user     user    8192 Jun 30 09:38 etc
...
</pre>
      <p>
        Ostatni rodzaj przekierowania, to <strong>potok</strong>, o potoku
        jeszcze będzie w tym rozdziale.
      </p>
      <h3 id="7.1.4.history">7.1.4. Historia poleceń</h3>
      <p>
        Dość istotną funkcją powłoki <em>BASH</em> jest historia poleceń.
        Pozwala ona zaoszczędzić pisania w szczególności długich poleceń czy
        potoków poleceń (ang. <em>pipelines</em>). Posiada ona funkcję
        wyszukiwania oraz swobodny dostęp do poleceń umieszczonych w historii.
      </p>
      <p>
        Aby wyświetlić polecenia z historii, należy użyć polecenia
        <strong>history</strong>, wyświetli ono listę poleceń z numerami na
        początku, każde polecenie to jedna linia. Numer porządkowy pomoże nam
        się odwołać do polecenia podczas jego wywoływania, ponieważ nie
        potrzeba szukać polecenia czy przebierać ich wszystkich za pomocą
        niżej opisanych klawiszy. Wystarczy znać jego numer. Poniżej znajduje
        się fragment listy historii poleceń z mojego systemu:
      </p>
<pre class="code-block">
[user@server1 ~]$ history
    1  id
    2  groups 
    3  su
    4  su -
    5  cat /etc/sudoers
    6  su - root
    7  sudo cat /etc/sudoers
    8  su - root
    9  sudo cat /etc/sudoers
   10  su - root
   11  sudo yum update
   12  su - root
   13  touch file1
...
</pre>
      <p>
        Wyświetlenie listy poleceń w historii możemy ograniczyć podajac w
        jako argument ilość wyświetlanych linii. Polecenie wyświetli wówczas
        polecenia od końca listy (ostatnio dodane).
      </p>
<pre class="code-block">
[user@server1 ~]$ history 10
  266  rm etc.tar 
  267  sudo tar -cvf etc.tar /etc
  268  tar -x -C /tmp &lt; etc.tar 
  269  ls -al /tmp
  270  ls -l /tmp
  271  history
  272  touch file1
  273  sudo poweroff
  274  touch file1
  275  history 10
</pre>
      <p>
        Za pomocą opcji <em>-d</em> możemy usunać wybrane polecenie z historii.
      </p>
<pre class="code-block">
[user@server1 ~]$ history 10
  266  rm etc.tar 
  267  sudo tar -cvf etc.tar /etc
  268  tar -x -C /tmp &lt; etc.tar 
  269  ls -al /tmp
  270  ls -l /tmp
  271  history
  272  touch file1
  273  sudo poweroff
  274  touch file1
  275  history 10
[user@server1 ~]$ history -d 271
[user@server1 ~]$ history 10
  267  sudo tar -cvf etc.tar /etc
  268  tar -x -C /tmp &lt; etc.tar 
  269  ls -al /tmp
  270  ls -l /tmp
  271  touch file1
  272  sudo poweroff
  273  touch file1
  274  history 10
  275  history -d 271
  276  history 10
</pre>
      <p>
        Na informacji zwracanej przez wcześniejsze wywołanie polecenia
        <code class="code-inline">history 10</code> w linii 
        <code class="code-inline">271</code> widnieje polecenie
        <code class="code-inline">history</code>, natomiast na drugim wywołaniu
        po usunięciu tego polecenia pod tym numerem widnieje już inne.
      </p>
      <p>
        Wśród poleceń w historii możemy poruszać się za pomocą strzełek w górę 
        oraz w dół lub kombinacji klawiszy (co jest bardziej zalecene)
        <em>Ctrl+p</em>(poprzednie polecenie) oraz <em>Ctrl+n</em> (następne
         polecenie). Możemy je również wszukiwać za
        przez wciśnięcie kombinacji klawiszy <em>Ctrl+r</em> i podanie 
        fragmentu polecenia. Czasmi wyszukiwanie może nie przynieść skutku,
        wówczas należy nacisnać <em>Ctrl+c</em> i spróbować ponownie.
      </p>
      <p>
        Do poleceń w historii odnosimy się wprowadzając w wierszu polecenia
        wykrzyknik (<strong>!</strong>) następnie możemy podać numer z listy.
        Dla przykładu użyje polecenia numer <code class="code-inline">13</code>
        z fragmentu listy z pierwszego przykładu.
      </p>
<pre class="code-block">
[user@server1 ~]$ !13
touch file1
touch: cannot touch 'file1': Permission denied
</pre>
      <p>
        Możemy podać litery rozpoczynające polecenie na przykład:
      </p>
<pre class="code-block">
[user@server1 ~]$ !tou
touch file1
touch: cannot touch 'file1': Permission denied
</pre>
      <p>
       Ta instrukcja podstawi najczęstsze wystąpienie polecenia 
       rozpoczynającego się o tych liter. Podobną metodą jest podanie fragmentu
       polecenia zawierającego jakiś ciąg znaków, na przykład:
      </p>
<pre class="code-block">
[user@server1 ~]$ !?file?
touch file1
touch: cannot touch 'file1': Permission denied
</pre>
      <p>
        To polecenie podstawi najczęściej występujące polecenie z historii
        zawierające ciąg znaków <code class="code-inline">file</code>.
      </p>
      <p>
        Za pomocą polecenia wykrzyknika możemy odwołać się do ostatniego
        polecenia podając drugi wykrzyknik. Tą metodę możemy zastosować
        w przypadku gdy zapomnimy o <em>sudo</em> przy wydawaniu poleceń
        administracyjnych.
      </p>
<pre class="code-block">
[user@server1 ~]$ cat /var/log/secure
cat: /var/log/secure: Permission denied
[user@server1 ~]$ sudo !!
sudo cat /var/log/secure
[sudo] password for user: 
Jun 26 14:12:08 server1 polkitd[725]: Loading rules from directory /etc/polkit-1/rules.d
Jun 26 14:12:08 server1 polkitd[725]: Loading rules from directory /usr/share/polkit-1/rules.d
Jun 26 14:12:08 server1 polkitd[725]: Finished loading, compiling and executing 12 rules
Jun 26 14:12:08 server1 polkitd[725]: Acquired the name org.freedesktop.PolicyKit1 on the system bus
...
</pre>
      <p>
        Historię możemy wyłączyć używając polecenia
        <code class="code-inline">set -o history</code>. Włączenie historii
        wymaga polecenia <code class="code-inline">set +o history</code>.
        Historia kontrolowana jest za pomocą trzech zmiennych
        <em>HISTSIZE</em>, której wartość jest równoznaczna z ze zmienną
        <em>HISTFILESIZE</em> oraz <em>HISTCONTROL</em>.  Ich opisy znajdują
        się na stronie podręcznika polecenia <em>bash</em>. Natomiast ścieżka
        do pliku zawierającego historie z poprzednich sesji znajduje się w
        zmiennej <em>HISTFILE</em>.
      </p>
      <h3 id="7.1.5.editingcli">7.1.5. Edycja wiersza polecenia</h3>
      <p>
        Za pomocą strzałek w lewo oraz w prawo, możemy przesuwać kursor w 
        wierszu polecenia, jednak istnieją znacznie bardziej efektywne
        sposoby na edycje wpisanego polecenia.
      </p> 
      <ul>
        <li><em>Ctrl+a</em> - przenosi kursor na początek wiersza.</li>
        <li><em>Ctrl+e</em> - przenosi kursor na koniec wiersza.</li>
        <li><em>Ctrl+f</em> - przenosi kursor o jeden znak w prawo.</li>
        <li><em>Ctrl+b</em> - przenosi kursor o jeden znak w lewo.</li>
        <li><em>Alt+f</em> - przenosi kursor o jedno słowo w prawo.</li>
        <li><em>Alt+b</em> - przenosi kursor o jedno słowo w lewo.</li>
        <li><em>Ctrl+u</em> - usuwa wszystko z linii polecenia.</li>
      </ul>
      <p>
        Te skróty pozwalają na sprawniejsze poruszenie się w wierszu
        polecenia.
      </p>
      <h3 id="7.1.6.commandcompletion">7.1.6. Uzupełnianie poleceń</h3>
      <p>
        Chcąc przyspieszyć pisanie poleceń możemy wykorzystać uzpełnianie
        poleceń. Wierszu polecenia zapisujemy fragment polecenia lub ścieżki
        następnie naciskamy klawisz <strong>Tab</strong>. Powłoka uzupełni
        nasz zapis do wspólnej części z na przykład nazwami plików, katalogów
        czy poleceń. Po następnym naciśnięciu tego klawisza, powłoka zwróci 
        możliwe warianty pasujące do tego co zapisaliśmy.
      </p>
<pre class="code-block">
[user@server1 ~]$ deb

#Pierwsze naciśnięcie klawisza Tab
[user@server1 ~]$ debug

#Drugie naciśnięcie klawisza Tab
[user@server1 ~]$ debug
debugfs          debuginfod-find  
[user@server1 ~]$ debug
</pre>
      <p>
        Kiedy dopiszemy kilka liter z jednego z wariantów, polecenie dopełni
        je pozostałymi lub zwróci zawężoną ilość możliwych do wyboru elementów.
      </p>
      <h3 id="7.1.7.tilde">7.1.7. Podstawienie tyldy</h3>
      <p>
        Tylda w powłoce oznacza jedno - katalog domowy użytkownika. Za jej
        pomocą możemy w prosty sposób odwoływać się do elementów w katalogu
        domowym użytkownika ale i nie tylko. Poniżej przedstawiłem trzy
        zastosowania tego podstawienia.
      </p>
      <ul>
        <li><strong>~/Dokumenty</strong> - odwołanie się do elementu 
          znajdującego się w katalogu domowym użytkownika.</li>
        <li><strong>~+</strong> - odwołanie się do obecnego katalogu roboczego
          (wyświetla ścieżkę bezwzględną obecnego katalogu roboczego),
          równoznaczne z podstawiemiem polecenia <em>pwd</em>.</li>
        <li><strong>~-</strong> - odwołanie się do poprzedniego katalogu
          roboczego, podstawienie również zwraca ścieżkę bezwzględną do 
          katalogu,
          w którym się znajdowaliśmy przed przejściem do obecnego.</li>
      </ul>
      <p>
        Podstawienie tyldy może zaoszczędzić nam czas oraz zmieniejszyć ilość
        pisania. Poniżej znajduje się kilka przykładów prezentujących powyższe
        podstawienia.
      </p>
<pre class="code-block">
[user@server1 logs]$ echo ~+
/home/user/logs
[user@server1 logs]$ echo ~
/home/user
[user@server1 logs]$ cd /etc
[user@server1 etc]$ echo ~-
/home/user/logs
</pre>
      <h3 id="7.1.8.alias">7.1.8. Aliasy</h3>
      <p>
        Alias to nazwa zastępcza, dzięki której możemy zastąpić długie
        polecenia za pomocą pojedyńczego wyrazu. Aliasy definiowane są
        pomocą polecenia <strong>alias</strong>, jako argument przyjmuje on
        definicję aliasów, czyli nazwę zastępnczą, znak równości oraz
        polecenie w podwójnych apostrofach. Między tym elementami nie
        powinno być spacji. Poniżej znajduje się definicja aliasów, który
        szuka w katalogu domowym plików powyżej 1 GB a następnie zwraca ich
        atrybutu. 
      </p>
<pre class="code-block">
alias bigfiles="find ~ -size +1G -exec ls -lh {} \;"
[user@server1 ~]$ bigfiles 
-rw-r--r--. 1 user user 1.5G Jul  1 12:55 /home/user/test.img
</pre>
      <p>
        Ważną rzeczą związna z aliasami jest fakt iż kiedy powłoka otrzymuje
        polecenie do interpretacji to sprawdza na początku czy nie jest ono
        aliasem i jeśli tak jest to wykonuje to co znajduje się pod nim. Aliasy
        mogą mieć takie same nazwy jak programy czy inne polecenia w systemie,
        dlatego też mogą je przesłaniać. Tak jest w przypadku superużytkownika
        z poleceniami <em>cp</em>, <em>mv</em> czy <em>rm</em>. Poniższy
        przykład dobrze to obrazuje.
      </p>
<pre class="code-block">
[user@server1 ~]$ alias rm="rm -i"
[user@server1 ~]$ rm test.img
rm: remove regular file 'test.img'? n
</pre>
      <p>
        Aby powłoka nie brała nazwy polecenia przy poszukiwaniu aliasów, należy
        poprzedzić ją znakiem lewego ukośnika czy <em>backslashu</em>
        (<strong>\</strong>).
      </p>
<pre class="code-block">
[user@server1 ~]$ rm logs
rm: remove symbolic link 'logs'? n
[user@server1 ~]$ \rm logs
</pre>
      <p>
        Usuwaniu aliasów służy polecenie <strong>unalias</strong>.
      </p>
<pre class="code-block">
[user@server1 ~]$ unalias bigfiles
[user@server1 ~]$ bigfiles
bash: bigfiles: command not found...
</pre>
      <h3 id="7.1.9.metacharacters">7.1.9. Metaznaki oraz nazwy wieloznaczne</h3>
      <p>
        Chcąc odwołać się do wielu elementów posiadających wspólne fragmenty
        nazw możemy użyć tzw. <strong>metaznaków</strong> lub
        <em>nazw wieloznacznych</em>, służą one podstawianiu znaków pod używane
        wraz z nim nazwy. Załóżmy że mamy dwa rodzaje archiwów w katalogu jedne
        rozpoczynają się od nazwy <em>backup</em> a drugie od nazwy <em>d</em>
        kazde archiwum zawiera w nazwie po podanej części myślnik oraz datę.
        Chcemy wyświetlić atrybuty archiwów z nazwą zaczynającą się od <em>d</em>
        w tym celu możemy użyć nazwy wieloznacznej. Podstawiając za nazwą
        gwiazdkę.
      </p>
<pre class="code-block">
[js@fujitsu windows]$ ls -l D*
-rwxr--r-- 1 windows windows 11718211581 05-01 21:09 D-2022-05-01.7z
-rwxr--r-- 1 windows windows 11718211581 05-02 21:08 D-2022-05-02.7z
-rwxr--r-- 1 windows windows 11718211581 05-03 21:08 D-2022-05-03.7z
-rwxr--r-- 1 windows windows 11718269229 05-04 21:15 D-2022-05-04.7z
-rwxr--r-- 1 windows windows 11718658739 05-05 21:14 D-2022-05-05.7z
-rwxr--r-- 1 windows windows 11718634289 05-06 21:14 D-2022-05-06.7z
-rwxr--r-- 1 windows windows 11718634289 05-07 21:08 D-2022-05-07.7z
-rwxr--r-- 1 windows windows 11718634289 05-08 21:08 D-2022-05-08.7z
-rwxr--r-- 1 windows windows 11718633900 05-09 21:15 D-2022-05-09.7z
...
</pre>
      <p>
        Do stosowania nazw wieloznacznych, możemy stosować wiele znaków ich
        opis znajduje się na liście poniżej.
      </p>
      <ul>
        <li><strong>*</strong> - gwiazdka, ten symbol podstawia dowolną ilość
          dowolnych znaków. Mogą one w ogóle nie występować.
<pre class="code-block">
[user@server1 ~]$ ls -l D*
-rw-r--r--. 1 user user 0 Jul  1 13:39 D
</pre>
        </li>
        <li><strong>?</strong> - znak zapytania, pojedyńczy dowolny znak.
<pre class="code-block">
[user@server1 ~]$ ls -l ??.*
-rw-r--r--. 1 user user 2732 Jun 30 19:14 ls.out
</pre>
        </li>
        <li><strong>[]</strong> - nawias kwadratowy, zakresy lub lista znaków.
          Lista znaków:
<pre class="code-block">
[user@server1 ~]$ ls -l /dev/*[ty]
crw-------. 1 root root 10, 126 Jul  1 11:00 /dev/cpu_dma_latency
crw-------. 1 root root 10, 228 Jul  1 11:00 /dev/hpet
crw-r-----. 1 root kmem  1,   4 Jul  1 11:00 /dev/port
crw-------. 1 root root 10, 231 Jul  1 11:00 /dev/snapshot
lrwxrwxrwx. 1 root root      15 Jul  1 11:00 /dev/stdout -&gt; /proc/self/fd/1
crw-rw-rw-. 1 root tty   5,   0 Jul  1 13:03 /dev/tty
</pre>
          Zakres:
<pre class="code-block">
[user@server1 ~]$ sudo ls -ld /etc/systemd/system/[m-o]*
drwxr-xr-x. 2 root root 4096 Jun 26 13:54 /etc/systemd/system/multi-user.target.wants
drwxr-xr-x. 2 root root   48 Jun 26 13:50 /etc/systemd/system/network-online.target.wants
</pre>
          Zakresy oraz listy znaków mogą zostać zanegowane za pomocą
          wykrzyknika.
<pre class="code-block">
[user@server1 ~]$ sudo ls -ld /etc/systemd/system/[!m-o]*
[sudo] password for user: 
drwxr-xr-x. 2 root root   65 Jun 26 13:54  /etc/systemd/system/basic.target.wants
drwxr-xr-x. 2 root root   31 Jun 26 13:50  /etc/systemd/system/bluetooth.target.wants
...
</pre>
          Powyższe przypasowane elementy nie zawierają liter od m-o na początku
          swoich nazw.
        </li> 
      </ul>
      <p>
        Stosując nazwy wieloznaczne możemy automatycznie wykonywać te same
        polecenia na elementach posiadających wspólne nazwy.
      </p>
      <h3 id="7.1.10.pipes">7.1.10. Potoki i polecenia potokowe</h3>
      <p>
        Omawiając przkierowania strumieni wspomniałem o potokach. Potok to 
        przekierowanie wyjścia jednego polecenia na wyjście drugiego za pomocą
        znaku pionowej kreski (<strong>|</strong>).
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /etc | head
total 1320
drwxr-xr-x.  3 root root        28 Jun 26 13:50 accountsservice
-rw-r--r--.  1 root root        16 Jun 26 14:01 adjtime
-rw-r--r--.  1 root root      1529 Jun 23  2020 aliases
drwxr-xr-x.  3 root root        65 Jun 26 13:54 alsa
drwxr-xr-x.  2 root root      4096 Jun 26 13:58 alternatives
-rw-r--r--.  1 root root       541 Aug  9  2021 anacrontab
-rw-r--r--.  1 root root       769 Aug 28  2021 appstream.conf
-rw-r--r--.  1 root root        55 Feb 11 10:53 asound.conf
-rw-r--r--.  1 root root         1 Aug  9  2021 at.deny
</pre>
      <p>
        Za pomocą potoków możemy łączyć polecenia w długie łańcuchy
        przekazując strumień wyjściowy wychodzący z innych poleceń na wejście
        kolejnych. Polecenia tego typu nazwyane są 
        <strong>poleceniami potokowymi</strong>. Poniżej znajduej się jedno
        z nich.
      </p>
<pre class="code-block">
[user@server1 ~]$ ls -l /etc | sed -n '15p' | awk '{printf $1}'
</pre>
      <p>
        Powyższe polecenie wyświetli pierwszą kolumnę atrybutów pliku z
        15 lini zawartości katalogu <em>/etc</em>. Polecenia 
        <code class="code-inline">sed</code> oraz 
        <code class="code-inline">awk</code> znajdują się poza zakresem
        merytrorycznym tego materiału.
      </p>
      <h3 id="7.1.11.quoting">7.1.11. Cytowanie</h3>
      <p>
        Za tą enigmatyczną nazwą stoją mechanizmy, których możemy użyć, aby
        znaki specjalne w powłoce, by traktowane jako zwykłe znaki bez
        żadnego specjalnego znaczenia. Pierwszym z nich jest użycie 
        lewego ukośnika (<strong>\</strong>). Jeśli na przykład stworzyślimy
        plik on nazwie <em>*</em>. To jeśli spróbujemy go usunąć bez żadnego
        cytowania usuniemy wszystko co znajduje się w katalogu.
      </p>
<pre class="code-block">
[user@server1 ~]$ rm \*
rm: remove regular empty file '*'? y
[user@server1 ~]$ ls
D  err.out  etc.tar  file1  ls2.out  ls.out  test.img
</pre>
      <p>
        Jak widać na załączonym przykładzie moim plikom nic się nie stało.
        Używanie lewego ukośnika może być uciążliwe jeśli do zacytowania mamy
        więcej niż jeden znak. Wówczas możemy się posłużyć pojedyńczym
        apostrofem (<strong>''</strong>). Wszystko co zostanie umieszczone
        miedzy nimi, będzie traktowane dosłownie. Najprostszym przykładem
        użycia jest odwołanie się do zmiennej.
      </p>
<pre class="code-block">
[user@server1 ~]$ zmienna='abc'
[user@server1 ~]$ echo $zmienna
abc
[user@server1 ~]$ echo '$zmienna'
$zmienna
</pre>
      <p>
        Gdy odwołaliśmy się do zmiennej w pojedyńczych cudzysłowach, znak
        dolara został potraktowany domyślnie, więc polecenie
        <code class="code-inline">echo</code> wypisało ciąg znaków
        <code class="code-inline">$zmienna</code>. Ostatnim rodzajem cytowania
        podobnym do pojedyńczego apostrofu jest podwójny apostrof. Zauważalną
        różnicą jest to, iż podwójny apostrof pozwala na użycie specjalnego
        znaczenia takich znaków jak: lewy ukośnik (<strong>\</strong>),
        znak dolara (<strong>$</strong>) oraz pojedyńczy apostrof
        (<strong>''</strong>), dzięki czemu wewnątrz literałów prezentowanych
        za pomocą podwójnych apostrofów możemy uzyskać wartości zmiennych. 
      </p>
<pre class="code-block">
[user@server1 ~]$ echo "Pierwszym literami alfabetu są litery $zmienna"
Pierwszym literami alfabetu są litery abc
</pre>
      <h3 id="7.1.12.regex">7.1.12. Wyrażenia regularne</h3>
      <p>
        Wyrażenia regularne służą wyszukiwaniu wzorców w tekście. Wzroce
        składają się z ze znaków specjalnych oraz innych zwykłych znaków 
        mających przybliżyć odnalezienie wzorca. Wyrażenia regularne w powłoce
        możemy obsługiwać za pomocą polecenia <strong>grep</strong>. W tym
        materiale również używaliśmy wyrażeń regularnych przy wyświetlaniu
        zawartości pliku <em>/etc/login.defs</em>
      </p>
<pre class="code-block">
[user@server1 ~]$ grep -v -e '^#' -e '^$' /etc/login.defs 
MAIL_DIR	/var/spool/mail
UMASK		022
HOME_MODE	0700
PASS_MAX_DAYS	99999
PASS_MIN_DAYS	0
PASS_WARN_AGE	7
...
</pre>
      <p>
        Na powyższym przykładzie widzimy składnie polecenia, źródłem danych
        nie musi być wyłącznie plik, równie dobrze mogą one pochodzić z
        przekierowania. Na przykład z potoku.
        Najpierw jednak zajmiemy się czymś prostszym, a do tego poziomu 
        dojdziemy pod koniec. Najprostszym wyrażeniem może być zwykły
        ciąg znaków.
      </p>
<pre class="code-block">
[user@server1 ~]$ grep 'pass' /etc/login.defs
# passwd command) should therefore be configured elsewhere. Refer to
#	PASS_MAX_DAYS	Maximum number of days a password may be used.
#	PASS_MIN_DAYS	Minimum number of days allowed between password changes.
#	PASS_MIN_LEN	Minimum acceptable password length.
#	PASS_WARN_AGE	Number of days warning given before a password expires.
</pre>
      <p>
        Jak możemy zauważyć polecenie zwróciło wszystkie linie zawierające
        wyrażenie jakie podaliśmy przed ścieżką do pliku. Podane wyrażenie
        zapisaliśmy za pomocą małych liter i takie też zostało przypasowane
        jeśli chcemy, aby nie była rozrózniana wielkość liter należy użyć
        opcji <em>-i</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ grep -i 'pass' /etc/login.defs
# passwd command) should therefore be configured elsewhere. Refer to
# Password aging controls:
#	PASS_MAX_DAYS	Maximum number of days a password may be used.
#	PASS_MIN_DAYS	Minimum number of days allowed between password changes.
#	PASS_MIN_LEN	Minimum acceptable password length.
#	PASS_WARN_AGE	Number of days warning given before a password expires.
PASS_MAX_DAYS	99999
PASS_MIN_DAYS	0
PASS_WARN_AGE	7
</pre>
      <p>
        Poniżej umieściłem listę znaków wykorzystywanych do tworzenie wyrażeń
        regularnych wraz z opisem. 
      </p>
      <ul>
        <li><strong>.</strong> - pojedyńczy dowolny znak,</li>
        <li><strong>*</strong> - przypasowanie wzorca min. 0 razy lub więcej 
          razy.</li>
        <li><strong>+</strong> - przypasowanie wzorca min. 1 raz lub więcej 
          razy.</li>
        <li><strong>^</strong> - metaznak oznaczający początek wiersza. 
          Wzorzec rozpoczynający się od tego znaku znajduje się na początku 
          wiersza.</li>
        <li><strong>$</strong> - metaznak oznaczający koniec wiersza. Wzorzec
          zakończony tym znakiem znajduje się na końcu wiersza.</li>
        <li><strong>[]</strong> - metaznak ozanaczający zbiory oraz zakresu. 
          Zakresy mogą być różne: litery <em>[a-z]</em>, wielkie litery 
          <em>[A-Z]</em> czy cyfry <em>[0-9]</em>. Zakresy nie muszą być pełne,
          mogą być np. od a do o - <em>[a-o]</em>.
        <li><strong>[^...]</strong> - negacja zbioru, zamiast trzech kropek
          wstawiamy znaki. Przypasowanie następuje wówczas, kiedy we wzorcu
          nie znajdują się podane znaki.</li>
      </ul>
      <p>
        Wiecęj znaków oraz informacji znajduje się na stronie podręcznika
        polecenia <em>grep</em> <code class="code-inline">man grep</code> oraz
        na stronie podręcznika poświęconej wyrażeniom regularnym: 
        <code class="code-inline">man 7 regex</code>. Teraz przedstawie kilka
        dodatkowych opcji polecenia <em>grep</em>.
      </p>
      <ul>
        <li><strong>-E</strong> - opcja umożliwia użycie rozszerzonych
          wyrażeń regularnych, jedną z ciekawych opcji tego trybu jest użycie
          <strong>alternatyw</strong>, czyli dodatkowych wzorców. Kiedy
          nie będzie przypasowań do pierwszego wzorca <em>grep</em> sprawdzi
          pozostałe. Alternatywy zapisuje się po <em>znaku potoku</em>, po
          kresce pionowej <strong>|</strong>.
<pre class="code-block">
[user@server1 ~]$ cat colors 
blue
yellow
green
orange
white
black
[user@server1 ~]$ grep -E 'red|white' colors 
white
</pre>
        </li>
        <li><strong>-v</strong> - odwraca przypasowanie wzorca, polecenie
          wówczas wypisze wszystkie linie nie pasujące do wzorca.</li>
        <li><strong>-o</strong> - zamiast całych wierszy, polecenie zwróci
          tylko pasujący do wzorca fragment danych.</li>
      </ul>
      <p>
        Wiecej opcji znajduje się na stronie podręcznika polecenia 
        <em>grep</em>. Myślę, że teraz bez problemu jesteśmy w stanie 
        zrozumieć przykład z początku tego podrozdziału.
      </p>
      <p class="exam_tip">
        Polecenie <em>grep</em> jest poręcznym narzędziem stosowany do 
        wyłuskiwania informacji z pliku lub wyjścia polecenia. Wybrane
        informacje mogą zostać przekierowane do pliku, pozostawiając dane
        wejściowe nienaruszone.
      </p>
      <h3 id="7.1.13.jobmanaging">7.1.13. Zarządzanie zadaniami</h3>
      <p>
        Uruchmiając jakiś program w terminalu, możemy go odłączyć od niego i
        przekazać jego wykonanie do tła. Wówczas taki program staje się
        <strong>zadaniem</strong>. Program kontynuje swoje wykonanie w tle, 
        ale jest kontrolowany przez terminal, w którym został uruchomiony.
        W pod powłoce uruchomiłem plik test, który jest mały skryptem, który
        tak naprawdę nic nie robi.
      </p>
<pre class="code-block">
[user@server1 ~]$ bash test

</pre>
      <p>
        Użyłem kombinacji klawiszy <strong>Ctrl+z</strong>, aby zatrzymać 
        wykonanie.
      </p>
<pre class="code-block">
[user@server1 ~]$ bash test
^Z
[1]+  Stopped                 bash test
</pre>
      <p>
        W ostatniej linii, na początku w nawiasie kwadratowym znajduje się
        numer zadania. Za pomocą tego numeru możemy odwoływać się do zadania.
        Teraz uruchomimy je w tle.
      </p>
<pre class="code-block">
[user@server1 ~]$ bg %1
[1]+ bash test &amp;
</pre>
      <p>
        Do uruchomienia zadania w tle służy polecenie <strong>bg</strong>,
        Do odwołania się do niego służą numery zadań poprzedzone
        znakiem procentu (<strong>%</strong>). Możemy przywrócić działanie 
        zadania na pierwszy plan przywołując je za pomocą polecenia
        <strong>fg</strong>, metoda odwołania się do zadania jest taka sama 
        jak w przypadku polecenia <em>bg</em>. Zanim przełaczym zadanie na
        pierwszy plan, sprawdźmy jego status za pomocą polecenia
        <strong>jobs</strong>.
      </p>
<pre class="code-block">
[user@server1 ~]$ jobs
[1]+  Running                 bash test &amp;
</pre>
      <p>
        Teraz możemy przełączyć polecenie, aby finalnie je zamknąć za pomocą
        klawiszy <strong>Ctrl + c</strong>.
      </p>
<pre class="code-block">
[user@server1 ~]$ fg %1
bash test
^C
</pre>
      <p>
        W ten sposób zarządza się zadaniami za pomocą mechanizmów powłoki,
        Zadań przekazanych do tła systemu, może być wiele. Zadania nie zostaną
        zakończone w momencie wylogowania się z systemu. Dlatego jeśli
        wykonanie jakiego zadania, będzie wymagać czasu mozemy przenieść je
        do tła. Przy planach użycia tła systemu warto wziąć po uwagę to, aby
        przekierować wyjście programów/poleceń do jakiegoś pliku lub 
        do urządzenia <em>/dev/null</em>, które ma jedno zadanie. Ignorować
        wszelkie napływające do niego dane.
      </p>
      <p>
        Chcąc uruchomić jakieś zadanie w tle odrazu, możemy pominąć tą całą
        zabawę w jego zatrzymywanie i przekazywanie do tła. Możemy uruchomić je
        odrazu kończąc polecenie znakiem ampersendu (<strong>&amp;</strong>).
      </p>
<pre class="code-block">
[user@server1 ~]$ bash test &amp;
[1] 14048
[user@server1 ~]$ jobs
[1]+  Running                 bash test &amp;
</pre>
      <h2 id="7.2.startupscripts">7.2. Pliki startowe powłoki</h2>
      <p>
        Plik startowe powłoki mają za zadanie wykonać kilka czynności 
        konfiguracjynych,
        aby użytkownik po jej uruchomieniu nie musiał tracić czasu
        na ustawienie na przykład ścieżki wszukiwania poleceń, czyli zmiennej
        <em>PATH</em>. Pliki te definiują również aliasy, które jak do tej
        pory mogły się wydawać zwykłymi poleceniami. Pliki startowe powłoki
        możemy podzielić na pliki globalne (mające zastosowanie dla całego
        systemu) oraz pliki lokalne (mające zastosowanie tylko dla jednego
        użytkownika).
      </p>
      <h3 id="7.2.1.systemwidefiles">7.2.1. Globalne pliki startowe powłoki</h3>
      <p>
        Do globalnych plików startowych możemy zaliczyć takie pliki jak
        <em>/etc/bashrc</em>, <em>/etc/profile</em> oraz katalog
        <em>/etc/profile.d</em>. Zmiany w tych plikach wpływają na konfigurację
        powłoki wszystkich użytkowników w systemie. Poniżej znajduje się lista
        ze skróconym opisem co dane pliki zawierają.
      </p>
      <ul>
        <li><strong>/etc/bashrc</strong> - plik zawiera ustawienia właściwości
          <em>PROMPT_COMMAND</em>, ustawienia historii, definicje znaku zachęty,
          maski użytkownika oraz definicje zmiennej środowiskowej <em>SHELL</em>.
        </li>
        <li><strong>/etc/profile</strong> - plik zawiera definicje części
          zmiennych środowiskowych, dopisuje pewne katalogi do zmiennej
          <em>PATH</em></li>
        <li><strong>/etc/profile.d</strong> - katalog zawiera skrypt
          rozszerzające konfiguracje zawarte w powyższych plikach, te skrypt
          są uruchamiane przez oba z nich.</li>
      </ul>
      <p>
        Jeśli musimy umieścić dodatkowe konfiguracje w tych plikach najlepiej
        umieścić je w skrypcie w katalogu <em>/etc/profile.d</em>.
      </p>
      <h3 id="7.2.2.usersfiles">7.2.2. Pliki startowe powłoki użytkownika</h3>
      <p>
        Każdy użytkownik posiada swoje pliki startowe powłoki
        <strong>~/.bash_profile</strong> - odpowiadający globalnemu
        <em>/etc/profile</em> oraz <strong>~/.bashrc</strong> - odpowiadający
        globalnemu <em>/etc/bashrc</em>. Te pliki kopiowane są z katalogu 
        szkieletowego - <em>/etc/skel</em> podczas tworzenia katalogu domowego
        przy zakładaniu nowego użytkownika. Jeśli zajrzymy do zawartości tych
        katalogów, to dowiemy się że:
      </p>
      <ul>
        <li>W pliku <strong>~/.bash_profile</strong> umieszczamy dodatkowe
          zmienne środowiskowe oraz dodatkowe programy lub skrypty startowe.
        </li>
        <li>W pliku <strong>~/.bashrc</strong> umieszczamy dodatkowe aliasy
          oraz funkcje powłoki (funkcje powłoki wykraczają poza ten materiał).
        </li>
      </ul>
      <p>
        Pliki startowe powłoki są uruchamione określonej kolejności. W ramach
        eksperymentu umieściłem, krótką informacje na końcu każdego z nich
        a następnie wylogowałem się i zalogowałem ponownie. W poniższym bloku
        kodu, znajduje się wynik tego eksperymentu:
      </p>
<pre class="code-block">
xf0r3m@inspiron-3542:~$ ssh user@rhel9-vm1 
user@rhel9-vm1's password: 
Register this system with Red Hat Insights: insights-client --register
Create an account or view all your systems at https://red.ht/insights-dashboard
Last login: Sat Jul  2 15:29:33 2022 from 192.168.122.1
Globalny /etc/bashrc
Globalny /etc/profile
Lokalny ~/.bashrc
Lokalny ~/.bash_profile
</pre>
      <p>
        Jak mogliśmy się domyślić na początku uruchiamiane są pliki globalne
        a następnie lokalne.
      </p>
      <p>
        Dodatkowym plikiem użytkownika o nieco innym znaczeniu jest
        <em>~/.bash_logout</em>. Czynności zapisane w tym pliku są
        wykonywane podczas wylogowywania użytkownika.
      </p>
      <p class="exam_tip">
        Jeśli jedno z zadań będzie dotyczyć dodania aliasu lub zmiennej
        środowiskowej, to należy wiedzieć w jakich plikach je umieścić.
      </p>
      <h3 id="exec7.1">Ćwiczenie 1: Zmiana symbolu zachęty</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em> dostosuj znak
        zachęty aby wyglądał jak ten ujęty w podwójne apostrofy
        "&lt;user@server1 in /etc &gt;:". <em>/etc</em> w tym przypadku jest
        ścieżką do obecnego katalogu roboczego. Zapisz nową definicję znaku
        zachęty do odpowiedniego pliku, wyloguje się i zaloguj ponownie 
        następnie usuń tę definicję.
      </p>
      <h3 id="exec7.2">Ćwiczenie 2: Przkierowanie strumieni</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em> wyświetl zawartość
        katalogów <em>/etc</em>, <em>/dvd</em> oraz <em>/var</em> przekieruj
        standardowe wyjście oraz strumień błędów do pliku <em>/tmp/ioerror</em>
        Sprawdź zawartość pliku.
      </p>
      <h2 id="ch2summary">Podsumowanie</h2>
      <p>
        W tym rodziale zapoznaliśmy się z powłoką BASH. Nauczyliśmy się
        korzystać z jej mechanizów, poznaliśmy również podstawy wyrażeń
        regularnych. Na koniec dowiedzieliśmy się jak używać plików startowych
        powłoki, aby dostosować ją do własnych potrzeb. W następnym rodziale
        zajmiemy się procesami.
      </p>
		</div>
	  <p style="margin: 15px; padding: 0; outline: 0;">
				2022; COPYLEFT; ALL RIGHTS REVERSED;
		</p>
	</body>
</html>
