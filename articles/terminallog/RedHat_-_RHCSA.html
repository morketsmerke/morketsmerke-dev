<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<style>
			.code-block {
				display: block;
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
				text-align: left;
			}
			.code-inline {
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
			}
			ul {
				text-align: left;
			}
      .toc {
        list-style-type: none;
      }
      p {
        text-align: justify;
      }
      .exam_tip {
        border: solid 1px black;
      }
		</style>
	</head>
	<body style="font-family: monospace;" >
<pre>
 ____          _ _   _       _   
|  _ \ ___  __| | | | | __ _| |_ 
| |_) / _ \/ _` | |_| |/ _` | __|
|  _ &lt;  __/ (_| |  _  | (_| | |_ 
|_| \_\___|\__,_|_| |_|\__,_|\__|
                                 
</pre>
    <p style="margin: 0; padding: 0; outline: 0; font-size: 18pt;">
	    &#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
    </p>
		<div style="margin-left: auto; margin-right: auto; width: 80%;">
      <h1 style="text-align: center;">RedHat - Red Hat Certified System 
        Administrator 9</h1>
      <h2>Spis treści</h2>
      <ul class="toc">
        <li><a href="#1.introduction">1. Wstęp</a>
          <ul class="toc">
            <li><a href="#1.1.exam">1.1. Egzamin</a></li>
            <li><a href="#1.2.examobjectives">1.2. Zagadnienia</a></li>
            <li><a href="#1.3.exampreparation">1.3. Przygotowania</a>
              <ul class="toc">
                <li><a href="#1.3.1.vboxinstallationonrhel">1.3.1. Instalacja Oracle VirtualBox na RHEL 8.6.</a></li>
                <li><a href="#1.3.2.gettingrheliso">1.3.2. Pozyskiwanie obrazu ISO z Red Hat Enterprise Linux 9</a></li>
                <li><a href="#1.3.3.createvmwithrhel">1.3.3. Tworzenie maszyn wirtualnych VirtualBox z RHEL</a></li>
                <li><a href="#1.3.4.rhelinstallation">1.3.4. Instalacja Red Hat Enterprise Linux 9.0</a></li>
              </ul> 
            <li><a href="#exec1.1">Ćwiczenie: 1-1</a></li>
            <li><a href="#exec1.2">Ćwiczenie: 1-2</a></li>
            <li><a href="#ch1summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#2.firststepsinRHEL9">2. Poruszanie się po systemie RHEL 9</a>
          <ul class="toc">
            <li><a href="#2.1.serverwithgui">2.1. Środowisko graficzne RHEL 9</a></li>
            <li><a href="#2.2.hfs">2.2. Struktura katalogowa w Uniksach</a></li>
            <li><a href="#2.3.usingcli">2.3. Obsługa wiersza poleceń i najprostsze polecenia</a>
              <ul class="toc">
                <li><a href="#2.3.1.ls">2.3.1. Listowanie zawartości katalogu</a></li>
                <li><a href="#2.3.2.pwd">2.3.2. Wyświetlanie bierzącego katalogu</a></li>
                <li><a href="#2.3.3.cd">2.3.3. Poruszanie się wśród katalogów</a></li>
                <li><a href="#2.3.4.tty">2.3.4. Identyfikacja urządzenia terminala</a></li>
                <li><a href="#2.3.5.uptime">2.3.5. Czas systemowy oraz załadowanie procesora</a></li>
                <li><a href="#2.3.6.clear">2.3.6. Czyszczenie ekranu powłoki</a></li>
                <li><a href="#2.3.7.which">2.3.7. Określanie ścieżki polecenia</a></li>
                <li><a href="#2.3.8.uname">2.3.8. Wyświetlenie informacji o systemie</a></li>
                <li><a href="#2.3.9.lscpu">2.3.9. Wyświetlenie informacji o procesorze</a></li>
              </ul>
            </li>
            <li><a href="#2.4.gettinghelp">2.4. Uzyskiwanie pomocy</a>
              <ul class="toc">
                <li><a href="#2.4.1.manpages">2.4.1. Strony podręcznika</a></li>
                <li><a href="#2.4.2.helpincommand">2.4.2. Pomoc w samym poleceniu</a></li>
                <li><a href="#2.4.3.texinfo">2.4.3. Dokumentacja texinfo</a></li>
                <li><a href="#2.4.4.usrsharedoc">2.4.4. /usr/share/doc</a></li>
                <li><a href="#2.4.5.rhdocs">2.4.5. Dokumentacja Red Hat Enterprise Linux</a></li>
              </ul>
            </li>
            <li><a href="#exec2.1">Ćwiczenie: 2-1</a></li>
            <li><a href="#exec2.2">Ćwiczenie: 2-2</a></li>
            <li><a href="#exec2.3">Ćwiczenie: 2-3</a></li>
            <li><a href="#exec2.4">Ćwiczenie: 2-4</a></li>
            <li><a href="#ch2summary">Podsumowanie</a></li>
          </ul>
        </li>
      </ul>
      <h1 id="1.introduction">1. Wstęp</h1>
      <p>
        Chcąc zmienić coś w swoim życiu postanowiłem, że zacznę od pracy.
        Dalej chciałem pracować w IT, tylko na innym stanowisku (praca 
        szkolnego administratora
        jest porównywalna z pracą technika IT, tu ma ktoś problem z systemem,
        tu trzeba podłączyć rzutnik, szczerze to znudziła się praca tego 
        typu).  Dobrze czułem się pracując z
        Linuksem, to była moja pasja. Znałem dwa stanowiska na których 
        mógłbym pracować: Linux System Administrator lub Linux System
        Engineer. Teraz na rynku pracy jeśli chodzi o IT ważniejsze są 
        uzyskane certyfikaty i odbyte kursy niż wykształcenie. Szukając 
        certyfikatów,
        które spowodują większe szanse na zatrudnienie, znalazłem dwa.
        Linux Fundation oraz Red Hat. Po przeczytaniu postu a na Reddit
        doszedłem do wniosku, że lepszym wyborem będzie Red Hat. Jeśli
        chodzi o produkcyjne wykorzystanie Linuksa to prym wśród firm
        wiedzie Red Hat lub jego darmowy odpowiednik. Kiedyś CentOS ale
        obecnie może być to zarówno Rocky Linux lub Alma Linux, oba są
        pochodnymi Red Hat. Szukając jakiś materiałów w internecie, które
        pomogły by mi się przygotować natrafiłem na Amazonie na książke
        Asghara Ghori pt. <em>RHCSA Red Hat Enterprise Linux 8 (UPDATED): 
        Training and Exam Preparation Guide (EX200), Second Edition</em>
        zamówiłem ją na swojego Kindla i zacząłem przygotowywać się do
        egzaminu. 
      </p>
      <h2 id="1.1.exam">1.1. Egzamin</h2>
      <p>
        Egzamin EX200 dający uprawnienia Red Hat Certified System
        Administrator jest egzamin praktycznym sprawdzającym umiejętność
        instalacji, konfiguracji oraz rozwiązywania podstawowych problemów
        administracyjnych na dystrybucji Red Hat. Egzamin będzie odbywać
        się w postaci elektronicznej i zdający będzie mięć do dyspozycji
        dwie maszyny wirtualne do wykonania zadań egzaminacyjnych. Takie
        też środowisko przygotujemy sobie do nauki. Na dzień 11 listopada
        2020 (tak jak podaje książka) egzamin obejmować 69 zagadnień jednak
        ta liczba, ze względu na rozwój technologii jak i samego Red Hata
        mogła ulec już zmianie.
      </p>
      <h2 id="1.2.examobjectives">1.2. Zagadnienia</h2>
      <p>
        Zagadnienia używane na egzaminie mogą cały czas ewoluować. Odnośnik
        obok przedstawia aktualne zagadnienia egzaminacyjne.
        <a href="http://www.redhat.com/training/courses/ex200/examobjective">http://www.redhat.com/training/courses/ex200/examobjective</a>. Obecnie egzamin zadawany jest na
        RHEL 9, wydany 17 maja 2022. Dość istotną zmianą w produkcji tego
        systemu jest zmiana <em>upstreamu</em>. Ta wersja Red Hat nie jest
        już oparta na Fedorze tak jak wszystkie do tej pory, ale na CentOS
        Stream (nowa wersja non-stream tej dystrybucji nie jest już dostępna 
        stąd
        rozbicie społeczonościowych dystrybucji do zastosowań produkcyjnych na
        Rocky oraz Alma Linux) i tej wersji będziemy użwać na maszynach
        wirtualnych.
      </p>
      <h2 id="1.3.exampreparation">1.3. Przygotowania</h2>
      <p>
        Kiedy uznałem, że chce zdobyć RHCSA, uzyskałem Red Hat na zasadzie
        <em>Non-cost RHEL Individual Developer Subscription</em>, gdzie
        istotne informacje znajdują się w odnośniku obok.
        <a href="https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux">https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux</a>
        Przy użyciu tej subskrypcji uzyskamy dostęp do Red Hat przez rok na
        16 instalacji (bez znaczenia czy to fizyczny komputer, czy maszyna
        wirtualna). Po tym czasie należy zalogować się ponownie, zakceptować
        warunki umowy i po 15 do 30 minut powinnimy uzyskać ponowny rok
        subskrypcji i tak co roku. Wszystko jest opisane na powyższej stronie.
        System w wersji 8.6 (ponieważ na wersję 9.0, moim zdaniem jest
        za wcześnie, kiedyś zainstalowałem RHEL 8 na laptopie to non stop
        otrzymywałem jakieś raporty o błedach) zainstalowałem na komputerze
        codziennego użytku w pracownii. Najlepszym sposobem na nauczenie się
        administracji systemu jest jego używanie, a że jest entuzajstą a nie
        profesjonalistą, mój kontakt z systemami tego typu jest raczej dość
        mocno ograniczony. Dlatego też przesiadłem się na RHEL, póki co ten
        system poprostu działa, wcześniej korzystałem z Fedory 35 oraz
        Debiana 11. Do celów dydaktycznych potrzebujemy peceta lub laptopa
        z min. dwurdzeniowym procesorem, 8GB pamięci operacyjnej oraz 27GB
        wolnej przestrzeni na dysku na potrzeby utworzenia maszyn wirtualnych
        z wymagną przez ćwiczenia przestrzenią dyskową oraz możliwością
        wirtualizacji 64-bitowych systemów. Do tego celu 
        użyjemy oprogramowania Oracle VirtualBox, dającego najprostszy
        interfejs do interakcji z maszynami, gdyż przy późniejszych
        zagadnieniach będziemy musieli zmienić jej ustawienia lub dodać kilka
        urządzeń, oczywiście jeśli ktoś czuje się mocny w innych środowiskach
        może użyć swojego ulubionego, nie mniej jednak w trakcie nauki będzie
        trzeba dokonać kilku zmian w na tych maszynach, a opisy zamieszczone
        tutaj będą dotyczyć głównie VirtualBox. Czy ktoś zainstaluje na swoim 
        komputerze RHEL czy nie to,
        już indywidualna sprawa i nie wypłynie ona wykonanie ćwiczeń. Nie
        mniej jednak, w podpunkcie odnośnie maszyn wirtualnych tego rodziału
        przedstawie skrypt powłoki, który po uruchomieniu utworzy
        automatycznie maszyny wymagane do wykonania ćwiczeń. Ale póki co 
        przedstawie teraz instalacje Oracle VirtualBox na RHEL 8.6.
      </p>
      <h3 id="1.3.1.vboxinstallationonrhel">1.3.1. Instalacja Oracle VirtualBox 
        na RHEL 8.6</h3>
      <p>
        Pierwszą czynnością jest uruchomienie przeglądarki i przejście pod
        adres: <a href="https://www.virtualbox.org/wiki/Linux_Downloads">https://www.virtualbox.org/wiki/Linux_Downloads</a>, na samym dole strony znajdują się pliki repozytorium
        dla kilku dystrybucji Linuksa. Pobieramy ten przeznaczony dla RHEL
        następnie przenosimy go do wskazanego na stronie katalogu. Następnie
        możemy wydać polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        Po instalacji, przełączamy się w terminalu na użytkownika <em>root</em>.
        Następnie wydajemy poniższe polecenia:
      </p>
<pre class="code-block">
$ sudo su
# akmods
Checking kmods exist for 4.18.0-372.9.1.el8.x86_64         [  OK  ]
# systemctl restart vboxdrv.service
</pre>
      <p>
        Teraz Oracle VirtualBox jest gotów do działania.
      </p>
      <p>
        W przypadku RHEL 9, jeśli ktoś używa, to instalacja wydaje się jeszcze
        prostsza, gdyż do instalacji możemy użyć <strong>RPMFusion</strong>. Po 
        załadowaniu tych repozytoriów do swojego systemu możemy od razu wydać
        polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        W wersji 8.6, zapewne również możemy skorzystać z <em>RPMFusion</em>.
        Ja zanim się dowiedziałem że VirtualBox jest dostępny w tych
        repozytoriach, instalowałem go za pomocą instrukcji zawartej na stronie
        Virtualbox, do której link znajduje się powyżej.
      </p>
      <h3 id="1.3.2.gettingrheliso">1.3.2. Pozyskanie obrazu ISO z Red Hat 
        Enterprise Linux 9</h3>
      <p>
        Aby uzyskać takowy obraz musimy zarejestrować się w subskrypcji dla
        indywidualnych deweloperów. Przechodzimy na stronę <a href="https://developers.redhat.com/register">https://developers.redhat.com/register</a> i rejestrujemy się. Następnie
        logujemy i po zalogowaniu przechodzimy na stronę: <a href="https://developers.redhat.com/products/rhel/download">https://developers.redhat.com/products/rhel/download</a>.
        w sekcji <em>All Downloads</em> znajdują się wszystkie dostępne wersje
        Red Hat objęte jeszcze wsparciem. Nas będzie interesować wyłącznie
        wersja 9 i tą też pobieramy, oczywiście dla architektury <em>x86_64</em>
        w wersji DVD.
      </p>
      <h3 id="1.3.3.createvmwithrhel">1.3.3. Tworzenie maszyn wirtualnych 
        VirtualBox z RHEL</h3>
      <p>
        Tworzenie maszyn wirtualnych VirtualBox, nie jest zaganieniem
        egzaminacyjnym. Na egzaminie dostaniemy dostęp do dwóch zdalnych
        maszyn. Teoretycznie można by użyć fizycznych maszyn o ile ktoś ma
        do takowych dostęp, jednak do drugiej maszyny trzeba dodać aż 7 dysków,
        więc użycie wirtualnej maszyny, to chyba jedyne efektywne rozwiązanie. 
        Poniżej znajdują się wymagania jakie powinna spełniać każda z nich:
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
          <ul>
            <li>64-Bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor,</li>
            <li>1024 MB pamięci operacyjnej,</li>
            <li>10GB dysk twardy, wyłącznie na instalacje systemu,</li>
            <li>Karta sieciowa ustawiona na bridged.</li>
            <li>Nazwa hosta ustawiona na server1.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
        <li><strong>RHEL9-VM2</strong>:
          <ul>
            <li>64-bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor</li>
            <li>2048 MB pamięci operacyjnej</li>
            <li>10 GB dysk twardy, na instalacje systemu</li>
            <li>4 x 250 MB dysk twardy, dla ćwiczeń z LVM</li>
            <li>1 x 4 GB dysk twardy, dla ćwiczeń z VDO</li>
            <li>1 x 1 GB dysk twardy, dla ćwiczeń ze Stratis</li>
            <li>Nazwa hosta ustawiona na server2.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
      </ul>
      <p>
        Maszyny możemy utworzyć ręcznie, podążając za wskazówkami przewodnika,
        w przypadku drugiej maszyny dodatkowe dyski trzeba będzie dodać z
        poziomu ustawień maszyny. Drugą możliwością jest skorzystanie z dwóch
        poniższych skryptów kolejno dla
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM1";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;
$vboxmanage storagectl $vmname --name SATA0 --add sata;

$vboxmanage modifyvm $vmname --memory 1024;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";
</pre>
        </li>
        <li><strong>RHEL9-VM2</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM2";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/VDO.vdi" --size \
4096 --format VDI --variant Standard;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/Stratis.vdi" \
--size 1024 --format VDI --variant Standard;

$vboxmanage storagectl $vmname --name SATA0 --add sata;
$vboxmanage modifyvm $vmname --memory 2048;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";

$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";

i=2;
while [ $i -le 5 ]; do
  $vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi" --size \
  250 --format VDI --variant Standard;
  $vboxmanage storageattach $vmname --storagectl SATA0 --port $i --type hdd --medium \
  "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi";
  i=$((i + 1));
done

$vboxmanage storageattach $vmname --storagectl SATA0 --port 6 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/VDO.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 7 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/Stratis.vdi";
</pre>
        </li>
      </ul>
      <p>
        Powyższe skrypt są również dostępne na moim profilu na github-ie. Pod
        poniższymi linkami.
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh</a></li>
        <li><strong>RHEL9-VM2</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh</a></li>
      </ul>
      <p>
        Korzystając ze skryptów <strong>należy pamiętać o zmianie intefejsu
        sieciowego</strong> wykorzystywanego do mostkowania. Zmienna
        <code class="code-inline">bridge_if</code>.
      </p>
      <p>
        Po utworzeniu maszyn przyszedł czas na instalację.
      </p>
      <h3 id="1.3.4.rhelinstallation">1.3.4. Instalacja Red Hat Enterprise 
        Linux 9.0</h3>
      <p>
        Zaraz po uruchomieniu maszyny rozpocznie się proces ładowania
        zawartości płyty. Menu bootowania płyty zawiera trzy opcje. 
      </p>
      <ol>
        <li><em>Install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Test this media & install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Troubleshooting</em></li>
      </ol>
      <p>
        Domyślnie zaznaczoną jest opcja numer 2. Mamy minutę na zmianę
        decyzji. Naciśnięcie dowolnego klawisza zatrzymuje odliczanie. Dając
        nam czas do namysłu, jednak na ten moment nie co za bardzo rozmyślać
        dlatego też wybieramy opcję numer 1. Po wybraniu tej opcji nastąpi
        uruchomienie systemu oraz instalatora. Instalator używany przez RHEL 
        oraz dystrybucje z nim związane
        nazywa się <strong>Anaconda</strong>. Swoje działanie
        rozpoczyna jeszcze w trybie tekstowym, następnie domyślnie uruchamia
        tryb graficzny, gdzie odbywa się konfiguracja instalcji a następnie 
        już właściwa instalacja.
        Nie mniej jednak instalacja w trybie tekstowym jest również możliwa.
        Podczas instalacji, poza głównym instalatorem będziemy mieć do
        dyspozycji 
        multipekser terminala, który do momentu uruchomienia właściwego 
        instalatora (w wersji graficznej) był główną konsolą. W multiplekserze
        będzie my mieć dostęp do komunikatów diagnostyczny, które w wersji 8
        RHEL był wyświetlane na oddzielnych konsolach; kilka powłok z
        uprawnieniami superużytkownika (uruchomione na konsolach 2, 3 i 5) 
        oraz konsolę z komunikatami przechwytywanymi przez główny 
        rejestrator systemu <em>syslog</em>. Udostępnienie tych funkcjonalności
        podczas instalacji systemu, może pomóc w ewentualnym namierzeniu i
        naprawie problemów z instalacją.
        Pliki z komunikatami na czas instalacji przechowywane są w katalogu 
        <em>/tmp</em>, po instalacji zostaną one przeniesione do katalogu
        <em>/var/log/anaconda</em>. Według mnie jest dość przydatna
        funkcjonalność, ponieważ na podstawie czasu modyfikacji tych plików
        możemy dowiedzić się kiedy system został zainstalowany. Poniżej
        znajduje się lista, opisująca za co odpowiada konkretna konsola
        (kolejny ekran, dostępny po naciśnięciu klawiszy Ctrl + Alt + F1 - F6).
      </p>
      <ul>
        <li><strong>CTLR + ALT + F1</strong> - multiplekser terminala,</li>
        <li><strong>CTRL + ALT + F2</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F3</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F4</strong> - komunikaty diagnostyczne
            rejestratora <em>syslog</em>.</li>
        <li><strong>CTRL + ALT + F5</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F6</strong> - tryb graficzny.</li>
      </ul>
      <p>
        Instalacja Red Hat Enterprise Linux rozpoczyna się od wyboru języka
        procesu instalacji. Chcąc pracować już w takim prawowitym IT, należy
        posługiwać się językiem angielskim i to technicznym. Systemy z którymi
        zderzmy się w potencjalnej pracy raczej będą systemami o zasięgu
        międzynarodowym, prawdopodobnie już o tym wspominałem ale egzamin
        pozwalający uzyskać certyfikacje RHCSA również będzie po angielsku.
        Dlatego też instalować jak i korzystać z systemu będziemy w języku
        angielskim, na pierwszym ekranie wybieramy <em>English</em>
        pozostawiając wariant <em>English (United States)</em>. Następnym
        ekranem jest <em>Installation Summary</em> (lewy górny róg), jest tak
        jakby pulpit programu instalacyjnego, na nim występują komponenty,
        które możemy skonfigurować. W wersji 9.0, te komponenty są podzielone
        na 4 sekcje: <em>Localization</em>, <em>Software</em>, <em>System</em>
        oraz <em>User Settings</em>. W pierwszym procesie instalacji,
        przejdziemy przez wszystkie z nich.
      </p>
      <p>
        Zwróć my uwagę na to, iż system sam dokonał wstępnej konfiguracji
        instalatora, na pozostało jedynie sprawdzić oraz skonfigurować tylko
        te opcje oznaczone znakiem ostrzegawczym oraz czerwoną podpowiedzią. Po
        ich konfiguracji program umożliwi nam zainstalowanie systemu.
      </p>
      <p>
        W sekcji lokalizacyjnej do ustawienia są takie opcje, układ klawiatury,
        język, oraz data i czas. Podczas ładowania pierwszego okna (moment 
        wybrania języka instalacji), instalator na podstawie informacji GeoIP
        postara się określić naszą przybliżoną lokalizację, o ile posiada on
        na tym momencie połączenie z internetem. Dlatego też możemy
        spotkać się z samoinstnie wybranym języku instalacji ustawionym na
        Polski. Język został zmieniony, ale wybrana strefa czasowa może
        pozostać, wręcz powinna. Dzięki tej funkcji możemy zaoszczędzić czas,
        i przejść do kolejnej sekcji.
      </p>
      <p>
        Kolejną sekcja dotyczy oprogramowania, tutaj konfigurowane będzie
        na przykład połączenie z firmą Red Hat. RHEL jest system 
        licencjonowanym i jeśli chcemy skorzystać z oficjalnych repozytoriów
        należy "podłączyć" system do naszego konta założonego w celu
        pozyskania obrazu płyty. Jednak na razie nie trzeba tego, będzie to
        do zrobienia na późniejszych etapach nauki administracji systemem.
        Kolejną opcją jest <em>Installation Source</em> (Źródło instalacji),
        konfigurąc tę opcję możemy
        wybrać czy będziemy korzystać pod czas instalacji z obrazu płyty lub
        sieciowego repozytorium lub Red Hat CDN. Z racji tego, iż ściągneliśmy 
        pełny obraz
        ważący kilka gigabajtów, nie ma sensu używać instalacji sieciowej.
        Tego typu źródło instalacji należy wybrać w momencie gdy pobraliśmy
        minimalistyczną wersję obrazu, dlatego też zostaniemy przy standardowym
        wyborze <em>Local media</em>. Ta opcja pozwala też na dodanie podczas
        instalacji dodatkowego repozytorium, jednak na tym etapie nie będziemy
        się tym zajmować. Ostanią opcją z tej sekcji jest <em>Software
        selection</em>, ta opcja daje nam możliwość, wyboru rodzaju instalacji.
        Na potrzeby nauki, wybierzemy opcję <em>Server with GUI</em>, jeśli
        będziemy instalować RHEL na naszym komputerze do codziennego użytku
        możemy wybrać <em>Workstation</em>. Wybierając rodzaj instalacji po
        lewej stronie, po prawej wyświetają się dodatkowe pakiety lub
        warianty do zainstalowania.
      </p>
      <p>
        Sekcja <em>System</em>, służy głównie do wyboru docelowego miejsca dla
        instalacji. W opcji <em>Instalation Destination</em>,
        wskazujemy docelowy dysk do instalacji, możemy go spartycjonować 
        ręcznie lub automatycznie możemy również zaszyfrować instalacje,
        jeśli jest taka potrzeba. W przypadku szyfrowania danych 
        bardzo ważny jest układ klawiatury. Innymi opcjami
        póki co dla nas ważnymi jest <em>Network &amp; Host name</em>, w
        założeniach zadania, może być wymagane ustawienie odpowiedniego adresu
        oraz nazwy dla maszyny. Tak jest w naszym przypadku, to te opcje
        ustawiamy właśnie tam. Pozostałe opcje tej sekcji, poki co nie są
        dla nas istotne.
      </p>
      <p>
        Ostatnia sekcja ustawia hasło dla superużytkownika oraz tworzy konto
        dla pierwszego użytkownika. Nie musi on posiadać uprawnień
        administratora i nie będzie ich miał. Opcja utworzenia użytkownika
        może się nie mieścić na ekranie, podczas instalacji systemu maszynie
        witualnej, dlatego nie należy przejmować, że jej nie ma.
      </p>
      <p>
        Teraz kiedy wszyskie (te istotne dla instalacji) zostały opisane możemy
        zainstalować system zgodnie założeniami pierwsze maszyny i powtorzyć
        to na drugiej. I to jest pierwsze ćwiczenie.
      </p>
      <h3 id="exec1.1">Ćwiczenie 1: Instalacja Red Hat Enterprise Linux 9</h3>
      <p>
        Zainstaluj zgodnie założeniami podanymi w podrozdziale 
        <em>Tworzenie maszyn wirtualnych VirtualBox z RHEL</em> oraz sugestiami
        podanymi podczas opisu procesu instalacji. Red Hat
        Enterprise Linux 9 na maszynie wirtualnej <em>RHEL-VM1</em>. Następnie
        powtórz tę czynność drugiej maszynie przeznaczonej do laboratorium.
        Pamiętaj, że założenia dla drugiej maszyny różnią się.
      </p>
      <h3 id="exec1.2">Ćwiczenie 2: Logowanie zdalne do RHEL</h3>
      <p>
        Wykorzystując program do obsługi protokołu SSH dla twoje systemu
        operacyjnego zaloguj się na superużytkownika. Pamiętaj o tym, że
        bezpośrednie logowanie na superużytkownika wymagało zaznaczenia opcji
        podczas ustawiania hasła dla niego.
      </p>
      <h2 id="ch1summary">Podsumowanie</h2>
      <p>
        W tym rozdziale przezszliśmy przez proces instalacji RHEL.
        Dowiedzielśmy się, że możliwe jest instalacja w trybie tekstowym oraz
        oraz, że nienależy ona do najtrudniejszych. Warto zwrócić uwagę na to
        iż jeśli do tej pory korzystaliśmy z jakiś materiałów to dotyczą one
        wersji 8 RHEL, my będziemy korzystać z wersji 9, bo to na niej w 2022
        roku będziemy zdawać egzamin, a między tymi wersjami jest kilka zmian.
        W następnym rozdziale zapoznamy się z środowiskiem graficznym,
        strukturą katalogów oraz podstawowym narzędziami do pracy w powłoce.
      </p>
      <h1 id="2.firststepsinRHEL9">2. Poruszenia się po systemie RHEL 9</h1> 
      <p>
        Wykonując ćwiczenia z pierwszego rozdziału, zainstalowaliśmy sobie
        Red Hat w wersji 9 na maszynie wirtualnej. Jako wariant wyboru
        oprogramowania wybraliśmy <em>Server with GUI</em> i od drobnego
        omówienia środowiska graficznego rozpocznę ten rodział.
      </p>
      <h2 id="2.1.serverwithgui">2.1. Środowisko graficzne RHEL 9</h2>
      <p>
        Red Hat jest dystrybucją Linuksa przeznaczoną do zastosowań
        produkcyjnych, więc system tego typu musi wykazywać się dużą
        stabilnością. Znaczące zmiany są wprowadzane raczej w dużych wydania
        jak RHEL 9, takim znaczącym przeskokiem jest zmiana linii jądra z
        4.18 (w przypadku RHEL 8) na 5.14 (w przypadku RHEL 9) oraz zastąpienie
        klasycznego serwera X Window protokołem Wayland, to jednak nastąpiło z
        wydaniem RHEL 8. Zmiany w RHEL 9, odnośnie środowiska graficznego
        to przejście z Gnome 3.38 na Gnome 40, ta zmiana przyniosła również
        odświerzenie menedżera wyświetlania lub menedżera logowania czym w
        przypadku środowiska Gnome jest GDM. Większość elementów pozostała
        taka sama na górnej belce mamy datę oraz czas w prawyn górnym rogu
        do wyboru opcje ułatwień dostępu, wskaźnik połączenia sieciowego oraz
        porozwinięciu możliwość regulacji głośności i jasności ekranu oraz 
        wyłączenia komputera. Wiecej opcji w tym miejscu będzie dostępne dopiero 
        po zalogowaniu. Będzie można zmienić kilka ustawień jak np. sieć
        bezprzewodwą. Zmianie uległ również sposób prezentacji kont użytkownika.
        Z racji tego iż <em>root</em> nie jest zwykłym użytkownikiem nie będzie
        pojawiać się na liscie, ale zalogowanie na niego jest możliwe za pomocą
        kliknięcia w "Not Listed?" pod listą użytkowników, wówczas będzie mogli
        ręcznie podać nazwę użytkownika oraz hasło. Ekranem startowym po
        zalogowaniu jest ekran <em>Activities</em>, który pozwala na podgląd
        wykonywanych czynności, rozpoczęcie nowych (wybierają aplikacje z 
        z doka lub z pełnej listy aplikacji, która jest dostępna po kliknięciu
        na ikonę 9 kropek w doku) oraz przełacznie się między obszarami
        roboczymi. Domyślnie GNOME daje dostęp do dwóch przestrzeni roboczych,
        gdy tylko przeniesiemy aplikację do na nowy obszar, GNOME udostępni
        nam kolejny i tak dalej. Wyszukiwarka nad podgląd obszaru roboczego
        daje możliwość wyszukiwania nie tylko aplikacji ale także ustawień co
        jest normą w GNOME od wersji 3. Na doku znajdują się ulubione
        aplikacje, które możemy usuwać i dodawać za pomocą PPM i następnie
        wybierając dodaj lub usuń z ulubionych.
      </p>
      <h2 id="2.2.hfs">2.2. Struktura katalogowa w Uniksach</h2>
      <p>
        Zanim jednak przejedziemy do obsługi wiersza poleceń omówimy sobie
        hierachiczną strukturę katalogów, która występuje nie tylko w RHEL ale
        i w innych Uniksach, ponieważ HFS (<em>ang. Hierarchy File System</em>)
        jest ogólnym standardem. Na Uniksach możemy spotkać się z trzema typami
        systemów plików.
      </p>
      <ul>
        <li><strong><em>Disk-based</em> - dyskowe</strong> - są to klasyczne
          pliki i katalogi przechowywane bezpośrednio na dysku.</li>
        <li><strong><em>Network-based</em> - sieciowe</strong> - są to udziały
          podmontowane w naszych systemach za pomocą róznych protokołów, nie
          tylko SMB. Plik <em>network-based</em> są plikami <em>disk-based</em>,
          ale na innych komputerach.</li>
        <li><strong><em>Memory-based</em> - wirtualne</strong> - te systemy
          plików są tworzone przez procesy na potrzeby działania systemu, takim
          systemem może być katalog <em>/dev</em> lub <em>/tmp</em>. Ich
          trwałość często zależy od tego jak długo system pozostaje włączony
          lub od wewnętrznych ustaleń samego systemu.</li>
      </ul>
      <p>
        Struktura plików i katalogów na Uniksach ma postać odwróconego drzewa.
        Korzeń (katalog główny) znajduje się na szczycie struktury i odniego
        rozchodzą się poszczególne gałęzie (podkatalogi), gałęzię mogą zawierać
        kolejne rozgałezienia i tworzyć całe struktury, na gałęziach
        znajdują się również liscie czyli pliki i na liściach struktura się
        kończy.
      </p>
      <p>
        Dostęp do konkretnych plików i katalogów w strukturze określany jest
        za pomocą ścieżek. Scieżki określają położenie plików i katalogów
        wewnątrz HFS.
        Separatorem elementów ścieżki (posczególnych podkatalogów), jest
        ukośnik, slash (<strong>/</strong>).
      </p>
      <p>
        Podczas pracy z elementami jak foldery oraz pliki możemy używać
        <strong>scieżęk bezwzględnych</strong> zaczynające się od
        katalogu głównego, lub <strong>ścieżek względnych</strong>
        zaczynających
        się od elementu znajdującego w obecnym katalogu robocznym
        (tym katalogu, w którym się obecnie znajdujemy).
      </p>
      <p>
        Katalog główny jest miejscem do przechwywania wszystkich plików, jakie
        znajdują się w systemie, jest pierwszy element znajdujący się na
        ścieżce (bezwzględnej) i oznaczny jest on poprostu ukośnikiem
        (<strong>/</strong>), od tego katalogu zaczyna się cała struktura.
        Poniżej znajduje się lista najważniejszych podkatalogów katalogu
        głównego, każdy z nich ma swoje znaczenie w systemie.
      </p>
      <ul>
        <li><strong>/boot</strong> (<em>disk-based</em>) - katalog ten
            przechowuje jądro, <em>initramfs</em> oraz konfiguracje programu
            rozruchowego.</li>
        <li><strong>/dev</strong> (<em>memory-based</em>) - katalog ten
            przechowuje pliki urządzeń służące do odwoływania się do
            rzeczywistego sprzętu podczas komunikacji. Pliki te są tworzone
            przez usługę <em>udevd</em> podczas podłączania urządzenia oraz
            rozruchu systemu.</li>
        <li><strong>/etc</strong> (<em>disk-based</em>) - skrót <em>etc</em>
            możemy rozwinąć do <em>ang. etcetera</em> lub <em>ang. extended
            text configration</em>. Jest to miejsce do przechowywania plików
            konfiguracyjnych różnych programów.</li>
        <li><strong>/home</strong> (<em>disk-based</em>) - ten katalog
            przechowuje, katalogi domowe użytkowników.</li>
        <li><strong>/opt</strong> (<em>disk-based</em>) - katalog przeznaczony
            na dodatkowe oprogramowanie instalowane w systemie.</li>
        <li><strong>/proc</strong> (<em>memory-based</em>) - wirtualna 
            struktura podkatalogów, zawierająca informacje o procesach oraz
            różne informacje o systemie, np. informacje o procesorze.</li>
        <li><strong>/run</strong> (<em>memory-based</em>) - katalog
            przechowywujący pliki wykorzystywane przez procesy podczas
            wykonywania ich czynności. W tym katalogu znajduje się również
            podkatalog <em>media</em> zawierący punkt monotowania automatycznie
            montowanych w systemie dysków wymiennych.</li>
        <li><strong>/sys</strong> (<em>memory-based</em>) - katalog
            przechowuje informacje o urządzeniach, sterownikach. Pewne
            funkcjonalności jądra również są zawarte w tym katalogu. Informacje
            z tego katalogu są używane przez jądro do obsługi urządzeń.</li>
        <li><strong>/tmp</strong> (<em>memory-based</em>) - miejsce 
            przechowywania plików tymczasowych okres przechowywania tych 
            plików to 10 dni, lub ponowne uruchomienie komputera.</li>
        <li><strong>/usr</strong> (<em>disk-based</em>) - skrót <em>usr</em>,
            należy rozwinąć jako <em>ang. UNIX System Resources</em>. Ten
            katalog jest kolejną dużą strukturą katalogów w systemie. W tym
            katalog przechowywane są wszystkie programy, więc wiekszość 
            systemu. Na poniższej liście znajdują się rozpisane podkatalogi
            tego katalogu:
            <ul>
              <li><strong>/usr/bin</strong> - katalog przechowuje większosć
                  plików binarnych, wykorzystywanych w systemie, programów oraz
                  poleceń.</li>
              <li><strong>/usr/sbin</strong> - narzędzia administracyjne
                  niedostępne dla zwykłych użytkowników, poza kilkoma
                  programami. Ten katalog często nie jest ujęty podczas 
                  wyszukiwania poleceń.</li>
              <li><strong>/usr/lib</strong>, <strong>/usr/lib64</strong> - 
                  biblioteki współdzielone oraz pliki statyczne, nie których
                  programów typu init.</li>
              <li><strong>/usr/include</strong> - pliki nagłówkowe języka C</li>
              <li><strong>/usr/local</strong> - miejsce przechowywania
                  zewnętrznych programów instalowanych i
                  wykorzystywanych przez administatorów, ten katalog zawiera w
                  sobie podobną strukturę katalogową jak sam <em>/usr</em>.</li>
              <li><strong>/usr/share</strong> - miejsce przechowywania stron
                  podręcznika, dokumentacji czy przykładowych plików 
                  konfiguracyjnych.</li>
            </ul>
        </li>
        <li><strong>/var</strong> (<em>disk-based</em>) - katalog na zmienne
            dane, katalog podobnie do <em>/usr</em> ma wewnątrz wiele znaczący
            podkatalogów, których opis znajduje się poniżej:
            <ul>
              <li><strong>/var/log</strong> - katalog na pliki dzienników,
                zbierane nie tylko z głównego rejestratora, ale i funkcji
                rejestrowania samych usług.</li>
              <li><strong>/var/opt</strong> - katalog na zmienne dane
                oprogramowania instalowanego w katalogu <em>/opt</em></li>
              <li><strong>/var/spool</strong> - katalog ten przechowuje dane
                zanim zostaną przekazane lub pobrane przez właściwe komponenty.</li>
              <li><strong>/var/tmp</strong> - katalog przechowuje duże pliki
                tymczasowe. Pliki przeżywają uruchomienie ponowne systemu.
                Czas ich istnienia w tym katalog to 30 dni.</li>
            </ul>
        </li>
      </ul>
      <p>
        Za pomocą polecenia <strong>tree</strong>, możemy wyświetlić strukturę
        katalogą w postaci drzewa, jednak najpierw nauczymy się korzystać z
        poleceń w RHEL.
      </p>
      <h2 id="2.3.usingcli">2.3. Obsługa wiersza poleceń i najprostsze 
      polecenia</h2>
      <p>
        Obsługa wiersza poleceń zależy w znacznym stopniu od powłoki, ponieważ
        to ona zajmuj się jego interpretacją i koniec końców wykonaniem
        programu, którego nazwę podaliśmy chcą wykonać polecenie. Aby móc
        skorzystać w RHEL z wiersza poleceń musimy albo uruchomić w środowisku
        graficznym aplikację <strong>Terminal</strong>, lub zalogować się
        zdalnie za pomocą protokołu SSH. Uruchomienie terminala lub zalogowanie
        się przez SSH uruchomi powłokę, która swoją gotowość na otrzymywanie
        poleceń obwieści wyświetleniem <strong>znaku zachęty</strong>.
      </p> 
      <p>
        Znak zachęty jest wskaźnikiem za kursorem po którym możemy wprowadzać 
        do systemu
        polecenia. Kiedyś znaki zachęty były pojedyńczymi znakmi informującymi
        o uprawnieniach z jakimi działa proces powłoki (o tym za chwilę). Teraz
        znaki zwracają nazwę użytkownika, nazwę komputera oraz obecny katalog
        roboczy wewnątrz nawiasu kwadratowego, następnie zanim znajduje się
        znak krzyżyka (<strong>#</strong>) mówiący, że powłoka działa
        uprawnieniami użytkownika <em>root</em> lub symbol dolara 
        (<strong>$</strong>) mówiący, że połoka działa z uprawnieniami zwykłego
        użytkownika. Poniżej przedstawiłem oba znaki:
      </p>
<pre class="code-block">
[root@server1 ~]#

[user@server1 ~]$
</pre>
      <p>
        W różnych dystrybucjach, znak zachęty może różnorako wyglądąć. Możemy
        dostować go do własnych potrzeb, wiele osób korzysta z jak 
        najmniejszych
        znaków zachęty, aby zaoszczedzić miejsce w wierszu polecenia. Teraz
        możemy już wydawać polecenia.
      </p>
      <p>
        Kazde polecenie w jakimkolwiek Uniksie, składa się z nazwy polecenia,
        ewentualnych opcji oraz ewentualnych argumentów. Nie wszystkie
        polecenia do uzyskania żądanych przez nas efektów wymagają opcji czy
        argumentów.  
      </p>
<pre class="code-block">
$ nazwa_polecenia [opcje] [argumenty]
</pre>
      <p>
        Każde polecenie przed zatwierdzeniem możemy edytować, za pomocą
        strzałek lub skrótów klawiszowych dostarczanych przez bibliotekę
        <em>GNU Readline</em>. Więcej na ten temat znajdziemy w internecie.
      </p>
      <p>
        Przez cały kurs będziemy poznawać jakieś polecenia ale w tym momencie
        nauczymy się najprostszych z nich.
      </p>
      <h3 id="2.3.1.ls">2.3.1. Listowanie zawartości katalogu</h3>
      <p>
        Aby wyświetlić zawartość katalogu w powłoce, możemy użyć polecenia
        <strong>ls</strong>. Polecenie bez podania argumentu w postaci
        katalogu wyświetli zawartość folderu, w którym się znajdujemy.
        Najważniejszymi opcjami między innymi są:
      </p>
      <ul>
        <li><strong>-a</strong> - wyświetlanie wszystkich, elementów w katalogu
            także tych, które normalnie nie są wyświetlane (plik i foldery,
            których nazwa rozpoczyna się od kropki).</li>
        <li><strong>-l</strong> - wyświetlenie szczegółowych informacji na
            temat elementów. Informacja zwracana przez polecenie jest wówczas
            podzielona na 9 pól, które kolejno oznaczają: typ pliku oraz
            uprawnienia; liczbę dowiązań; nazwę użytkownika (właściciela pliku);
            nazwę grupy do której należy ten plik; rozmiar w bajtach; czas
            modyfikacji oraz nazwę elementu.</li>
        <li><strong>-ld</strong> - wyświetla szczegółową informacje na temat
            podanego jak argument katalogu, bez wyświetlania jego zawartości.
            Jeśli nie podamy argumentu polecenie wyświetli informacje na temat
            bierzącego katalogu.</li>
        <li><strong>-lh</strong> - wyświetli szczegółowo informacje
            na temat elementów w katalogu, wyświetlając ich rozmiar w
            przeskalowanych wartościach, co ułatwi odczytanie go przez 
            człowieka.</li>
        <li><strong>-lt</strong> - wyświetli szczegółową listę elementów
            posortową względem czasu modyfikacji od najnowszego pliku.</li>
        <li><strong>-ltr</strong> - działanie podobne to <em>-lt</em>, ale
            odwrócone, elementy zostaną wyświetlone od najstarszego.</li>
        <li><strong>-R</strong> - wyświetlenie elementów w sposób 
            rekurencyjny. Polecenie z tą opcją wyświetli zawartość katalogów
            wraz z zawartością ich podkatalogów itd.</li>
      </ul>
      <p>
        Poniżej znajduje się przykład najczęściej wykorzystywanego polecenia
        <em>ls</em> wraz z opcjami:
      </p>
<pre class="code-block">
[root@server1 ~]# ls -al
total 10576
dr-xr-x---. 17 root root    4096 Jun 16 18:49 .
dr-xr-xr-x. 18 root root     235 Jun  9 19:46 ..
-rw-------.  1 root root    1197 Jun  9 19:59 anaconda-ks.cfg
-rw-------.  1 root root    3908 Jun 16 18:50 .bash_history
-rw-r--r--.  1 root root      18 Aug 10  2021 .bash_logout
-rw-r--r--.  1 root root     141 Aug 10  2021 .bash_profile
-rw-r--r--.  1 root root     429 Aug 10  2021 .bashrc
drwxr-xr-x.  3 root root      17 Jun 16 18:14 bzipped
drwx------.  8 root root     120 Jun 13 10:55 .cache
-rw-r--r--.  1 root root      11 Jun 16 13:10 catfile1
drwx------.  9 root root    4096 Jun 13 13:42 .config
-rw-r--r--.  1 root root     100 Aug 10  2021 .cshrc
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Desktop
drwxr-xr-x.  4 root root      30 Jun 16 16:44 dir20
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Documents
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Downloads
drwxr-xr-x.  3 root root      55 Jun 16 11:34 etc
-rw-r--r--.  1 root root 4986788 Jun 16 18:13 etc-bzipped.tar.bz2
-rw-r--r--.  1 root root 5772869 Jun 16 18:12 etc-gzipped.tar.gz
-rw-r--r--.  2 root root       0 Jun 16 17:26 file10
-rw-r--r--.  2 root root       0 Jun 16 17:26 file20
-rw-r--r--.  1 root root     579 Jun 16 11:07 fstab
drwxr-xr-x.  3 root root      17 Jun 16 18:14 gzipped
-rw-------.  1 root root      42 Jun 16 18:22 .lesshst
drwx------.  3 root root      19 Jun 13 10:55 .local
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Music
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Pictures
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Public
lrwxrwxrwx.  1 root root       6 Jun 16 17:30 soft10 -&gt; file10
-rw-r--r--.  1 root root     129 Aug 10  2021 .tcshrc
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Templates
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Videos
-rw-------.  1 root root    8264 Jun 16 18:38 .viminfo
-rw-r--r--.  1 root root     464 Jun 16 18:38 vipractice
</pre>
      <p>
        Podczas korzystania z wielu programów możemy natknąć się na wiele opcji.
        Dzielą się one na długie i krótkie, opcje krótkie występują w
        postaci pojedyńczego znaku poprzedzonego jednym myślnikiem
        (<strong>-</strong>). Opcje długie występuje w postaci pojedyńczego
        (najczęsciej, ponieważ to zależy od programu) słowa poprzedzonego dwoma 
        myślnikami (<strong>--</strong>). W przypadku tak prostych poleceń jak
        <em>ls</em> również możemy użyć długich opcji np. zamiast
        <em>-a</em> możemy użyć <em>--all</em>.
      </p>
      <h3 id="2.3.2.pwd">2.3.2. Wyświetlenie bierzącego katalogu roboczego</h3>
      <p>
        Na pierwszy rzut oka mogłoby się wydawać po co nam to polecenie,
        skoro w znaku zachęty na RHEL jest wyświetlona nazwa bierzącego
        katalogu. Polecenie <strong>pwd</strong> wyświetla ścieżkę bezwzględną 
        do bierzącego katalogu, a po drugie to polecenie ma bardzo ważną cechę
        związaną z dowiązaniami, ale o tym będzie przy dowiązaniach. Do
        normalnych zastosować <em>pwd</em> nie potrzebuje żadnej opcji, ani
        żadnego argumentu.
      </p>
<pre class="code-block">
[root@server1 ~]# pwd
/root
</pre>
      <h3 id="2.3.3.cd">2.3.3. Poruszanie się wśrod katalogów</h3>
      <p>
        Generalnie do zmiany bierzącego katalogu, czy przejścia z/do 
        innego katalogu służy polecenie <strong>cd</strong>. Pozwala on na
        kilka sztuczek.
      </p>
      <ul>
        <li>Powrót do katalogu domowowego nie wymaga przy tym poleceniu żadnego
          argumentu ani opcji, wystarczy wydać polecenie <em>cd</em>.</li>
        <li>Polecenie zapamiętuje poprzedni katalog roboczy i powrót do niego
          wymaga podania polceniu <em>cd</em> myślnika (<strong>-</strong>)
          jako argumentu</li>
        <li>W ścieżka chcąć skrócić sobie pisanie, możemy użyć tyldy
          (<strong>~</strong>) jako przedstawienia katalogu domowego.</li>
        <li>Chcąc przenieść się do katalogu nadrzędnego względem bierzącego
          nie musimy znać jego nazyw wystarczy że poleceniu <em>cd</em> podamy
          dwie kropki (<strong>..</strong>)</li>
      </ul>
      <p>
        Poniżej zamieściłem przykłady kilku z nich.
      </p>
<pre class="code-block">
[root@server1 ~]# cd -
/home/user
[root@server1 user]# cd ..
[root@server1 home]# cd 
</pre>
      <h3 id="2.3.4.tty">2.3.4. Identyfikacja urządzenia terminala</h3>
      <p>
        Czasmi może zajść potrzeba zidentyfikowania własnego urządania 
        terminalowego służy do tego polecenie <strong>tty</strong>. Jeśli 
        wynikiem działania tego polecenie będzie <em>/dev/pts*</em> oznacza to,
        że korzystamy z emulatora terminala np. programu Terminal w środowisku
        GNOME lub połączenia zdalnego za pomocą protokołu SSH. 
        Jeśli naszę urządzenie to <em>/dev/tty*</em> oznacza to, że
        korzystamy z jednej wirtualnych konsol dostępnych na komputerze.
      </p>
<pre class="code-block">
[root@server1 ~]# tty
/dev/pts/0
</pre>
      <h3 id="2.3.5.uptime">2.3.5. Czas systemowy oraz załadowanie procesora</h3>
      <p>
        W większości dostępnych Uniksów zapewne dostępne będzie polecenie 
        <strong>uptime</strong>. To niepozorne polecenie zawraca dużą ilość
        informacji.
      </p>
      <ul>
        <li>Czas systemowy,</li>
        <li>Ilość czasu jaka upłyneła od uruchomienia systemu (tzw. 
            <em>uptime</em>),</li>
        <li>Ilość zalogowanych do systemu użytkowników,</li>
        <li>Średnie załadowanie procesora w przeciągu minuty, 5 i 15 minut, ta
            wartość pokazuje zużycie procesora, podając wartości ułamkowe jeśli
            np. w ciągu jednej minuty jeden z wątków procesora był wykorzystany
            w 50% otrzymamy wynik 0.50. Jeśli posiadamy procesor wielordzeniowy, 
            ten wskaźnik może
            wskazywać wartości powyżej 1, oznacza to że procesy wykorzystują
            już więcej niż jeden wątęk/rdzeń.</li>.
      </ul>
<pre class="code-block">
[root@server1 ~]# uptime
 13:28:40 up 8 min,  1 user,  load average: 0.00, 0.12, 0.12
</pre>
      <h3 id="2.3.6.clear">2.3.6. Czyszczenie ekranu powłoki</h3>
      <p>
        Do czyszczenia terminala ze zbędnego wyjścia poleceń służy polcenie
        <strong>clear</strong> lub kombinacja klawiszy <em>CTRL+l</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# clear
</pre>
      <h3 id="2.3.7.which">2.3.7. Określanie ścieżki polecenia</h3>
      <p>
        Czasami w pewnych konfiguracjach lub też w skryptach powłoki niezbędne
        będzie podanie ścieżki do konkretnego programu kryjącego się za nazwą
        polecenia, w RHEL możemy zrobić to na trzy sposoby wykorzystując do
        tego różne polecenia. Polecenia podałem w przykładzie w raz z
        informacją zwracaną przez polecenie.
      </p>
<pre class="code-block">
$ which ls
alias ls='ls --color=auto'
	/usr/bin/ls

$ whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz

$ type ls
ls jest aliasem do ls --color=auto'
</pre>
      <p>
        Które z tych poleceń będzie właściwe to już zależy, do czego będą nam
        potrzebne tego typu informacje. Polecenie <em>whereis</em> wydaje się
        szczególnie pomocne.
      </p>
      <h3 id="2.3.8.uname">2.3.8. Wyświetlenie informacji o systemie</h3>
      <p>
        Polecenie <strong>uname</strong>, należy do poleceń, które są dość
        niepozorne, ale za pomocą jego opcji możemy otrzymać wersję użytego
        jądra, archtekturę systemu i tym podobne informacje. Polecenie bez 
        podania
        żadnej z opcji zwraca wyłącznie nazwę systemu i jest to <em>Linux</em>.
        Aby otrzymać wszelkie zwracane przez to polecenie informacje możemy 
        użyć opcji <em>-a</em>. Resztę opcji znajdziemy na stronach
        podręcznika (o tym będzie w dalszej częście materiału).
      </p>
<pre class="code-block">
$ uname -a 
Linux latitude-e5270 5.14.0-70.13.1.el9_0.x86_64 #1 SMP PREEMPT Thu Apr 14 12:42:38 EDT 2022 x86_64 x86_64 x86_64 GNU/Linux
</pre>
      <h3 id="2.3.9.lscpu">2.3.9. Wyświetlanie informacji o procesorze</h3>
      <p>
        W RHEL możemy łatwo sprawdzić informacje na temat zainstalowanego w
        naszym komputerze procesora w przystępny sposób. Do dyspozycji mamy
        bowiem polecenie <strong>lscpu</strong>. Wyświetla ono wszystkie
        dostępne informacje jakie może znaleźć w systemie na temat tego
        komponentu.
      </p>
<pre class="code-block">
[root@server1 ~]# lscpu
Architecture:            x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Address sizes:         39 bits physical, 48 bits virtual
  Byte Order:            Little Endian
CPU(s):                  1
  On-line CPU(s) list:   0
Vendor ID:               GenuineIntel
  Model name:            Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
    CPU family:          6
    Model:               78
    Thread(s) per core:  1
    Core(s) per socket:  1
    Socket(s):           1
    Stepping:            3
    BogoMIPS:            5004.62
    Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush
                          mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology
                          nonstop_tsc cpuid tsc_known_freq pni pclmulqdq monitor ssse3 cx16 pcid sse4_1 
                         sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm 3dnowpre
                         fetch invpcid_single pti fsgsbase avx2 invpcid rdseed clflushopt md_clear flush
                         _l1d
Virtualization features: 
  Hypervisor vendor:     KVM
  Virtualization type:   full
Caches (sum of all):     
  L1d:                   32 KiB (1 instance)
  L1i:                   32 KiB (1 instance)
  L2:                    256 KiB (1 instance)
  L3:                    3 MiB (1 instance)
NUMA:                    
  NUMA node(s):          1
  NUMA node0 CPU(s):     0
Vulnerabilities:         
  Itlb multihit:         KVM: Mitigation: VMX unsupported
  L1tf:                  Mitigation; PTE Inversion
  Mds:                   Mitigation; Clear CPU buffers; SMT Host state unknown
  Meltdown:              Mitigation; PTI
  Spec store bypass:     Vulnerable
  Spectre v1:            Mitigation; usercopy/swapgs barriers and __user pointer sanitization
  Spectre v2:            Mitigation; Retpolines, STIBP disabled, RSB filling
  Srbds:                 Unknown: Dependent on hypervisor status
  Tsx async abort:       Not affected
</pre>
      <h2 id="2.4.gettinghelp">2.4. Uzyskiwanie pomocy</h2>
      <h3 id="2.4.1.manpages">2.4.1. Strony podręcznika</h3>
      <p>
        W dystrybucjach Linuksa nie tylko w RHEL możemy znaleźć duża bazę
        zawierającą opisy poleceń, plików konfiguracyjnych oraz innych
        komponentów takich jak biblioteki. Służą temu strony podręcznika. Aby
        uzyskać do nich dostęp wystarczy wydać polecenie <strong>man</strong>
        podając jako argument interesujący na komponent. Nie zawsze musi być
        to polecenie. Strony podręcznika są podzielone na rozdziały czy też
        sekcje ich opisy oraz numery sa zawarte w na (o ironio) stronie
        podręcznika polecenia <em>man</em>. Wydaj poniższe polecenie aby
        zapoznać się z nim oraz z ich organizacją.
      </p>
<pre class="code-block">
$ man man
</pre>
      <p>
        Różne komponenty na Linuksie mogą mieć takie same nazwy. Polecenie
        <em>man</em> zwraca pierwsze znalezione wystąpienie, jeśli wpiszemy
        polecenie <code class="code-inline">man passwd</code> to otrzymamy
        informacje na temat polecenia, ale jeśli interesowałoby nas poznanie
        szczegółów pliku <em>/etc/passwd</em> musimy podać przed nazwą, numer
        sekcji odpowiedzialny za pliki konfiguracyjne.
      </p>
<pre class="code-block">
$ man 5 passwd
</pre>
      <p>
        Strony podręcznika, możemy przeszukiwać pod kątem występowania słów
        kluczowych, w przypadku kiedy znamy zagadnienie ale nie znamy
        odpowiedniego polecenia. Do tego celu możemy użyć opcji <em>-k</em>
        polecenia <em>man</em> lub polecenia <strong>apropos</strong>. Wynik 
        działania tych programów jest taki sam.
      </p>
<pre class="code-block">
$ apropos dos
dos2unix (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
mac2unix (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
unix2dos (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
unix2mac (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
dosfsck (8)          - check and repair MS-DOS FAT filesystems
dosfslabel (8)       - set or get MS-DOS filesystem label or volume ID
fatlabel (8)         - set or get MS-DOS filesystem label or volume ID
filesystems (5)      - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdo...
fs (5)               - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdo...
fsck.fat (8)         - check and repair MS-DOS FAT filesystems
fsck.msdos (8)       - check and repair MS-DOS FAT filesystems
fsck.vfat (8)        - check and repair MS-DOS FAT filesystems
mkdosfs (8)          - create an MS-DOS FAT filesystem
mkfs.fat (8)         - create an MS-DOS FAT filesystem
mkfs.msdos (8)       - create an MS-DOS FAT filesystem
mkfs.vfat (8)        - create an MS-DOS FAT filesystem
vdosetuuid (8)       - sets a new uuid for the vdo volume stored on a backing store
vdostats (8)         - Display configuration and statistics of VDO volumes
</pre>
      <p>
        W pierwszej kolumnie znajduje się nazwa komponentu, w drugiej numer
        sekcji a następnie krótki opis.
      </p>
      <p>
        Szukając opisu polecenia możemy posiłkować się poleceniem 
        <strong>whatis</strong>. Polecenie to poszukuje konkretnego komponentu
        na stronach podręcznika, a nie słowa kluczowego.
      </p>
<pre class="code-block">
$ whatis xdg-open 
xdg-open (1)         - opens a file or URL in the user's preferred application
</pre>
      <p>
        Polecenie <em>whatis</em>, zachowuje się identycznie jak polecenie
        <em>man</em> z opcją <em>-f</em>.
      </p>
      <h3 id="2.4.2.helpincommand">2.4.2. Pomoc w samym poleceniu</h3>
      <p>
        Inny sposobem niż wertowanie stron podręcznika w celu znalezienia
        odpowiedniej opcji jest po prostu wywołanie polecenie a opcją
        <strong>--help</strong>.
      </p>
<pre class="code-block">
$ ranger --help
Usage: ranger [options] [path]

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -d, --debug           activate debug mode
  -c, --clean           don't touch/require any config files.
  --logfile=file        log file to use, '-' for stderr
  --cachedir=dir        change the cache directory.
                        (/home/xf0r3m/.cache/ranger)
  -r dir, --confdir=dir
                        change the configuration directory.
                        (/home/xf0r3m/.config/ranger)
  --datadir=dir         change the data directory.
                        (/home/xf0r3m/.local/share/ranger)
  --copy-config=which   copy the default configs to the local config
                        directory. Possible values: all, rc, rifle, commands,
                        commands_full, scope
  --choosefile=OUTFILE  Makes ranger act like a file chooser. When opening a
                        file, it will quit and write the name of the selected
                        file to OUTFILE.
  --choosefiles=OUTFILE
                        Makes ranger act like a file chooser for multiple
                        files at once. When opening a file, it will quit and
                        write the name of all selected files to OUTFILE.
  --choosedir=OUTFILE   Makes ranger act like a directory chooser. When ranger
                        quits, it will write the name of the last visited
                        directory to OUTFILE
  --selectfile=filepath
                        Open ranger with supplied file selected.
  --show-only-dirs      Show only directories, no files or links
  --list-unused-keys    List common keys which are not bound to any action.
  --list-tagged-files=tag
                        List all files which are tagged with the given tag,
                        default: *
  --profile             Print statistics of CPU usage on exit.
  --cmd=COMMAND         Execute COMMAND after the configuration has been read.
                        Use this option multiple times to run multiple
                        commands.
</pre>
      <p>
        Posiadanie tej opcji nie jest standardem, wiec nie wszystkie polecenia
        będą ją mieć.
      </p>
      <h3 id="2.4.3.texinfo">2.4.3. Dokumentacja texinfo</h3>
      <p>
        Projekt GNU, zaproponował zmianę formatu dokumentacji programów, z
        suchych stron podręcznika do dokumentów przypominających ksiązkę lub
        inne dokumenty. Strony podręcznika nadal są podstawowym i wybudowanym
        (w większość dystrybcji) źródłem  wiedzy na temat systemu i jego 
        komponentów. 
        Nie mniej jednak jeśli uznamy, że zawartość strony podręcznika nie jest
        dla zadowalająca może spojrzeć też tam, o ile ten format jest
        zainstalowany w naszym systemie. Dostęp do niego uzyskujemy za pomocą
        polecenia <strong>info</strong> lub <strong>pinfo</strong>, następnie
        podając nazwę polecenia jako argument. Wydając samo polecenie
        <em>info</em>, możemy zobaczyć ile dokumentacji w formacie
        <em>texinfo</em> znajduje się w systemie.
      </p>
      <h3 id="2.4.4.usrsharedoc">2.4.4. /usr/share/doc</h3>
      <p>
        Innym miejscem przechowującym jakieś informacje na temat poleceń czy
        też programów może być katalog <em>/usr/share/doc</em>. Możemy w nim
        znaleźć na przykład domyślne plik konfiguracyjne wielu usług 
        (oczywiście zależy to czy zostaną one dodany do paczek z 
        oprogramowaniem). Nie należy jednak
        od razu skreślać tego katalogu, często mogą znajdować się tam
        informacje, których nie znajdziemy na stronach podręcznika czy w
        formacie <em>info</em> np. tutoriale lub gotowe konfiguracje.
      </p>
      <h3 id="2.4.5.rhdocs">2.4.5. Dokumentacja Red Hat Enterprise Linux</h3>
      <p>
        Innym źródłem informacji na temat obsługi systemu jest dokumentacja
        Red Hat dostępna w internecie (dla RHEL 9) pod tym adresem:
        <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9</a>
      </p>
      <p>
        Każdy zebranych tam tematów możemy pobrać w formacie HTML, PDF oraz
        ePub (czytniki e-booków).
      </p>
      <p class="exam_tip">
        <strong>Odnośnie egzaminu:</strong><br />
        Na egzaminie możemy korzystać ze wszystkiego co jest dostępne w systemie
        warto pamiętać o tym. Jeśli będziemy mieć problemy z poleceniem
        <em>man</em>, warto wydać polecenie <strong>mandb</strong> odświeży
        to bazę danych stron podręcznika.
      </p>
      <h3 id="exec2.1">Ćwiczenie 1: Nawigacja pośród katalogów Linuksa</h3>
      <p>
        Jako zwykły użytkownik na maszynie wirtualnej <em>server1</em>, 
        wyświetl ścieżkę na której
        się znajdujesz. W tym samym katalogu wyświetl wszystkie pliki.
        Przjedź do katalogu <em>/etc</em> następnie wyświetl ścieżkę, na której
        się znajdujesz, następnie powróć do poprzedniego katalogu i jeszcze
        raz wyświetl ścieżkę.
      </p>
      <h3 id="exec2.2">Ćwiczenie 2: Rożne zadania</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em> w terminalu 
        polecenie <em>tty</em>.
        Następnie uruchom kilka kart terminala wydaj w nich to samo polecenie
        i porównaj zwracane wartości. Wyświetl czas pracy systemu oraz 
        średnie obciążenie procesora. Za pomocą trzech poznanych poleceń 
        wyświetl lokalizacje polecenia <em>vgs</em>.
      </p>
      <h3 id="exec2.3">Ćwiczenie 3: Informacje o systemie</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em>
        za pomocą poznanego polecenia wyświetl wszystkie informacje o systemie
        (oczywście w miarę możliwości polecenia). Następnie użyj innego
        polecenia aby sprawdzić informacje na temat zainstalowanego w
        komputerze procesora.
      </p>
      <h3 id="exec2.4">Ćwiczenie 4: Używanie pomocy</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em>
        Wyświetl stronę podręcznika polecenia <em>uname</em> oraz stronę
        podręcznika dla pliku <em>/etc/shadow</em>. Wykonaj trzy polecenia:
        <code class="code-inline">apropos ext4</code>,
        <code class="code-inline">man -k ext4</code>,
        <code class="code-inline">whatis group</code>. Czym różnią się
        informacje zwracane przez te polecenia?
      </p>
      <h2 id="ch2summary">Podsumowanie</h2>
      <p>
        W tym rozdziale skupiliśmy się na podstawach obsługi systemu,
        poznaliśmy środowisko graficzne. Odświerzyliśmy sobie informacje na
        temat hierachicznego systemu plików wykorzystywanego w Uniksach.
        Zapoznaliśmy się z terminalem i podstawowymi polecenia. Na koniec
        dowiedzieliśmy się gdzie możemy szukać pomocy na temat poleceń, plików
        konfiguracyjnych i tego typu rzeczy.
      </p>
		</div>
	  <p style="margin: 15px; padding: 0; outline: 0;">
				2022; COPYLEFT; ALL RIGHTS REVERSED;
		</p>
	</body>
</html>
