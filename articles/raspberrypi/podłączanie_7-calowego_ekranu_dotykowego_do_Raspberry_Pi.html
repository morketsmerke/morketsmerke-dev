<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<style>
			.code-block {
				display: block;
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
			}
			.code-inline {
				background-color: silver;
				font-family: monospace;

				font-weight: bolder;
			}
			p { text-align: justify; }
		</style>
	</head>
	<body style="font-family: monospace;" >
		<pre>
		<span style="color: green;">     .~~.   .~~.
		    '. \ ' ' / .'</span>
		<span style="color: red;">     .~ .~~~..~.</span>                       _                          _
		<span style="color: red;">    : .~.'~'.~. :</span>      ___ ___ ___ ___| |_ ___ ___ ___ _ _    ___|_|
		<span style="color: red;">   ~ (   ) (   ) ~</span>    |  _| .'|_ -| . | . | -_|  _|  _| | |  | . | |
		<span style="color: red;">  ( : '~'.~.'~' : )</span>   |_| |__,|___|  _|___|___|_| |_| |_  |  |  _|_|
		<span style="color: red;">   ~ .~ (   ) ~. ~</span>                |_|                 |___|  |_|
		<span style="color: red">    (  : '~' :  )</span>
		<span style="color: red;">     '~ .~~~. ~'
			 '~'</span>
		</pre>

	<p style="margin: 15px; padding: 0; outline: 0; font-size: 18pt;">
		&#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
	</p>

	<div style="margin-left: auto; margin-right: auto; width: 80%;">
    <h1 style="text-align:center;">Podłączanie 7-calowego (1024 x 600) ekranu dotykowego do Raspberry Pi</h1>
    <p>
      W długi weekend majowy, kolega poprosił mnie podłączenie 7-calowego
      wyświetlacza do Raspberry Pi. Oczywiście przez podłączenie należy
      rozumieć fizczne podłączenie oraz skonfigurowanie systemu w taki sposób,
      aby Raspberry wyświetlało na nim prawidłowo obraz, w optymalnej dla
      ekranu rozdzielczości. Mój zleceniodawca utknął przy ładowaniu środowiska
      graficznego. Po powrocie do pracy, wziąłem od niego wyświetlacz i
      przystąpiłem do działania, nie brałem jego maliny ponieważ chciałem
      na początku sam dowiedzieć się jak to się podłącza. Na naprawę jego
      konfiguracji przyjdzie jeszcze czas...
    </p>
    <p>
      Jak każdą świeżą zabawę z malinką, rozpocznam do pobrania najnowszego
      obrazu i załadowania go na kartę microSD. Dla celów testowych, najlepiej
      użyć obrazu z preinstalowanym środowiskiem graficznym, najlepiej bez
      zbędnego (rekomendowanego) oprogramowania.
    </p>
<pre class="code-block">
  $ wget https://downloads.raspberrypi.org/raspios_armhf/images/raspios_armhf-2022-04-07/2022-04-04-raspios-bullseye-armhf.img.xz
  $ unxz 2022-04-04-raspios-bullseye-armhf.img.xz
  $ sudo dd if=2022-04-04-raspios-bullseye-armhf.img bs=1M of=/dev/sdX status=progress
</pre>
    <p>
      Gdzie <code class="code-inline">/dev/sdX</code> jest plikiem urządzenia
      reprezentującym podłączoną kartę microSD. Obraz po rozpakowaniu ma lekko
      powyżej 4GB. Po nagraniu obrazu zanim włóżymy kartę do urządzenia, możemy
      już dokonać niezbędnych modyfikacji, tak aby na tym wczesnym etapie nasz
      ekran już zaczął wyświetlać jakiś obraz. Zmian w pliku dokonujemy
      w pliku <em>config.txt</em> partycji <em>boot</em>, korzystającej z
      systemu plków FAT-32. Na samym końcu pliku zapisujemy poniższe linie.
    </p>
<pre class="code-block">
max_usb_current=1
hdmi_group=2
hdmi_mode=87
hdmi_cvt=1024 600 60 6 0 0 0
hdmi_ignore_edid=0xa5000080
config_hdmi_boost=2
</pre>
    <ul>
      <li><code class="code-inline">max_usb_current</code> - załączenie
        maksymalnego możliwego natężenia prądu na USB. Normalnie jest 600 mA,
        jednak przy użyciu tej opcji, prąd wzrasata do 1,2 A.</li>
      <li><code class="code-inline">hdmi_group</code> - określa grupę
        wyświetlaczy korzystających z HDMI. Na przykład telewizory oraz
        monitory korzystają zupełnie innych standardów. Jednak nie musimy się
        tym przejmować ponieważ ta opcja oraz opcja poniżej służą jedynie
        umożliwieniu użycia opcji <code class="code-inline">hdmi_cvt</code>.</li>
      <li><code class="code-inline">hdmi_mode</code> - definiuje domyślną
        rodzielczość, odświeżanie oraz aspekt ekranu, jak będziemy mogli
        zauważyć tryb <code class="code-inline">87</code> znajduje się w poza
        tabelą (link na końcu artykułu), służy on jedynie umożliwieniu
        ręcznego ustawienia powyższych cech obrazu aby były prawidłowo
        wyświelane na podłączonym ekranie.</li>
      <li><code class="code-inline">hdmi_cvt</code> - umożliwia wpisanie
        własnych ustawień obrazu, dając możliwość zedefiniowania rozdzielczości,
        częstotliwości obrazu oraz jego formatu. Pozostałe trzy zera odnoszą
        się głównie do cech ekranów kineskopowych i mogą zostać pominięte,
        ponieważ są one domyślną wartość. Warto dodać że ta opcja utworzy
        tryb hdmi <code class="code-inline">87</code>.</li>
      <li><code class="code-inline">hdmi_ignore_edid</code> - opcją załącza
        ignorowanie danych identyfikacyjnych wyświetlacza, jeśli wyświetlacz
        ich nie posiada. Użycie wartości <code class="code-inline">0xa5000080</code>
        chroni tę opcję przed omyłkowym przełączeniem.</li>
      <li><code class="code-inline">config_hdmi_boost</code> - złacza
        wzmocnienie sygnału HDMI. Ta wartość jest ignorowana przez Raspberry
        Pi 4. W źródle podano konkretne przypadki, który należy użyć
        odpowiednich wartości tej opcji.</li>
    </ul>
    <p>
      Zapisujemy zmiany w pliku. Teraz możemy włożyć kartę do maliny a
      następnie podłączyć nasz wyświetlacz. 7-calowych wyświetlaczy do RPi jest
      dostępnych na rynku bardzo wiele, różnią się one rodzielczością oraz 
      ilością dostępnych złączy. Część z nich to po prostu chińskie klony
      oryginalnego produktu marki <em>WaveShare</em>, i ja również otrzymałem
      taki klon. Głowną różnicą są chyba złącza znajdujące się z tyłu
      wyświetlacza. Wyświetlacz, który ja otrzymałem wyglądał mniej więcej tak: 
    </p>
    <p>
      <img src="https://i.ibb.co/h7RDQLh/7-inch-display.jpg" alt="7-inch-display" border="0">
    </p>
    <p>
      Mniej więcej, ponieważ zdjęcia nie zrobiłem. A obrazek powyżej jest tylko
      zdjęciem poglądowym. Oryginalny wyświetlacz 7-calowy firmwy 
      <em>WaveShare</em> wygląda identycznie jak ten, przedstawiony w ramce
      oznaczonej <em>7"</em>.
    </p>
    <p>
      <img src="https://i.ibb.co/QXsmbDv/RPi-LCD-Anti-Piracy-l.jpg" alt="RPi-LCD-Anti-Piracy-l" border="0">
    </p>
    <p>
      Istotną w naszym przypadku różnicą są złącza. W oryginalny wyświetlacz
      mamy tylko jedno złącze USB, natomiast w klonie dwa i oba podpisane jako
      "<em>touch</em>". Więc jeśli dysonujemy klonem<strong>Kabel USB 
      podłączamy po <u>drugiego</u> portu USB, nad przełącznikiem 
      "<em>backlight</em>"</strong>. Z HDMI to chyba wiadomo. Po podłączeniu
      możemy uruchomić Raspberry. Po nieco dłuższym procesie uruchamiania,
      na wyświetlaczu pojawi się fragment obrazu. Obraz wyświetlany przez
      system operacyjny jest w znaczanie większej rozdzielczości niż
      obsługiwana przez wyświetlacz. Serwer X Window, nie był wstanie dobrać
      odpowiedniej rozdzielczości dlatego też musimy ją wymusić. Aby to zrobić
      tworzymy mały skrypt powłoki z poniższych poleceń. Jednak przed
      przystąpieniem do pisania skryptu należy jeszcze poznać nazwę wyjścia
      wideo jaka figuruje na serwerze X Window, za pomocą polecenia
      <strong>xrandr</strong> jesteśmy w stanie wypisać dostępe w systemie
      wyjścia wideo, nazwy znajdują się na początku linii nad listą dostępnych
      rozdzielczości dla danego wyświetlacza. W moim przypadku było to HDMI-2.
    </p>
<pre class="code-block">
#!/bin/bash

xrandr --newmode "1024x600_60.00" 49.00 1024 1072 1168 1312 600 603 613 624 -hsync +vsync
xrandr --addmode HDMI-2 1024x600_60.00
xrandr --output HDMI-2 --mode 1024x60_60.00
</pre>
    <p>
      Wartości użyte w poleceniu <code class="code-inline">xrandr --newmode</code>
      zostały uzyskane za pomocą poniższego polecenia.
    </p>
<pre class="code-block">
$ cvt 1024 600 60
</pre>
    <p>
      Polecenie to generuje ustawienia obrazu w standardzie <em>VESA CVT</em>,
      które są niezbędne przy tworzeniu niestandardowych trybów wyświetlania.
      Niestety aby wyjaśnić kolejne wartości zwracane przez to polecenie,
      trzeby by zagłegić się w lekturę standardu, co wykracza poza ramy tego
      materiału. Najlepiej jest poprostu skopiować fragment wyjścia polecenia
      <code class="code-inline">cvt</code>, do argumenty polecenia
      <code class="code-inline">xrandr --newmode</code>.
    </p>
    <p>
      Skrypt zapisujemy pod wygodną dla nas nazwą, w miejscu gdzie nie zostanie
      przypadkowo usunięty. Następnie, musimy zmusić system do tego aby
      uruchomił on ten skrypt przed wyświetleniem użytkownikowi pulpitu. Do
      tego posłużymy się plikiem <em>/etc/xdg/lxsession/LXDE-pi/autostart</em>.
      Nad linią <em>@xscreensaver -no-splash</em> zapisujemy poniższą linię:
    </p> 
<pre class="code-block">
@lxterminal -e "&lt;ścieżka_do_skryptu&gt;"
</pre>
    <p>
      Następnie zapisujemy zmiany, dla pewności możemy przekopiować również
      ten plik do katalogu <em>/etc/xdg/lxsession/LXDE</em>, aby mieć pewność,
      że na pewno się uruchomi.
    </p>
    <p>
      Źródła:
      <ol>
        <li><a href="https://www.youtube.com/watch?v=TYzOhgUmZcw">Konfiguracja wyświetlania obrazu w pliku config.txt</a></li>
        <li><a href="https://www.raspberrypi.com/documentation/computers/config_txt.html">Opis opcji z konfiguracji pliku /boot/config.txt</a></li>
        <li><a href="https://ronboelectronics.en.made-in-china.com/product/usynxqbMlFkW/China-Capacitive-Touch-7-0-Inch-1024X600-HDMI-LCD-Monitor-Panel-with-Driver-Board-for-Raspberry-Pi-PC-Monitor.html">Zdjęcie chińskiego klona wyświetlacza WaveShare</a></li>
        <li><a href="https://www.waveshare.com/wiki/7inch_HDMI_LCD_(C)">Zdjęcie przedstawiające między innymi oryginalny wyświetlacz</a></li>
      </ol>
    </p>
    <p>
      ~xf0r3m
    </p>
	</div>
		<p style="margin: 15px; padding: 0; outline: 0;">
			2021; COPYLEFT; ALL RIGHTS REVERSED;
		</p>

	</body>
	</html>
