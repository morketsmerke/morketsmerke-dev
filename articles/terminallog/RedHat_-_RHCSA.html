<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<style>
			.code-block {
				display: block;
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
				text-align: left;
			}
			.code-inline {
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
			}
			ul {
				text-align: left;
			}
      .toc {
        list-style-type: none;
      }
      p {
        text-align: justify;
      }
      .exam_tip {
        border: solid 1px black;
      }
		</style>
	</head>
	<body style="font-family: monospace;" >
<pre>
 ____          _ _   _       _   
|  _ \ ___  __| | | | | __ _| |_ 
| |_) / _ \/ _` | |_| |/ _` | __|
|  _ &lt;  __/ (_| |  _  | (_| | |_ 
|_| \_\___|\__,_|_| |_|\__,_|\__|
                                 
</pre>
    <p style="margin: 0; padding: 0; outline: 0; font-size: 18pt;">
	    &#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
    </p>
		<div style="margin-left: auto; margin-right: auto; width: 80%;">
      <h1 style="text-align: center;">RedHat - Red Hat Certified System 
        Administrator 9</h1>
      <h2>Spis treści</h2>
      <ul class="toc">
        <li><a href="#1.introduction">1. Wstęp</a>
          <ul class="toc">
            <li><a href="#1.1.exam">1.1. Egzamin</a></li>
            <li><a href="#1.2.examobjectives">1.2. Zagadnienia</a></li>
            <li><a href="#1.3.exampreparation">1.3. Przygotowania</a>
              <ul class="toc">
                <li><a href="#1.3.1.vboxinstallationonrhel">1.3.1. Instalacja Oracle VirtualBox na RHEL 8.6.</a></li>
                <li><a href="#1.3.2.gettingrheliso">1.3.2. Pozyskiwanie obrazu ISO z Red Hat Enterprise Linux 9</a></li>
                <li><a href="#1.3.3.createvmwithrhel">1.3.3. Tworzenie maszyn wirtualnych VirtualBox z RHEL</a></li>
                <li><a href="#1.3.4.rhelinstallation">1.3.4. Instalacja Red Hat Enterprise Linux 9.0</a></li>
              </ul> 
            <li><a href="#exec1.1">Ćwiczenie: 1-1</a></li>
            <li><a href="#exec1.2">Ćwiczenie: 1-2</a></li>
            <li><a href="#ch1summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#2.firststepsinRHEL9">2. Poruszanie się po systemie RHEL 9</a>
          <ul class="toc">
            <li><a href="#2.1.serverwithgui">2.1. Środowisko graficzne RHEL 9</a></li>
            <li><a href="#2.2.hfs">2.2. Struktura katalogowa w Uniksach</a></li>
            <li><a href="#2.3.usingcli">2.3. Obsługa wiersza poleceń i najprostsze polecenia</a>
              <ul class="toc">
                <li><a href="#2.3.1.ls">2.3.1. Listowanie zawartości katalogu</a></li>
                <li><a href="#2.3.2.pwd">2.3.2. Wyświetlanie bierzącego katalogu</a></li>
                <li><a href="#2.3.3.cd">2.3.3. Poruszanie się wśród katalogów</a></li>
                <li><a href="#2.3.4.tty">2.3.4. Identyfikacja urządzenia terminala</a></li>
                <li><a href="#2.3.5.uptime">2.3.5. Czas systemowy oraz załadowanie procesora</a></li>
                <li><a href="#2.3.6.clear">2.3.6. Czyszczenie ekranu powłoki</a></li>
                <li><a href="#2.3.7.which">2.3.7. Określanie ścieżki polecenia</a></li>
                <li><a href="#2.3.8.uname">2.3.8. Wyświetlenie informacji o systemie</a></li>
                <li><a href="#2.3.9.lscpu">2.3.9. Wyświetlenie informacji o procesorze</a></li>
              </ul>
            </li>
            <li><a href="#2.4.gettinghelp">2.4. Uzyskiwanie pomocy</a>
              <ul class="toc">
                <li><a href="#2.4.1.manpages">2.4.1. Strony podręcznika</a></li>
                <li><a href="#2.4.2.helpincommand">2.4.2. Pomoc w samym poleceniu</a></li>
                <li><a href="#2.4.3.texinfo">2.4.3. Dokumentacja texinfo</a></li>
                <li><a href="#2.4.4.usrsharedoc">2.4.4. /usr/share/doc</a></li>
                <li><a href="#2.4.5.rhdocs">2.4.5. Dokumentacja Red Hat Enterprise Linux</a></li>
              </ul>
            </li>
            <li><a href="#exec2.1">Ćwiczenie: 2-1</a></li>
            <li><a href="#exec2.2">Ćwiczenie: 2-2</a></li>
            <li><a href="#exec2.3">Ćwiczenie: 2-3</a></li>
            <li><a href="#exec2.4">Ćwiczenie: 2-4</a></li>
            <li><a href="#ch2summary">Podsumowanie</a></li>
          </ul>
        </li>
        <li><a href="#3.fileoperations">3. Operacje na plikach</a>
          <ul class="toc">
            <li><a href="#3.1.filetypes">3.1. Rodzaje plików</a>
            <li><a href="#3.2.compressionandarchiving">3.2. Kompresja i archiwizowanie</a>
              <ul class="toc">
                <li><a href="#3.2.1.gzip">3.2.1. gzip</a></li>
                <li><a href="#3.2.2.bzip">3.2.2. bzip2</a></li>
                <li><a href="#3.2.3.tar">3.2.3. tar</a></li>
              </ul>
            </li>
            <li><a href="#3.3.vim">3.3. Edycja plików za pomocą edytora Vim</a>
              <ul class="toc">
                <li><a href="#3.3.1.startingvim">3.3.1. Podstawy obsługi Vim</a></li>
                <li><a href="#3.3.2.othervimcommands">3.3.2. Pozostałe polecenia Vim</a></li>
              </ul>
            </li>
            <li><a href="#3.4.filesanddirectories">3.4. Pliki i katalogi</a>
              <ul class="toc">
                <li><a href="#3.4.1.createfilesanddirs">3.4.1. Tworzenie plików i katalogów</a></li>
                <li><a href="#3.4.2.listingfiles">3.4.2. Wyświetlanie zawartości pliku</a></li>
                <li><a href="#3.4.3.copyingandmoving">3.4.3. Kopiowanie i przenoszenie plików</a></li>
                <li><a href="#3.4.5.removefilesanddirs">3.4.5. Usuwanie plików i katalogów</a></li>
              </ul>
            </li>
            <li><a href="#3.5.links">3.5. Dowiązania</a>
              <ul class="toc">
                <li><a href="#3.5.1.hardlinks">3.5.1. Dowiązanie twarde</a></li>
                <li><a href="#3.5.2.symlinks">3.5.2. Dowiązanie symboliczne</a></li>
              </ul>
            </li>
            <li><a href="#exec3.1">Ćwiczenie 1: Archiwa</a></li>
            <li><a href="#exec3.2">Ćwiczenie 2: Praktyka z Vim-a</a></li>
            <li><a href="#exec3.3">Ćwiczenie 3: Manipulacja plikami</a></li>
            <li><a href="ch3summary">Podsumowanie</a></li>
          </ul>
        </li>
      </ul>
      <h1 id="1.introduction">1. Wstęp</h1>
      <p>
        Chcąc zmienić coś w swoim życiu postanowiłem, że zacznę od pracy.
        Dalej chciałem pracować w IT, tylko na innym stanowisku (praca 
        szkolnego administratora
        jest porównywalna z pracą technika IT, tu ma ktoś problem z systemem,
        tu trzeba podłączyć rzutnik, szczerze to znudziła się praca tego 
        typu).  Dobrze czułem się pracując z
        Linuksem, to była moja pasja. Znałem dwa stanowiska na których 
        mógłbym pracować: Linux System Administrator lub Linux System
        Engineer. Teraz na rynku pracy jeśli chodzi o IT ważniejsze są 
        uzyskane certyfikaty i odbyte kursy niż wykształcenie. Szukając 
        certyfikatów,
        które spowodują większe szanse na zatrudnienie, znalazłem dwa.
        Linux Fundation oraz Red Hat. Po przeczytaniu postu a na Reddit
        doszedłem do wniosku, że lepszym wyborem będzie Red Hat. Jeśli
        chodzi o produkcyjne wykorzystanie Linuksa to prym wśród firm
        wiedzie Red Hat lub jego darmowy odpowiednik. Kiedyś CentOS ale
        obecnie może być to zarówno Rocky Linux lub Alma Linux, oba są
        pochodnymi Red Hat. Szukając jakiś materiałów w internecie, które
        pomogły by mi się przygotować natrafiłem na Amazonie na książke
        Asghara Ghori pt. <em>RHCSA Red Hat Enterprise Linux 8 (UPDATED): 
        Training and Exam Preparation Guide (EX200), Second Edition</em>
        zamówiłem ją na swojego Kindla i zacząłem przygotowywać się do
        egzaminu. 
      </p>
      <h2 id="1.1.exam">1.1. Egzamin</h2>
      <p>
        Egzamin EX200 dający uprawnienia Red Hat Certified System
        Administrator jest egzamin praktycznym sprawdzającym umiejętność
        instalacji, konfiguracji oraz rozwiązywania podstawowych problemów
        administracyjnych na dystrybucji Red Hat. Egzamin będzie odbywać
        się w postaci elektronicznej i zdający będzie mięć do dyspozycji
        dwie maszyny wirtualne do wykonania zadań egzaminacyjnych. Takie
        też środowisko przygotujemy sobie do nauki. Na dzień 11 listopada
        2020 (tak jak podaje książka) egzamin obejmować 69 zagadnień jednak
        ta liczba, ze względu na rozwój technologii jak i samego Red Hata
        mogła ulec już zmianie.
      </p>
      <h2 id="1.2.examobjectives">1.2. Zagadnienia</h2>
      <p>
        Zagadnienia używane na egzaminie mogą cały czas ewoluować. Odnośnik
        obok przedstawia aktualne zagadnienia egzaminacyjne.
        <a href="http://www.redhat.com/training/courses/ex200/examobjective">http://www.redhat.com/training/courses/ex200/examobjective</a>. Obecnie egzamin zadawany jest na
        RHEL 9, wydany 17 maja 2022. Dość istotną zmianą w produkcji tego
        systemu jest zmiana <em>upstreamu</em>. Ta wersja Red Hat nie jest
        już oparta na Fedorze tak jak wszystkie do tej pory, ale na CentOS
        Stream (nowa wersja non-stream tej dystrybucji nie jest już dostępna 
        stąd
        rozbicie społeczonościowych dystrybucji do zastosowań produkcyjnych na
        Rocky oraz Alma Linux) i tej wersji będziemy użwać na maszynach
        wirtualnych.
      </p>
      <h2 id="1.3.exampreparation">1.3. Przygotowania</h2>
      <p>
        Kiedy uznałem, że chce zdobyć RHCSA, uzyskałem Red Hat na zasadzie
        <em>Non-cost RHEL Individual Developer Subscription</em>, gdzie
        istotne informacje znajdują się w odnośniku obok.
        <a href="https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux">https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux</a>
        Przy użyciu tej subskrypcji uzyskamy dostęp do Red Hat przez rok na
        16 instalacji (bez znaczenia czy to fizyczny komputer, czy maszyna
        wirtualna). Po tym czasie należy zalogować się ponownie, zakceptować
        warunki umowy i po 15 do 30 minut powinnimy uzyskać ponowny rok
        subskrypcji i tak co roku. Wszystko jest opisane na powyższej stronie.
        System w wersji 8.6 (ponieważ na wersję 9.0, moim zdaniem jest
        za wcześnie, kiedyś zainstalowałem RHEL 8 na laptopie to non stop
        otrzymywałem jakieś raporty o błedach) zainstalowałem na komputerze
        codziennego użytku w pracownii. Najlepszym sposobem na nauczenie się
        administracji systemu jest jego używanie, a że jest entuzajstą a nie
        profesjonalistą, mój kontakt z systemami tego typu jest raczej dość
        mocno ograniczony. Dlatego też przesiadłem się na RHEL, póki co ten
        system poprostu działa, wcześniej korzystałem z Fedory 35 oraz
        Debiana 11. Do celów dydaktycznych potrzebujemy peceta lub laptopa
        z min. dwurdzeniowym procesorem, 8GB pamięci operacyjnej oraz 27GB
        wolnej przestrzeni na dysku na potrzeby utworzenia maszyn wirtualnych
        z wymagną przez ćwiczenia przestrzenią dyskową oraz możliwością
        wirtualizacji 64-bitowych systemów. Do tego celu 
        użyjemy oprogramowania Oracle VirtualBox, dającego najprostszy
        interfejs do interakcji z maszynami, gdyż przy późniejszych
        zagadnieniach będziemy musieli zmienić jej ustawienia lub dodać kilka
        urządzeń, oczywiście jeśli ktoś czuje się mocny w innych środowiskach
        może użyć swojego ulubionego, nie mniej jednak w trakcie nauki będzie
        trzeba dokonać kilku zmian w na tych maszynach, a opisy zamieszczone
        tutaj będą dotyczyć głównie VirtualBox. Czy ktoś zainstaluje na swoim 
        komputerze RHEL czy nie to,
        już indywidualna sprawa i nie wypłynie ona wykonanie ćwiczeń. Nie
        mniej jednak, w podpunkcie odnośnie maszyn wirtualnych tego rodziału
        przedstawie skrypt powłoki, który po uruchomieniu utworzy
        automatycznie maszyny wymagane do wykonania ćwiczeń. Ale póki co 
        przedstawie teraz instalacje Oracle VirtualBox na RHEL 8.6.
      </p>
      <h3 id="1.3.1.vboxinstallationonrhel">1.3.1. Instalacja Oracle VirtualBox 
        na RHEL 8.6</h3>
      <p>
        Pierwszą czynnością jest uruchomienie przeglądarki i przejście pod
        adres: <a href="https://www.virtualbox.org/wiki/Linux_Downloads">https://www.virtualbox.org/wiki/Linux_Downloads</a>, na samym dole strony znajdują się pliki repozytorium
        dla kilku dystrybucji Linuksa. Pobieramy ten przeznaczony dla RHEL
        następnie przenosimy go do wskazanego na stronie katalogu. Następnie
        możemy wydać polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        Po instalacji, przełączamy się w terminalu na użytkownika <em>root</em>.
        Następnie wydajemy poniższe polecenia:
      </p>
<pre class="code-block">
$ sudo su
# akmods
Checking kmods exist for 4.18.0-372.9.1.el8.x86_64         [  OK  ]
# systemctl restart vboxdrv.service
</pre>
      <p>
        Teraz Oracle VirtualBox jest gotów do działania.
      </p>
      <p>
        W przypadku RHEL 9, jeśli ktoś używa, to instalacja wydaje się jeszcze
        prostsza, gdyż do instalacji możemy użyć <strong>RPMFusion</strong>. Po 
        załadowaniu tych repozytoriów do swojego systemu możemy od razu wydać
        polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        W wersji 8.6, zapewne również możemy skorzystać z <em>RPMFusion</em>.
        Ja zanim się dowiedziałem że VirtualBox jest dostępny w tych
        repozytoriach, instalowałem go za pomocą instrukcji zawartej na stronie
        Virtualbox, do której link znajduje się powyżej.
      </p>
      <h3 id="1.3.2.gettingrheliso">1.3.2. Pozyskanie obrazu ISO z Red Hat 
        Enterprise Linux 9</h3>
      <p>
        Aby uzyskać takowy obraz musimy zarejestrować się w subskrypcji dla
        indywidualnych deweloperów. Przechodzimy na stronę <a href="https://developers.redhat.com/register">https://developers.redhat.com/register</a> i rejestrujemy się. Następnie
        logujemy i po zalogowaniu przechodzimy na stronę: <a href="https://developers.redhat.com/products/rhel/download">https://developers.redhat.com/products/rhel/download</a>.
        w sekcji <em>All Downloads</em> znajdują się wszystkie dostępne wersje
        Red Hat objęte jeszcze wsparciem. Nas będzie interesować wyłącznie
        wersja 9 i tą też pobieramy, oczywiście dla architektury <em>x86_64</em>
        w wersji DVD.
      </p>
      <h3 id="1.3.3.createvmwithrhel">1.3.3. Tworzenie maszyn wirtualnych 
        VirtualBox z RHEL</h3>
      <p>
        Tworzenie maszyn wirtualnych VirtualBox, nie jest zaganieniem
        egzaminacyjnym. Na egzaminie dostaniemy dostęp do dwóch zdalnych
        maszyn. Teoretycznie można by użyć fizycznych maszyn o ile ktoś ma
        do takowych dostęp, jednak do drugiej maszyny trzeba dodać aż 7 dysków,
        więc użycie wirtualnej maszyny, to chyba jedyne efektywne rozwiązanie. 
        Poniżej znajdują się wymagania jakie powinna spełniać każda z nich:
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
          <ul>
            <li>64-Bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor,</li>
            <li>1024 MB pamięci operacyjnej,</li>
            <li>10GB dysk twardy, wyłącznie na instalacje systemu,</li>
            <li>Karta sieciowa ustawiona na bridged.</li>
            <li>Nazwa hosta ustawiona na server1.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
        <li><strong>RHEL9-VM2</strong>:
          <ul>
            <li>64-bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor</li>
            <li>2048 MB pamięci operacyjnej</li>
            <li>10 GB dysk twardy, na instalacje systemu</li>
            <li>4 x 250 MB dysk twardy, dla ćwiczeń z LVM</li>
            <li>1 x 4 GB dysk twardy, dla ćwiczeń z VDO</li>
            <li>1 x 1 GB dysk twardy, dla ćwiczeń ze Stratis</li>
            <li>Nazwa hosta ustawiona na server2.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
      </ul>
      <p>
        Maszyny możemy utworzyć ręcznie, podążając za wskazówkami przewodnika,
        w przypadku drugiej maszyny dodatkowe dyski trzeba będzie dodać z
        poziomu ustawień maszyny. Drugą możliwością jest skorzystanie z dwóch
        poniższych skryptów kolejno dla
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM1";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;
$vboxmanage storagectl $vmname --name SATA0 --add sata;

$vboxmanage modifyvm $vmname --memory 1024;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";
</pre>
        </li>
        <li><strong>RHEL9-VM2</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM2";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/VDO.vdi" --size \
4096 --format VDI --variant Standard;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/Stratis.vdi" \
--size 1024 --format VDI --variant Standard;

$vboxmanage storagectl $vmname --name SATA0 --add sata;
$vboxmanage modifyvm $vmname --memory 2048;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";

$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";

i=2;
while [ $i -le 5 ]; do
  $vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi" --size \
  250 --format VDI --variant Standard;
  $vboxmanage storageattach $vmname --storagectl SATA0 --port $i --type hdd --medium \
  "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi";
  i=$((i + 1));
done

$vboxmanage storageattach $vmname --storagectl SATA0 --port 6 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/VDO.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 7 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/Stratis.vdi";
</pre>
        </li>
      </ul>
      <p>
        Powyższe skrypt są również dostępne na moim profilu na github-ie. Pod
        poniższymi linkami.
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh</a></li>
        <li><strong>RHEL9-VM2</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh</a></li>
      </ul>
      <p>
        Korzystając ze skryptów <strong>należy pamiętać o zmianie intefejsu
        sieciowego</strong> wykorzystywanego do mostkowania. Zmienna
        <code class="code-inline">bridge_if</code>.
      </p>
      <p>
        Po utworzeniu maszyn przyszedł czas na instalację.
      </p>
      <h3 id="1.3.4.rhelinstallation">1.3.4. Instalacja Red Hat Enterprise 
        Linux 9.0</h3>
      <p>
        Zaraz po uruchomieniu maszyny rozpocznie się proces ładowania
        zawartości płyty. Menu bootowania płyty zawiera trzy opcje. 
      </p>
      <ol>
        <li><em>Install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Test this media & install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Troubleshooting</em></li>
      </ol>
      <p>
        Domyślnie zaznaczoną jest opcja numer 2. Mamy minutę na zmianę
        decyzji. Naciśnięcie dowolnego klawisza zatrzymuje odliczanie. Dając
        nam czas do namysłu, jednak na ten moment nie co za bardzo rozmyślać
        dlatego też wybieramy opcję numer 1. Po wybraniu tej opcji nastąpi
        uruchomienie systemu oraz instalatora. Instalator używany przez RHEL 
        oraz dystrybucje z nim związane
        nazywa się <strong>Anaconda</strong>. Swoje działanie
        rozpoczyna jeszcze w trybie tekstowym, następnie domyślnie uruchamia
        tryb graficzny, gdzie odbywa się konfiguracja instalcji a następnie 
        już właściwa instalacja.
        Nie mniej jednak instalacja w trybie tekstowym jest również możliwa.
        Podczas instalacji, poza głównym instalatorem będziemy mieć do
        dyspozycji 
        multipekser terminala, który do momentu uruchomienia właściwego 
        instalatora (w wersji graficznej) był główną konsolą. W multiplekserze
        będzie my mieć dostęp do komunikatów diagnostyczny, które w wersji 8
        RHEL był wyświetlane na oddzielnych konsolach; kilka powłok z
        uprawnieniami superużytkownika (uruchomione na konsolach 2, 3 i 5) 
        oraz konsolę z komunikatami przechwytywanymi przez główny 
        rejestrator systemu <em>syslog</em>. Udostępnienie tych funkcjonalności
        podczas instalacji systemu, może pomóc w ewentualnym namierzeniu i
        naprawie problemów z instalacją.
        Pliki z komunikatami na czas instalacji przechowywane są w katalogu 
        <em>/tmp</em>, po instalacji zostaną one przeniesione do katalogu
        <em>/var/log/anaconda</em>. Według mnie jest dość przydatna
        funkcjonalność, ponieważ na podstawie czasu modyfikacji tych plików
        możemy dowiedzić się kiedy system został zainstalowany. Poniżej
        znajduje się lista, opisująca za co odpowiada konkretna konsola
        (kolejny ekran, dostępny po naciśnięciu klawiszy Ctrl + Alt + F1 - F6).
      </p>
      <ul>
        <li><strong>CTLR + ALT + F1</strong> - multiplekser terminala,</li>
        <li><strong>CTRL + ALT + F2</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F3</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F4</strong> - komunikaty diagnostyczne
            rejestratora <em>syslog</em>.</li>
        <li><strong>CTRL + ALT + F5</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F6</strong> - tryb graficzny.</li>
      </ul>
      <p>
        Instalacja Red Hat Enterprise Linux rozpoczyna się od wyboru języka
        procesu instalacji. Chcąc pracować już w takim prawowitym IT, należy
        posługiwać się językiem angielskim i to technicznym. Systemy z którymi
        zderzmy się w potencjalnej pracy raczej będą systemami o zasięgu
        międzynarodowym, prawdopodobnie już o tym wspominałem ale egzamin
        pozwalający uzyskać certyfikacje RHCSA również będzie po angielsku.
        Dlatego też instalować jak i korzystać z systemu będziemy w języku
        angielskim, na pierwszym ekranie wybieramy <em>English</em>
        pozostawiając wariant <em>English (United States)</em>. Następnym
        ekranem jest <em>Installation Summary</em> (lewy górny róg), jest tak
        jakby pulpit programu instalacyjnego, na nim występują komponenty,
        które możemy skonfigurować. W wersji 9.0, te komponenty są podzielone
        na 4 sekcje: <em>Localization</em>, <em>Software</em>, <em>System</em>
        oraz <em>User Settings</em>. W pierwszym procesie instalacji,
        przejdziemy przez wszystkie z nich.
      </p>
      <p>
        Zwróć my uwagę na to, iż system sam dokonał wstępnej konfiguracji
        instalatora, na pozostało jedynie sprawdzić oraz skonfigurować tylko
        te opcje oznaczone znakiem ostrzegawczym oraz czerwoną podpowiedzią. Po
        ich konfiguracji program umożliwi nam zainstalowanie systemu.
      </p>
      <p>
        W sekcji lokalizacyjnej do ustawienia są takie opcje, układ klawiatury,
        język, oraz data i czas. Podczas ładowania pierwszego okna (moment 
        wybrania języka instalacji), instalator na podstawie informacji GeoIP
        postara się określić naszą przybliżoną lokalizację, o ile posiada on
        na tym momencie połączenie z internetem. Dlatego też możemy
        spotkać się z samoinstnie wybranym języku instalacji ustawionym na
        Polski. Język został zmieniony, ale wybrana strefa czasowa może
        pozostać, wręcz powinna. Dzięki tej funkcji możemy zaoszczędzić czas,
        i przejść do kolejnej sekcji.
      </p>
      <p>
        Kolejną sekcja dotyczy oprogramowania, tutaj konfigurowane będzie
        na przykład połączenie z firmą Red Hat. RHEL jest system 
        licencjonowanym i jeśli chcemy skorzystać z oficjalnych repozytoriów
        należy "podłączyć" system do naszego konta założonego w celu
        pozyskania obrazu płyty. Jednak na razie nie trzeba tego, będzie to
        do zrobienia na późniejszych etapach nauki administracji systemem.
        Kolejną opcją jest <em>Installation Source</em> (Źródło instalacji),
        konfigurąc tę opcję możemy
        wybrać czy będziemy korzystać pod czas instalacji z obrazu płyty lub
        sieciowego repozytorium lub Red Hat CDN. Z racji tego, iż ściągneliśmy 
        pełny obraz
        ważący kilka gigabajtów, nie ma sensu używać instalacji sieciowej.
        Tego typu źródło instalacji należy wybrać w momencie gdy pobraliśmy
        minimalistyczną wersję obrazu, dlatego też zostaniemy przy standardowym
        wyborze <em>Local media</em>. Ta opcja pozwala też na dodanie podczas
        instalacji dodatkowego repozytorium, jednak na tym etapie nie będziemy
        się tym zajmować. Ostanią opcją z tej sekcji jest <em>Software
        selection</em>, ta opcja daje nam możliwość, wyboru rodzaju instalacji.
        Na potrzeby nauki, wybierzemy opcję <em>Server with GUI</em>, jeśli
        będziemy instalować RHEL na naszym komputerze do codziennego użytku
        możemy wybrać <em>Workstation</em>. Wybierając rodzaj instalacji po
        lewej stronie, po prawej wyświetają się dodatkowe pakiety lub
        warianty do zainstalowania.
      </p>
      <p>
        Sekcja <em>System</em>, służy głównie do wyboru docelowego miejsca dla
        instalacji. W opcji <em>Instalation Destination</em>,
        wskazujemy docelowy dysk do instalacji, możemy go spartycjonować 
        ręcznie lub automatycznie możemy również zaszyfrować instalacje,
        jeśli jest taka potrzeba. W przypadku szyfrowania danych 
        bardzo ważny jest układ klawiatury. Innymi opcjami
        póki co dla nas ważnymi jest <em>Network &amp; Host name</em>, w
        założeniach zadania, może być wymagane ustawienie odpowiedniego adresu
        oraz nazwy dla maszyny. Tak jest w naszym przypadku, to te opcje
        ustawiamy właśnie tam. Pozostałe opcje tej sekcji, poki co nie są
        dla nas istotne.
      </p>
      <p>
        Ostatnia sekcja ustawia hasło dla superużytkownika oraz tworzy konto
        dla pierwszego użytkownika. Nie musi on posiadać uprawnień
        administratora i nie będzie ich miał. Opcja utworzenia użytkownika
        może się nie mieścić na ekranie, podczas instalacji systemu maszynie
        witualnej, dlatego nie należy przejmować, że jej nie ma.
      </p>
      <p>
        Teraz kiedy wszyskie (te istotne dla instalacji) zostały opisane możemy
        zainstalować system zgodnie założeniami pierwsze maszyny i powtorzyć
        to na drugiej. I to jest pierwsze ćwiczenie.
      </p>
      <h3 id="exec1.1">Ćwiczenie 1: Instalacja Red Hat Enterprise Linux 9</h3>
      <p>
        Zainstaluj zgodnie założeniami podanymi w podrozdziale 
        <em>Tworzenie maszyn wirtualnych VirtualBox z RHEL</em> oraz sugestiami
        podanymi podczas opisu procesu instalacji. Red Hat
        Enterprise Linux 9 na maszynie wirtualnej <em>RHEL-VM1</em>. Następnie
        powtórz tę czynność drugiej maszynie przeznaczonej do laboratorium.
        Pamiętaj, że założenia dla drugiej maszyny różnią się.
      </p>
      <h3 id="exec1.2">Ćwiczenie 2: Logowanie zdalne do RHEL</h3>
      <p>
        Wykorzystując program do obsługi protokołu SSH dla twoje systemu
        operacyjnego zaloguj się na superużytkownika. Pamiętaj o tym, że
        bezpośrednie logowanie na superużytkownika wymagało zaznaczenia opcji
        podczas ustawiania hasła dla niego.
      </p>
      <h2 id="ch1summary">Podsumowanie</h2>
      <p>
        W tym rozdziale przezszliśmy przez proces instalacji RHEL.
        Dowiedzielśmy się, że możliwe jest instalacja w trybie tekstowym oraz
        oraz, że nienależy ona do najtrudniejszych. Warto zwrócić uwagę na to
        iż jeśli do tej pory korzystaliśmy z jakiś materiałów to dotyczą one
        wersji 8 RHEL, my będziemy korzystać z wersji 9, bo to na niej w 2022
        roku będziemy zdawać egzamin, a między tymi wersjami jest kilka zmian.
        W następnym rozdziale zapoznamy się z środowiskiem graficznym,
        strukturą katalogów oraz podstawowym narzędziami do pracy w powłoce.
      </p>
      <h1 id="2.firststepsinRHEL9">2. Poruszenia się po systemie RHEL 9</h1> 
      <p>
        Wykonując ćwiczenia z pierwszego rozdziału, zainstalowaliśmy sobie
        Red Hat w wersji 9 na maszynie wirtualnej. Jako wariant wyboru
        oprogramowania wybraliśmy <em>Server with GUI</em> i od drobnego
        omówienia środowiska graficznego rozpocznę ten rodział.
      </p>
      <h2 id="2.1.serverwithgui">2.1. Środowisko graficzne RHEL 9</h2>
      <p>
        Red Hat jest dystrybucją Linuksa przeznaczoną do zastosowań
        produkcyjnych, więc system tego typu musi wykazywać się dużą
        stabilnością. Znaczące zmiany są wprowadzane raczej w dużych wydania
        jak RHEL 9, takim znaczącym przeskokiem jest zmiana linii jądra z
        4.18 (w przypadku RHEL 8) na 5.14 (w przypadku RHEL 9) oraz zastąpienie
        klasycznego serwera X Window protokołem Wayland, to jednak nastąpiło z
        wydaniem RHEL 8. Zmiany w RHEL 9, odnośnie środowiska graficznego
        to przejście z Gnome 3.38 na Gnome 40, ta zmiana przyniosła również
        odświerzenie menedżera wyświetlania lub menedżera logowania czym w
        przypadku środowiska Gnome jest GDM. Większość elementów pozostała
        taka sama na górnej belce mamy datę oraz czas w prawyn górnym rogu
        do wyboru opcje ułatwień dostępu, wskaźnik połączenia sieciowego oraz
        porozwinięciu możliwość regulacji głośności i jasności ekranu oraz 
        wyłączenia komputera. Wiecej opcji w tym miejscu będzie dostępne dopiero 
        po zalogowaniu. Będzie można zmienić kilka ustawień jak np. sieć
        bezprzewodwą. Zmianie uległ również sposób prezentacji kont użytkownika.
        Z racji tego iż <em>root</em> nie jest zwykłym użytkownikiem nie będzie
        pojawiać się na liscie, ale zalogowanie na niego jest możliwe za pomocą
        kliknięcia w "Not Listed?" pod listą użytkowników, wówczas będzie mogli
        ręcznie podać nazwę użytkownika oraz hasło. Ekranem startowym po
        zalogowaniu jest ekran <em>Activities</em>, który pozwala na podgląd
        wykonywanych czynności, rozpoczęcie nowych (wybierają aplikacje z 
        z doka lub z pełnej listy aplikacji, która jest dostępna po kliknięciu
        na ikonę 9 kropek w doku) oraz przełacznie się między obszarami
        roboczymi. Domyślnie GNOME daje dostęp do dwóch przestrzeni roboczych,
        gdy tylko przeniesiemy aplikację do na nowy obszar, GNOME udostępni
        nam kolejny i tak dalej. Wyszukiwarka nad podgląd obszaru roboczego
        daje możliwość wyszukiwania nie tylko aplikacji ale także ustawień co
        jest normą w GNOME od wersji 3. Na doku znajdują się ulubione
        aplikacje, które możemy usuwać i dodawać za pomocą PPM i następnie
        wybierając dodaj lub usuń z ulubionych.
      </p>
      <h2 id="2.2.hfs">2.2. Struktura katalogowa w Uniksach</h2>
      <p>
        Zanim jednak przejedziemy do obsługi wiersza poleceń omówimy sobie
        hierachiczną strukturę katalogów, która występuje nie tylko w RHEL ale
        i w innych Uniksach, ponieważ HFS (<em>ang. Hierarchy File System</em>)
        jest ogólnym standardem. Na Uniksach możemy spotkać się z trzema typami
        systemów plików.
      </p>
      <ul>
        <li><strong><em>Disk-based</em> - dyskowe</strong> - są to klasyczne
          pliki i katalogi przechowywane bezpośrednio na dysku.</li>
        <li><strong><em>Network-based</em> - sieciowe</strong> - są to udziały
          podmontowane w naszych systemach za pomocą róznych protokołów, nie
          tylko SMB. Plik <em>network-based</em> są plikami <em>disk-based</em>,
          ale na innych komputerach.</li>
        <li><strong><em>Memory-based</em> - wirtualne</strong> - te systemy
          plików są tworzone przez procesy na potrzeby działania systemu, takim
          systemem może być katalog <em>/dev</em> lub <em>/tmp</em>. Ich
          trwałość często zależy od tego jak długo system pozostaje włączony
          lub od wewnętrznych ustaleń samego systemu.</li>
      </ul>
      <p>
        Struktura plików i katalogów na Uniksach ma postać odwróconego drzewa.
        Korzeń (katalog główny) znajduje się na szczycie struktury i odniego
        rozchodzą się poszczególne gałęzie (podkatalogi), gałęzię mogą zawierać
        kolejne rozgałezienia i tworzyć całe struktury, na gałęziach
        znajdują się również liscie czyli pliki i na liściach struktura się
        kończy.
      </p>
      <p>
        Dostęp do konkretnych plików i katalogów w strukturze określany jest
        za pomocą ścieżek. Scieżki określają położenie plików i katalogów
        wewnątrz HFS.
        Separatorem elementów ścieżki (posczególnych podkatalogów), jest
        ukośnik, slash (<strong>/</strong>).
      </p>
      <p>
        Podczas pracy z elementami jak foldery oraz pliki możemy używać
        <strong>scieżęk bezwzględnych</strong> zaczynające się od
        katalogu głównego, lub <strong>ścieżek względnych</strong>
        zaczynających
        się od elementu znajdującego w obecnym katalogu robocznym
        (tym katalogu, w którym się obecnie znajdujemy).
      </p>
      <p>
        Katalog główny jest miejscem do przechwywania wszystkich plików, jakie
        znajdują się w systemie, jest pierwszy element znajdujący się na
        ścieżce (bezwzględnej) i oznaczny jest on poprostu ukośnikiem
        (<strong>/</strong>), od tego katalogu zaczyna się cała struktura.
        Poniżej znajduje się lista najważniejszych podkatalogów katalogu
        głównego, każdy z nich ma swoje znaczenie w systemie.
      </p>
      <ul>
        <li><strong>/boot</strong> (<em>disk-based</em>) - katalog ten
            przechowuje jądro, <em>initramfs</em> oraz konfiguracje programu
            rozruchowego.</li>
        <li><strong>/dev</strong> (<em>memory-based</em>) - katalog ten
            przechowuje pliki urządzeń służące do odwoływania się do
            rzeczywistego sprzętu podczas komunikacji. Pliki te są tworzone
            przez usługę <em>udevd</em> podczas podłączania urządzenia oraz
            rozruchu systemu.</li>
        <li><strong>/etc</strong> (<em>disk-based</em>) - skrót <em>etc</em>
            możemy rozwinąć do <em>ang. etcetera</em> lub <em>ang. extended
            text configration</em>. Jest to miejsce do przechowywania plików
            konfiguracyjnych różnych programów.</li>
        <li><strong>/home</strong> (<em>disk-based</em>) - ten katalog
            przechowuje, katalogi domowe użytkowników.</li>
        <li><strong>/opt</strong> (<em>disk-based</em>) - katalog przeznaczony
            na dodatkowe oprogramowanie instalowane w systemie.</li>
        <li><strong>/proc</strong> (<em>memory-based</em>) - wirtualna 
            struktura podkatalogów, zawierająca informacje o procesach oraz
            różne informacje o systemie, np. informacje o procesorze.</li>
        <li><strong>/run</strong> (<em>memory-based</em>) - katalog
            przechowywujący pliki wykorzystywane przez procesy podczas
            wykonywania ich czynności. W tym katalogu znajduje się również
            podkatalog <em>media</em> zawierący punkt monotowania automatycznie
            montowanych w systemie dysków wymiennych.</li>
        <li><strong>/sys</strong> (<em>memory-based</em>) - katalog
            przechowuje informacje o urządzeniach, sterownikach. Pewne
            funkcjonalności jądra również są zawarte w tym katalogu. Informacje
            z tego katalogu są używane przez jądro do obsługi urządzeń.</li>
        <li><strong>/tmp</strong> (<em>disk-based</em>) - miejsce 
            przechowywania plików tymczasowych, plik złożone w tym katalogu
            przetrwają ponowne uruchomienie komputera. Okres przechowywania 
            tych plików to 10 dni.</li>
        <li><strong>/usr</strong> (<em>disk-based</em>) - skrót <em>usr</em>,
            należy rozwinąć jako <em>ang. UNIX System Resources</em>. Ten
            katalog jest kolejną dużą strukturą katalogów w systemie. W tym
            katalog przechowywane są wszystkie programy, więc wiekszość 
            systemu. Na poniższej liście znajdują się rozpisane podkatalogi
            tego katalogu:
            <ul>
              <li><strong>/usr/bin</strong> - katalog przechowuje większosć
                  plików binarnych, wykorzystywanych w systemie, programów oraz
                  poleceń.</li>
              <li><strong>/usr/sbin</strong> - narzędzia administracyjne
                  niedostępne dla zwykłych użytkowników, poza kilkoma
                  programami. Ten katalog często nie jest ujęty podczas 
                  wyszukiwania poleceń.</li>
              <li><strong>/usr/lib</strong>, <strong>/usr/lib64</strong> - 
                  biblioteki współdzielone oraz pliki statyczne, nie których
                  programów typu init.</li>
              <li><strong>/usr/include</strong> - pliki nagłówkowe języka C</li>
              <li><strong>/usr/local</strong> - miejsce przechowywania
                  zewnętrznych programów instalowanych i
                  wykorzystywanych przez administatorów, ten katalog zawiera w
                  sobie podobną strukturę katalogową jak sam <em>/usr</em>.</li>
              <li><strong>/usr/share</strong> - miejsce przechowywania stron
                  podręcznika, dokumentacji czy przykładowych plików 
                  konfiguracyjnych.</li>
            </ul>
        </li>
        <li><strong>/var</strong> (<em>disk-based</em>) - katalog na zmienne
            dane, katalog podobnie do <em>/usr</em> ma wewnątrz wiele znaczący
            podkatalogów, których opis znajduje się poniżej:
            <ul>
              <li><strong>/var/log</strong> - katalog na pliki dzienników,
                zbierane nie tylko z głównego rejestratora, ale i funkcji
                rejestrowania samych usług.</li>
              <li><strong>/var/opt</strong> - katalog na zmienne dane
                oprogramowania instalowanego w katalogu <em>/opt</em></li>
              <li><strong>/var/spool</strong> - katalog ten przechowuje dane
                zanim zostaną przekazane lub pobrane przez właściwe komponenty.</li>
              <li><strong>/var/tmp</strong> - katalog przechowuje duże pliki
                tymczasowe. Pliki przeżywają uruchomienie ponowne systemu.
                Czas ich istnienia w tym katalog to 30 dni.</li>
            </ul>
        </li>
      </ul>
      <p>
        Za pomocą polecenia <strong>tree</strong>, możemy wyświetlić strukturę
        katalogą w postaci drzewa, jednak najpierw nauczymy się korzystać z
        poleceń w RHEL.
      </p>
      <h2 id="2.3.usingcli">2.3. Obsługa wiersza poleceń i najprostsze 
      polecenia</h2>
      <p>
        Obsługa wiersza poleceń zależy w znacznym stopniu od powłoki, ponieważ
        to ona zajmuj się jego interpretacją i koniec końców wykonaniem
        programu, którego nazwę podaliśmy chcą wykonać polecenie. Aby móc
        skorzystać w RHEL z wiersza poleceń musimy albo uruchomić w środowisku
        graficznym aplikację <strong>Terminal</strong>, lub zalogować się
        zdalnie za pomocą protokołu SSH. Uruchomienie terminala lub zalogowanie
        się przez SSH uruchomi powłokę, która swoją gotowość na otrzymywanie
        poleceń obwieści wyświetleniem <strong>znaku zachęty</strong>.
      </p> 
      <p>
        Znak zachęty jest wskaźnikiem za kursorem po którym możemy wprowadzać 
        do systemu
        polecenia. Kiedyś znaki zachęty były pojedyńczymi znakmi informującymi
        o uprawnieniach z jakimi działa proces powłoki (o tym za chwilę). Teraz
        znaki zwracają nazwę użytkownika, nazwę komputera oraz obecny katalog
        roboczy wewnątrz nawiasu kwadratowego, następnie zanim znajduje się
        znak krzyżyka (<strong>#</strong>) mówiący, że powłoka działa
        uprawnieniami użytkownika <em>root</em> lub symbol dolara 
        (<strong>$</strong>) mówiący, że połoka działa z uprawnieniami zwykłego
        użytkownika. Poniżej przedstawiłem oba znaki:
      </p>
<pre class="code-block">
[root@server1 ~]#

[user@server1 ~]$
</pre>
      <p>
        W różnych dystrybucjach, znak zachęty może różnorako wyglądąć. Możemy
        dostować go do własnych potrzeb, wiele osób korzysta z jak 
        najmniejszych
        znaków zachęty, aby zaoszczedzić miejsce w wierszu polecenia. Teraz
        możemy już wydawać polecenia.
      </p>
      <p>
        Kazde polecenie w jakimkolwiek Uniksie, składa się z nazwy polecenia,
        ewentualnych opcji oraz ewentualnych argumentów. Nie wszystkie
        polecenia do uzyskania żądanych przez nas efektów wymagają opcji czy
        argumentów.  
      </p>
<pre class="code-block">
$ nazwa_polecenia [opcje] [argumenty]
</pre>
      <p>
        Każde polecenie przed zatwierdzeniem możemy edytować, za pomocą
        strzałek lub skrótów klawiszowych dostarczanych przez bibliotekę
        <em>GNU Readline</em>. Więcej na ten temat znajdziemy w internecie.
      </p>
      <p>
        Przez cały kurs będziemy poznawać jakieś polecenia ale w tym momencie
        nauczymy się najprostszych z nich.
      </p>
      <h3 id="2.3.1.ls">2.3.1. Listowanie zawartości katalogu</h3>
      <p>
        Aby wyświetlić zawartość katalogu w powłoce, możemy użyć polecenia
        <strong>ls</strong>. Polecenie bez podania argumentu w postaci
        katalogu wyświetli zawartość folderu, w którym się znajdujemy.
        Najważniejszymi opcjami między innymi są:
      </p>
      <ul>
        <li><strong>-a</strong> - wyświetlanie wszystkich, elementów w katalogu
            także tych, które normalnie nie są wyświetlane (plik i foldery,
            których nazwa rozpoczyna się od kropki).</li>
        <li><strong>-l</strong> - wyświetlenie szczegółowych informacji na
            temat elementów. Informacja zwracana przez polecenie jest wówczas
            podzielona na 9 pól, które kolejno oznaczają: typ pliku oraz
            uprawnienia; liczbę dowiązań; nazwę użytkownika (właściciela pliku);
            nazwę grupy do której należy ten plik; rozmiar w bajtach; czas
            modyfikacji oraz nazwę elementu.</li>
        <li><strong>-ld</strong> - wyświetla szczegółową informacje na temat
            podanego jak argument katalogu, bez wyświetlania jego zawartości.
            Jeśli nie podamy argumentu polecenie wyświetli informacje na temat
            bierzącego katalogu.</li>
        <li><strong>-lh</strong> - wyświetli szczegółowo informacje
            na temat elementów w katalogu, wyświetlając ich rozmiar w
            przeskalowanych wartościach, co ułatwi odczytanie go przez 
            człowieka.</li>
        <li><strong>-lt</strong> - wyświetli szczegółową listę elementów
            posortową względem czasu modyfikacji od najnowszego pliku.</li>
        <li><strong>-ltr</strong> - działanie podobne to <em>-lt</em>, ale
            odwrócone, elementy zostaną wyświetlone od najstarszego.</li>
        <li><strong>-R</strong> - wyświetlenie elementów w sposób 
            rekurencyjny. Polecenie z tą opcją wyświetli zawartość katalogów
            wraz z zawartością ich podkatalogów itd.</li>
      </ul>
      <p>
        Poniżej znajduje się przykład najczęściej wykorzystywanego polecenia
        <em>ls</em> wraz z opcjami:
      </p>
<pre class="code-block">
[root@server1 ~]# ls -al
total 10576
dr-xr-x---. 17 root root    4096 Jun 16 18:49 .
dr-xr-xr-x. 18 root root     235 Jun  9 19:46 ..
-rw-------.  1 root root    1197 Jun  9 19:59 anaconda-ks.cfg
-rw-------.  1 root root    3908 Jun 16 18:50 .bash_history
-rw-r--r--.  1 root root      18 Aug 10  2021 .bash_logout
-rw-r--r--.  1 root root     141 Aug 10  2021 .bash_profile
-rw-r--r--.  1 root root     429 Aug 10  2021 .bashrc
drwxr-xr-x.  3 root root      17 Jun 16 18:14 bzipped
drwx------.  8 root root     120 Jun 13 10:55 .cache
-rw-r--r--.  1 root root      11 Jun 16 13:10 catfile1
drwx------.  9 root root    4096 Jun 13 13:42 .config
-rw-r--r--.  1 root root     100 Aug 10  2021 .cshrc
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Desktop
drwxr-xr-x.  4 root root      30 Jun 16 16:44 dir20
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Documents
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Downloads
drwxr-xr-x.  3 root root      55 Jun 16 11:34 etc
-rw-r--r--.  1 root root 4986788 Jun 16 18:13 etc-bzipped.tar.bz2
-rw-r--r--.  1 root root 5772869 Jun 16 18:12 etc-gzipped.tar.gz
-rw-r--r--.  2 root root       0 Jun 16 17:26 file10
-rw-r--r--.  2 root root       0 Jun 16 17:26 file20
-rw-r--r--.  1 root root     579 Jun 16 11:07 fstab
drwxr-xr-x.  3 root root      17 Jun 16 18:14 gzipped
-rw-------.  1 root root      42 Jun 16 18:22 .lesshst
drwx------.  3 root root      19 Jun 13 10:55 .local
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Music
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Pictures
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Public
lrwxrwxrwx.  1 root root       6 Jun 16 17:30 soft10 -&gt; file10
-rw-r--r--.  1 root root     129 Aug 10  2021 .tcshrc
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Templates
drwxr-xr-x.  2 root root       6 Jun 13 10:55 Videos
-rw-------.  1 root root    8264 Jun 16 18:38 .viminfo
-rw-r--r--.  1 root root     464 Jun 16 18:38 vipractice
</pre>
      <p>
        Podczas korzystania z wielu programów możemy natknąć się na wiele opcji.
        Dzielą się one na długie i krótkie, opcje krótkie występują w
        postaci pojedyńczego znaku poprzedzonego jednym myślnikiem
        (<strong>-</strong>). Opcje długie występuje w postaci pojedyńczego
        (najczęsciej, ponieważ to zależy od programu) słowa poprzedzonego dwoma 
        myślnikami (<strong>--</strong>). W przypadku tak prostych poleceń jak
        <em>ls</em> również możemy użyć długich opcji np. zamiast
        <em>-a</em> możemy użyć <em>--all</em>.
      </p>
      <h3 id="2.3.2.pwd">2.3.2. Wyświetlenie bierzącego katalogu roboczego</h3>
      <p>
        Na pierwszy rzut oka mogłoby się wydawać po co nam to polecenie,
        skoro w znaku zachęty na RHEL jest wyświetlona nazwa bierzącego
        katalogu. Polecenie <strong>pwd</strong> wyświetla ścieżkę bezwzględną 
        do bierzącego katalogu, a po drugie to polecenie ma bardzo ważną cechę
        związaną z dowiązaniami, ale o tym będzie przy dowiązaniach. Do
        normalnych zastosować <em>pwd</em> nie potrzebuje żadnej opcji, ani
        żadnego argumentu.
      </p>
<pre class="code-block">
[root@server1 ~]# pwd
/root
</pre>
      <h3 id="2.3.3.cd">2.3.3. Poruszanie się wśrod katalogów</h3>
      <p>
        Generalnie do zmiany bierzącego katalogu, czy przejścia z/do 
        innego katalogu służy polecenie <strong>cd</strong>. Pozwala on na
        kilka sztuczek.
      </p>
      <ul>
        <li>Powrót do katalogu domowowego nie wymaga przy tym poleceniu żadnego
          argumentu ani opcji, wystarczy wydać polecenie <em>cd</em>.</li>
        <li>Polecenie zapamiętuje poprzedni katalog roboczy i powrót do niego
          wymaga podania polceniu <em>cd</em> myślnika (<strong>-</strong>)
          jako argumentu</li>
        <li>W ścieżka chcąć skrócić sobie pisanie, możemy użyć tyldy
          (<strong>~</strong>) jako przedstawienia katalogu domowego.</li>
        <li>Chcąc przenieść się do katalogu nadrzędnego względem bierzącego
          nie musimy znać jego nazyw wystarczy że poleceniu <em>cd</em> podamy
          dwie kropki (<strong>..</strong>)</li>
      </ul>
      <p>
        Poniżej zamieściłem przykłady kilku z nich.
      </p>
<pre class="code-block">
[root@server1 ~]# cd -
/home/user
[root@server1 user]# cd ..
[root@server1 home]# cd 
</pre>
      <h3 id="2.3.4.tty">2.3.4. Identyfikacja urządzenia terminala</h3>
      <p>
        Czasmi może zajść potrzeba zidentyfikowania własnego urządania 
        terminalowego służy do tego polecenie <strong>tty</strong>. Jeśli 
        wynikiem działania tego polecenie będzie <em>/dev/pts*</em> oznacza to,
        że korzystamy z emulatora terminala np. programu Terminal w środowisku
        GNOME lub połączenia zdalnego za pomocą protokołu SSH. 
        Jeśli naszę urządzenie to <em>/dev/tty*</em> oznacza to, że
        korzystamy z jednej wirtualnych konsol dostępnych na komputerze.
      </p>
<pre class="code-block">
[root@server1 ~]# tty
/dev/pts/0
</pre>
      <h3 id="2.3.5.uptime">2.3.5. Czas systemowy oraz załadowanie procesora</h3>
      <p>
        W większości dostępnych Uniksów zapewne dostępne będzie polecenie 
        <strong>uptime</strong>. To niepozorne polecenie zawraca dużą ilość
        informacji.
      </p>
      <ul>
        <li>Czas systemowy,</li>
        <li>Ilość czasu jaka upłyneła od uruchomienia systemu (tzw. 
            <em>uptime</em>),</li>
        <li>Ilość zalogowanych do systemu użytkowników,</li>
        <li>Średnie załadowanie procesora w przeciągu minuty, 5 i 15 minut, ta
            wartość pokazuje zużycie procesora, podając wartości ułamkowe jeśli
            np. w ciągu jednej minuty jeden z wątków procesora był wykorzystany
            w 50% otrzymamy wynik 0.50. Jeśli posiadamy procesor wielordzeniowy, 
            ten wskaźnik może
            wskazywać wartości powyżej 1, oznacza to że procesy wykorzystują
            już więcej niż jeden wątęk/rdzeń.</li>.
      </ul>
<pre class="code-block">
[root@server1 ~]# uptime
 13:28:40 up 8 min,  1 user,  load average: 0.00, 0.12, 0.12
</pre>
      <h3 id="2.3.6.clear">2.3.6. Czyszczenie ekranu powłoki</h3>
      <p>
        Do czyszczenia terminala ze zbędnego wyjścia poleceń służy polcenie
        <strong>clear</strong> lub kombinacja klawiszy <em>CTRL+l</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# clear
</pre>
      <h3 id="2.3.7.which">2.3.7. Określanie ścieżki polecenia</h3>
      <p>
        Czasami w pewnych konfiguracjach lub też w skryptach powłoki niezbędne
        będzie podanie ścieżki do konkretnego programu kryjącego się za nazwą
        polecenia, w RHEL możemy zrobić to na trzy sposoby wykorzystując do
        tego różne polecenia. Polecenia podałem w przykładzie w raz z
        informacją zwracaną przez polecenie.
      </p>
<pre class="code-block">
$ which ls
alias ls='ls --color=auto'
	/usr/bin/ls

$ whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz

$ type ls
ls jest aliasem do ls --color=auto'
</pre>
      <p>
        Które z tych poleceń będzie właściwe to już zależy, do czego będą nam
        potrzebne tego typu informacje. Polecenie <em>whereis</em> wydaje się
        szczególnie pomocne.
      </p>
      <h3 id="2.3.8.uname">2.3.8. Wyświetlenie informacji o systemie</h3>
      <p>
        Polecenie <strong>uname</strong>, należy do poleceń, które są dość
        niepozorne, ale za pomocą jego opcji możemy otrzymać wersję użytego
        jądra, archtekturę systemu i tym podobne informacje. Polecenie bez 
        podania
        żadnej z opcji zwraca wyłącznie nazwę systemu i jest to <em>Linux</em>.
        Aby otrzymać wszelkie zwracane przez to polecenie informacje możemy 
        użyć opcji <em>-a</em>. Resztę opcji znajdziemy na stronach
        podręcznika (o tym będzie w dalszej częście materiału).
      </p>
<pre class="code-block">
$ uname -a 
Linux latitude-e5270 5.14.0-70.13.1.el9_0.x86_64 #1 SMP PREEMPT Thu Apr 14 12:42:38 EDT 2022 x86_64 x86_64 x86_64 GNU/Linux
</pre>
      <h3 id="2.3.9.lscpu">2.3.9. Wyświetlanie informacji o procesorze</h3>
      <p>
        W RHEL możemy łatwo sprawdzić informacje na temat zainstalowanego w
        naszym komputerze procesora w przystępny sposób. Do dyspozycji mamy
        bowiem polecenie <strong>lscpu</strong>. Wyświetla ono wszystkie
        dostępne informacje jakie może znaleźć w systemie na temat tego
        komponentu.
      </p>
<pre class="code-block">
[root@server1 ~]# lscpu
Architecture:            x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Address sizes:         39 bits physical, 48 bits virtual
  Byte Order:            Little Endian
CPU(s):                  1
  On-line CPU(s) list:   0
Vendor ID:               GenuineIntel
  Model name:            Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
    CPU family:          6
    Model:               78
    Thread(s) per core:  1
    Core(s) per socket:  1
    Socket(s):           1
    Stepping:            3
    BogoMIPS:            5004.62
    Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush
                          mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology
                          nonstop_tsc cpuid tsc_known_freq pni pclmulqdq monitor ssse3 cx16 pcid sse4_1 
                         sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm 3dnowpre
                         fetch invpcid_single pti fsgsbase avx2 invpcid rdseed clflushopt md_clear flush
                         _l1d
Virtualization features: 
  Hypervisor vendor:     KVM
  Virtualization type:   full
Caches (sum of all):     
  L1d:                   32 KiB (1 instance)
  L1i:                   32 KiB (1 instance)
  L2:                    256 KiB (1 instance)
  L3:                    3 MiB (1 instance)
NUMA:                    
  NUMA node(s):          1
  NUMA node0 CPU(s):     0
Vulnerabilities:         
  Itlb multihit:         KVM: Mitigation: VMX unsupported
  L1tf:                  Mitigation; PTE Inversion
  Mds:                   Mitigation; Clear CPU buffers; SMT Host state unknown
  Meltdown:              Mitigation; PTI
  Spec store bypass:     Vulnerable
  Spectre v1:            Mitigation; usercopy/swapgs barriers and __user pointer sanitization
  Spectre v2:            Mitigation; Retpolines, STIBP disabled, RSB filling
  Srbds:                 Unknown: Dependent on hypervisor status
  Tsx async abort:       Not affected
</pre>
      <h2 id="2.4.gettinghelp">2.4. Uzyskiwanie pomocy</h2>
      <h3 id="2.4.1.manpages">2.4.1. Strony podręcznika</h3>
      <p>
        W dystrybucjach Linuksa nie tylko w RHEL możemy znaleźć duża bazę
        zawierającą opisy poleceń, plików konfiguracyjnych oraz innych
        komponentów takich jak biblioteki. Służą temu strony podręcznika. Aby
        uzyskać do nich dostęp wystarczy wydać polecenie <strong>man</strong>
        podając jako argument interesujący na komponent. Nie zawsze musi być
        to polecenie. Strony podręcznika są podzielone na rozdziały czy też
        sekcje ich opisy oraz numery sa zawarte w na (o ironio) stronie
        podręcznika polecenia <em>man</em>. Wydaj poniższe polecenie aby
        zapoznać się z nim oraz z ich organizacją.
      </p>
<pre class="code-block">
$ man man
</pre>
      <p>
        Różne komponenty na Linuksie mogą mieć takie same nazwy. Polecenie
        <em>man</em> zwraca pierwsze znalezione wystąpienie, jeśli wpiszemy
        polecenie <code class="code-inline">man passwd</code> to otrzymamy
        informacje na temat polecenia, ale jeśli interesowałoby nas poznanie
        szczegółów pliku <em>/etc/passwd</em> musimy podać przed nazwą, numer
        sekcji odpowiedzialny za pliki konfiguracyjne.
      </p>
<pre class="code-block">
$ man 5 passwd
</pre>
      <p>
        Strony podręcznika, możemy przeszukiwać pod kątem występowania słów
        kluczowych, w przypadku kiedy znamy zagadnienie ale nie znamy
        odpowiedniego polecenia. Do tego celu możemy użyć opcji <em>-k</em>
        polecenia <em>man</em> lub polecenia <strong>apropos</strong>. Wynik 
        działania tych programów jest taki sam.
      </p>
<pre class="code-block">
$ apropos dos
dos2unix (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
mac2unix (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
unix2dos (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
unix2mac (1)         - konwerter formatu plików tekstowych między systemami DOS/Mac a Uniksem
dosfsck (8)          - check and repair MS-DOS FAT filesystems
dosfslabel (8)       - set or get MS-DOS filesystem label or volume ID
fatlabel (8)         - set or get MS-DOS filesystem label or volume ID
filesystems (5)      - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdo...
fs (5)               - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdo...
fsck.fat (8)         - check and repair MS-DOS FAT filesystems
fsck.msdos (8)       - check and repair MS-DOS FAT filesystems
fsck.vfat (8)        - check and repair MS-DOS FAT filesystems
mkdosfs (8)          - create an MS-DOS FAT filesystem
mkfs.fat (8)         - create an MS-DOS FAT filesystem
mkfs.msdos (8)       - create an MS-DOS FAT filesystem
mkfs.vfat (8)        - create an MS-DOS FAT filesystem
vdosetuuid (8)       - sets a new uuid for the vdo volume stored on a backing store
vdostats (8)         - Display configuration and statistics of VDO volumes
</pre>
      <p>
        W pierwszej kolumnie znajduje się nazwa komponentu, w drugiej numer
        sekcji a następnie krótki opis.
      </p>
      <p>
        Szukając opisu polecenia możemy posiłkować się poleceniem 
        <strong>whatis</strong>. Polecenie to poszukuje konkretnego komponentu
        na stronach podręcznika, a nie słowa kluczowego.
      </p>
<pre class="code-block">
$ whatis xdg-open 
xdg-open (1)         - opens a file or URL in the user's preferred application
</pre>
      <p>
        Polecenie <em>whatis</em>, zachowuje się identycznie jak polecenie
        <em>man</em> z opcją <em>-f</em>.
      </p>
      <h3 id="2.4.2.helpincommand">2.4.2. Pomoc w samym poleceniu</h3>
      <p>
        Inny sposobem niż wertowanie stron podręcznika w celu znalezienia
        odpowiedniej opcji jest po prostu wywołanie polecenie a opcją
        <strong>--help</strong>.
      </p>
<pre class="code-block">
$ ranger --help
Usage: ranger [options] [path]

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -d, --debug           activate debug mode
  -c, --clean           don't touch/require any config files.
  --logfile=file        log file to use, '-' for stderr
  --cachedir=dir        change the cache directory.
                        (/home/xf0r3m/.cache/ranger)
  -r dir, --confdir=dir
                        change the configuration directory.
                        (/home/xf0r3m/.config/ranger)
  --datadir=dir         change the data directory.
                        (/home/xf0r3m/.local/share/ranger)
  --copy-config=which   copy the default configs to the local config
                        directory. Possible values: all, rc, rifle, commands,
                        commands_full, scope
  --choosefile=OUTFILE  Makes ranger act like a file chooser. When opening a
                        file, it will quit and write the name of the selected
                        file to OUTFILE.
  --choosefiles=OUTFILE
                        Makes ranger act like a file chooser for multiple
                        files at once. When opening a file, it will quit and
                        write the name of all selected files to OUTFILE.
  --choosedir=OUTFILE   Makes ranger act like a directory chooser. When ranger
                        quits, it will write the name of the last visited
                        directory to OUTFILE
  --selectfile=filepath
                        Open ranger with supplied file selected.
  --show-only-dirs      Show only directories, no files or links
  --list-unused-keys    List common keys which are not bound to any action.
  --list-tagged-files=tag
                        List all files which are tagged with the given tag,
                        default: *
  --profile             Print statistics of CPU usage on exit.
  --cmd=COMMAND         Execute COMMAND after the configuration has been read.
                        Use this option multiple times to run multiple
                        commands.
</pre>
      <p>
        Posiadanie tej opcji nie jest standardem, wiec nie wszystkie polecenia
        będą ją mieć.
      </p>
      <h3 id="2.4.3.texinfo">2.4.3. Dokumentacja texinfo</h3>
      <p>
        Projekt GNU, zaproponował zmianę formatu dokumentacji programów, z
        suchych stron podręcznika do dokumentów przypominających ksiązkę lub
        inne dokumenty. Strony podręcznika nadal są podstawowym i wybudowanym
        (w większość dystrybcji) źródłem  wiedzy na temat systemu i jego 
        komponentów. 
        Nie mniej jednak jeśli uznamy, że zawartość strony podręcznika nie jest
        dla zadowalająca może spojrzeć też tam, o ile ten format jest
        zainstalowany w naszym systemie. Dostęp do niego uzyskujemy za pomocą
        polecenia <strong>info</strong> lub <strong>pinfo</strong>, następnie
        podając nazwę polecenia jako argument. Wydając samo polecenie
        <em>info</em>, możemy zobaczyć ile dokumentacji w formacie
        <em>texinfo</em> znajduje się w systemie.
      </p>
      <h3 id="2.4.4.usrsharedoc">2.4.4. /usr/share/doc</h3>
      <p>
        Innym miejscem przechowującym jakieś informacje na temat poleceń czy
        też programów może być katalog <em>/usr/share/doc</em>. Możemy w nim
        znaleźć na przykład domyślne plik konfiguracyjne wielu usług 
        (oczywiście zależy to czy zostaną one dodany do paczek z 
        oprogramowaniem). Nie należy jednak
        od razu skreślać tego katalogu, często mogą znajdować się tam
        informacje, których nie znajdziemy na stronach podręcznika czy w
        formacie <em>info</em> np. tutoriale lub gotowe konfiguracje.
      </p>
      <h3 id="2.4.5.rhdocs">2.4.5. Dokumentacja Red Hat Enterprise Linux</h3>
      <p>
        Innym źródłem informacji na temat obsługi systemu jest dokumentacja
        Red Hat dostępna w internecie (dla RHEL 9) pod tym adresem:
        <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9</a>
      </p>
      <p>
        Każdy zebranych tam tematów możemy pobrać w formacie HTML, PDF oraz
        ePub (czytniki e-booków).
      </p>
      <p class="exam_tip">
        <strong>Odnośnie egzaminu:</strong><br />
        Na egzaminie możemy korzystać ze wszystkiego co jest dostępne w systemie
        warto pamiętać o tym. Jeśli będziemy mieć problemy z poleceniem
        <em>man</em>, warto wydać polecenie <strong>mandb</strong> odświeży
        to bazę danych stron podręcznika.
      </p>
      <h3 id="exec2.1">Ćwiczenie 1: Nawigacja pośród katalogów Linuksa</h3>
      <p>
        Jako zwykły użytkownik na maszynie wirtualnej <em>server1</em>, 
        wyświetl ścieżkę na której
        się znajdujesz. W tym samym katalogu wyświetl wszystkie pliki.
        Przjedź do katalogu <em>/etc</em> następnie wyświetl ścieżkę, na której
        się znajdujesz, następnie powróć do poprzedniego katalogu i jeszcze
        raz wyświetl ścieżkę.
      </p>
      <h3 id="exec2.2">Ćwiczenie 2: Rożne zadania</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em> w terminalu 
        polecenie <em>tty</em>.
        Następnie uruchom kilka kart terminala wydaj w nich to samo polecenie
        i porównaj zwracane wartości. Wyświetl czas pracy systemu oraz 
        średnie obciążenie procesora. Za pomocą trzech poznanych poleceń 
        wyświetl lokalizacje polecenia <em>vgs</em>.
      </p>
      <h3 id="exec2.3">Ćwiczenie 3: Informacje o systemie</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em>
        za pomocą poznanego polecenia wyświetl wszystkie informacje o systemie
        (oczywście w miarę możliwości polecenia). Następnie użyj innego
        polecenia aby sprawdzić informacje na temat zainstalowanego w
        komputerze procesora.
      </p>
      <h3 id="exec2.4">Ćwiczenie 4: Używanie pomocy</h3>
      <p>
        Jako zwykły użytkownik na maszynie <em>server1</em>
        Wyświetl stronę podręcznika polecenia <em>uname</em> oraz stronę
        podręcznika dla pliku <em>/etc/shadow</em>. Wykonaj trzy polecenia:
        <code class="code-inline">apropos ext4</code>,
        <code class="code-inline">man -k ext4</code>,
        <code class="code-inline">whatis group</code>. Czym różnią się
        informacje zwracane przez te polecenia?
      </p>
      <h2 id="ch2summary">Podsumowanie</h2>
      <p>
        W tym rozdziale skupiliśmy się na podstawach obsługi systemu,
        poznaliśmy środowisko graficzne. Odświerzyliśmy sobie informacje na
        temat hierachicznego systemu plików wykorzystywanego w Uniksach.
        Zapoznaliśmy się z terminalem i podstawowymi polecenia. Na koniec
        dowiedzieliśmy się gdzie możemy szukać pomocy na temat poleceń, plików
        konfiguracyjnych i tego typu rzeczy.
      </p>
      <h1 id="3.fileoperations">3. Operacje na plikach</h1>
      <p>
        W poprzedni rodziale poznaliśmy podstawy poruszania się po systemie,
        przejrzeliśmy środowisko graficzne, zapoznaliśmy się z wierszem
        polecenia oraz z najbardziej podstawowymi poleceniami. Było to swoiste
        zapoznanie z systemem operacyjny. Teraz pora w nim trochę popracować.
        Ludzie zazwyczaj kiedy wspomagają swoją prace komputerem, pracują na
        danych. Te dane są zazwyczaj zebrane w pliki. Od omówienia rodzajów
        plików dostępnych na Linuksie ale i nie tylko rozpoczniemy ten rozdział.
      </p> 
      <h2 id="3.1.filetypes">3.1. Rodzaje plików</h2>
      <p>
        W Uniksach możemy wymienić 7 rodzajów różnych plików. W tych systemach
        nie jest istotne rozszerzenie oraz zawartość tych plików. Dla systemu
        zawsze będzie to <strong>zwykły plik</strong>. Wszystkie pliki nie
        wymienione na poniższej liście, które przyjdą na do głowy są plikami
        zwykłymi.
      </p>
      <p>
        Zatem w Uniksach możemy wyróżnić takie rodzaje plików jak:
      </p>
      <ul>
        <li><strong>Plik zwykły</strong> - plik zwykłe przechowywują dane, są
          to wszelkiej maści pliki tekstowe, pliki binarne z programami oraz
          inne.</li>
        <li><strong>Katalog</strong> - jest struktura organizacyjna systemu
          plików, stosowana w celach organizacyjnych zwykłych plików w systemie
          plików.</li>
        <li><strong>Plik urządzenia znakowego</strong> - w przypadku określenia
          <em>znakowy</em> stosuje się także określenie <strong>surowy</strong>
          (ang. <em>raw</em>). Pliki te wykorzystywane są do komunikacji z
          urządzaniami wykorzysującymi interfejs szeregowy.</li>
        <li><strong>Pliki urządzeń blokowych</strong> - Pliki te wykorzystywane
          są do komunikacji z urządzeniami wykorzystującymi interfejs
          równoległy. Głównie są to dyski.</li>
        <li><strong>Dowiązania symboliczne</strong> - przypominają skróty z
          z innych systemów operacyjnych. Jest to plik wskazujący na inny
          plik lub katalog.</li>
        <li><strong>Nazwane potoki, gniazda</strong> - są to pliki, które
          służą komunikacji miedzyprocesowej. Omawianie ich tutaj wychodzi
          poza ramy tego materiału.</li>
      </ul>
      <p>
        Nie ma się też za bardzo co rozwodzić nad każdym z tych typów plików.
        Wskaźnikiem rodzaju pliku podczas wyświetlania zawartości katalogu
        jest pierwszy znak w pierwszej kolumnie informacji zwracanej przez
        polecenie <em>ls -l</em>. Informacje zwracane dla poszczególnych
        typów pliku wyglądają następująco:
      </p>
<pre class="code-block">
#Zwykły plik:
[root@server1 ~]# ls -l anaconda-ks.cfg 
-rw-------. 1 root root 1197 Jun  9 19:59 anaconda-ks.cfg

#Katalog:
[root@server1 ~]# ls -ld bzipped/
drwxr-xr-x. 3 root root 17 Jun 16 18:14 bzipped/

#Urządzenie znakowe:
[root@server1 ~]# ls -l /dev/console
crw--w----. 1 root tty 5, 1 Jun 17 15:20 /dev/console

#Urządzenie blokowe:
[root@server1 ~]# ls -l /dev/sda1
brw-rw----. 1 root disk 8, 1 Jun 17 15:20 /dev/sda1

#Dowiązanie symboliczne:
[root@server1 ~]# ls -l soft10 
lrwxrwxrwx. 1 root root 6 Jun 16 17:30 soft10 -&gt; file10
</pre>
      <p>
        Pierwsze znaki, pierwszej kolumny róznią się od siebie w zależności
        od typu plików. Jest jeszcze kilka róznic. Pliki urządzeń nie posiadają
        rozmiaru, tylko dwie liczby oddzielone od siebie przecinkiem. Te liczby
        to numer główny oraz numer poboczny. Numer główny określa rodzaj
        urządzenia, z kolei numer podobczny jest jego unikalny identyfikatorem
        w systemie. Innym rodzajem, który jest plikiem, ale jednak nie plikiem
        jest dowiązanie symboliczne wrócimy do tego typu plików poźniej.
      </p>
      <p>
        Te informacje które są zwracane oprócz nazwy pliku przez polecenie,
        które wyświetla zawartość katalogu to tak zwane 
        <strong>meta-dane</strong>, bardziej szczegółowo możemy wyświetlić je
        za pomocą polecenia <strong>stat</strong>. Na poniższym przykładzie
        zamieszczono bardziej szczegółowe meta-dane zwykłego pliki z
        poprzedniego przykładu:
      </p>
<pre class="code-block">
[root@server1 ~]# stat anaconda-ks.cfg 
  File: anaconda-ks.cfg
  Size: 1197      	Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d	Inode: 6126703     Links: 1
Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)
Context: system_u:object_r:admin_home_t:s0
Access: 2022-06-16 10:37:11.765639347 +0200
Modify: 2022-06-09 19:59:42.592326645 +0200
Change: 2022-06-09 19:59:42.592326645 +0200
 Birth: 2022-06-09 19:59:42.237318552 +0200
</pre>
      <p>
        Zwykłe pliki na Uniksach nie muszą mieć rozszerzenia, wiec aby przed
        uruchomieniem pliku upewnić się co to jest mamy do dyspozycji takie
        narzędzie jak program <strong>file</strong>, który zbada zawartość
        podanego mu w argumencie pliku. 
      </p>
<pre class="code-block">
[root@server1 ~]# file test 
test: Bourne-Again shell script, ASCII text executable
</pre>
      <p>
        Plik nie ma rozszerzenia <em>.sh</em> a mimo to pozostaje skryptem
        powłoki.
      </p>
      <h2 id="3.2.compressionandarchiving">3.2. Kompresja i archiwizowanie</h2>
      <p>
        Kompresja pozwala na zmnieszenie objętości plików za pomocą
        zaawansowanych algorytmów, dzięki czemu możemy zaoszczędzić miejsce
        na dysku, jednak wadą takiego przechowywania danych jest dłuższy
        czas oczekiwania na ich gotowość do pracy ponieważ dane przed tym
        należy zdekompresować. Archizowanie może służyć to zebranie wielu
        małych plików w jeden duży. Na Uniksach możemy wymieć dwa natywne
        narzędzia służące do kompresji i jedno do archiwizowania.
      </p>
      <h3 id="3.2.1.gzip">3.2.1. gzip</h3>
      <p>
        Natywnym i dostępnym na każdym systemie sposobem na kompresje danych
        jest <strong>gzip</strong>. Algorytmy zawarte w tym narzędziu
        kompresują dane, powodując ich mniejszą objętość. Narzędzie do każdego
        skompresowanego pliku dodaje rozszerzenie <em>.gz</em>. Aby 
        skompresować plik wystarczy podać jego nazwę lub ścieżkę do niego jako
        argument poleceniu <em>gzip</em>.
      </p>
<pre class="code-block">
#Plik przed kompresją
[root@server1 ~]# ls -l fstab 
-rw-r--r--. 1 root root 579 Jun 16 11:07 fstab

#Plik po kompresji
[root@server1 ~]# ls -l fstab.gz 
-rw-r--r--. 1 root root 350 Jun 16 11:07 fstab.gz
</pre>
      <p>
        Jak możemy zauważyć rozmiar pliku zmniejszył sie. Zwróćmy uwagę na to
        iż narzędzie nie działa na kopii pliki tylko kompresuje bezpośrednio
        podany plik. Aby plik zdekompresować możemy użyć polecenia 
        <strong>gunzip</strong>
      </p>
<pre class="code-block">
[root@server1 ~]# gunzip fstab.gz
</pre>
      <p>
        Dla plików skompresowanych za pomocą polecenia <em>gzip</em>, możemy
        podejrzeć listę skompresowanych plików (w przypadku jednego pliku
        może być to użyteczne do wyświetlenia statystki kompresji) 
        wykorzystując 
        opcje <em>-t</em> i podając jako argument skompresowany plik.
      </p>
<pre class="code-block">
[root@server1 ~]# gzip -l fstab.gz 
         compressed        uncompressed  ratio uncompressed_name
                350                 579  43.7% fstab
</pre>
      <h3 id="3.2.2.bzip">3.2.2. bzip2</h3>
      <p>
        Program <em>bzip2</em> jest obecnie standardem kompresji, wśród wielu
        Uniksów. Jest wolniejszy od <em>gzip</em>, ale skompresowane przez
        niego pliki są mniejsze. Więc pozostaje w naszej gestii, który z nich
        będziemy stosować. Do skompresowanych przez <em>bzip2</em> plików
        dodawane jest rozszerzenie <em>.bz2</em>. A kompresja za pomocą tego
        narzędzia wygląda następująco:
      </p>
<pre class="code-block">
[root@server1 ~]# ls -lh test
-rw-r--r--. 1 root root 250M Jun 17 17:21 test
[root@server1 ~]# bzip2 test 
[root@server1 ~]# ls -lh test.bz2 
-rw-r--r--. 1 root root 210 Jun 17 17:23 test.bz2
</pre>
      <p>
        Dekompresja takiego pliku takiego pliku wyglada analogicznie do
        narzędzia <em>gunzip</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# bunzip2 test.bz2
[root@server1 ~]# ls -lh test 
-rw-r--r--. 1 root root 250M Jun 17 17:25 test
</pre>
      <p>
        W przypadku polecenia <em>bzip2</em> nie mamy możliwośći wyświetlenia
        listy skompresowanych plików (statystyk kompresji).
      </p>
      <h3 id="3.2.3.tar">3.2.3. tar</h3>
      <p>
        Program <strong>tar</strong> nie służy do kompresji, a do archiwizcji 
        jego zadaniem jest stworzenie jednego pliku z wielu innych plików lub 
        z całego katalogu. Na początku program swojego istnienia program 
        <em>tar</em> domyślnie tworzył archiwa na napędach taśmowych, dlatego
        też jeśli ma on tworzyć archiwum do pliku potrzebna będzie odpowiednia
        opcja, i ta funkcjonalność pozostała po dziś dzień.
      </p>
      <p>
        Opcje tego programu możemy podawać na trzy różne sposoby, wpisując
        z myślnikami każdą opcje po kolei, wypisując opcje pod jednym
        myślnikiem, lub nie używać myślnika w ogóle. Do stworzenia archiwum
        potrzebujemy dwóch opcji, pierwszej <em>-c</em> - tworzącej archiwum
        oraz drugiej <em>-f</em> - nakazujące stworzenie archiwum w podanym
        jako argument opcji pliki. Poniżej znajdują się opisane wyżej użycia
        polecenia <em>tar</em> do stworzenia archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -c -f etc_tarred.tar /etc
tar: Removing leading `/' from member names
[root@server1 ~]# tar -cf etc_tarred1.tar /etc
tar: Removing leading `/' from member names
[root@server1 ~]# tar cf etc_tarred2.tar /etc
tar: Removing leading `/' from member names
</pre>
      <p>
        Zwróćmy uwagę na komunikat programu, który usuwa ze scieżek
        wskazujących pliki (ponieważ użyłem ścieżki bezwzględnej) początkowy
        ukośnik, aby przy wypakowywaniu nie nadpisać ważnych plików 
        systemowych. Warto dodać, iż ja tworzyłem te archiwa jako 
        superużytkownik, w momencie gdy <em>root</em> używa polecenia
        <em>tar</em>, używana jest domyślnie opcja <em>-p</em>, która powoduje
        zachowanie wszystkich atrybutów plików, w przypadku zwykłego
        użytkownika ta opcja musi zostać jawnie podana.
      </p>
      <p>
        Rozpakowanie archiwum wymaga podania opcji <em>-x</em> oraz opcji
        <em>-f</em> ze wskazaniem pliku archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -xf etc_tarred1.tar -C /tmp
[root@server1 ~]# ls -ld /tmp/etc
drwxr-xr-x. 132 root root 8192 Jun 17 15:20 /tmp/etc
</pre>
      <p>
        W tym przykładzie użyłem jeszcze jednej ważnej opcji <em>-C</em>, która
        nakazuje poleceniu <em>tar</em> zmianę katalogu przed wypakowaniem
        archiwum.
      </p>
      <p>
        Za pomocą opcji <em>-t</em>, możemy podejrzeć zawartość archiwum.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -tvf etc_tarred2.tar
drwxr-xr-x root/root         0 2022-06-17 15:20 etc/
lrwxrwxrwx root/root         0 2022-06-09 19:47 etc/mtab -&gt; ../proc/self/mounts
-rw-r--r-- root/root       579 2022-06-09 19:44 etc/fstab
-rw------- root/root         0 2022-06-09 19:44 etc/crypttab
drwxr-xr-x root/root         0 2022-06-09 19:47 etc/lvm/
drwxr-xr-x root/root         0 2022-06-09 19:44 etc/lvm/devices/
-rw-r--r-- root/root       286 2022-06-09 19:44 etc/lvm/devices/system.devices
drwx------ root/root         0 2022-06-09 20:48 etc/lvm/archive/
-rw------- root/root      1891 2022-06-09 20:48 etc/lvm/archive/rhel_00000-557804270.vg
drwx------ root/root         0 2022-06-09 20:48 etc/lvm/backup/
-rw------- root/root      1890 2022-06-09 20:48 etc/lvm/backup/rhel
drwx------ root/root         0 2022-02-16 13:01 etc/lvm/cache/
-rw-r--r-- root/root    111694 2022-02-16 13:01 etc/lvm/lvm.conf
-rw-r--r-- root/root      2299 2022-02-16 13:01 etc/lvm/lvmlocal.conf
...
</pre>
      <p>
        Chcąc dodać plik do archiwum, wystarczy użyć opcji <em>-r</em> nie
        trzeba go rozpakowywać i dodawać tych plikiów wystarczy wskazać
        archiwum a następnie pliki, które chce się dodać.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -rvf etc_tarred2.tar vipractice.bz2 
vipractice.bz2

[root@server1 ~]# tar -tvf etc_tarred2.tar
...
-rw-r--r-- root/root       208 2022-06-09 19:46 etc/.updated
-rw-r--r-- root/root       307 2022-06-16 18:38 vipractice.bz2
</pre>
      <p>
        Dodawaniu plików nie służy wyłącznia opcja <em>-r</em>, ale również
        <em>-u</em>, która dodaje nowsze pliki na końcu archwium przez to
        wyświetlając zawrtość takiego archiwum, możemy zobaczyć pliki o tych
        samych nazwach. Te nazwy oczywiście odpowiadają różnym wersjom tych
        plików.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -uvf etc_tarred.tar /etc/nanorc
tar: Removing leading `/' from member names
/etc/nanorc
tar: Removing leading `/' from hard link targets

[root@server1 ~]# tar -tvf etc_tarred2.tar
...
-rw-r--r-- root/root       208 2022-06-09 19:46 etc/.updated
-rw-r--r-- root/root     10373 2022-06-19 09:47 etc/nanorc
</pre>
      <p>
        Po zebraniu wszystkich plików do archiwum, może ono przybrać na
        rozmiarze. Polecenie <em>tar</em>, pozwala na zastosowanie poznanych
        wcześniej algorytmów kompresji.
      </p>
      <ul>
        <li><strong>gzip:</strong> opcja <em>-z</em>
<pre class="code-block">
[root@server1 ~]# tar -czf etc-gzipped.tar.gz /etc
</pre>
        </li>
        <li><strong>bzip2:</strong> opcja <em>-j</em>
<pre class="code-block">
[root@server1 ~]# tar -cjf etc-bzipped.tar.bz2 /etc
</pre>
        </li>
      </ul>
      <p>
        Rozpakowując skompresowane archiwa w RHEL możemy rozpakować podając
        takie same opcje jak w przypadku nie skompresowanych archiwów.
      </p>
<pre class="code-block">
[root@server1 ~]# tar -xf etc-gzipped.tar.gz -C /tmp
</pre>
      <p>
        Program rozpozna po zawartości pliku algortym kompresji. Wiecej
        informacji na temat polecenia <em>tar</em> znajduje na stronie
        podręcznika.
      </p>
      <p class="exam_tip">
        Na egzaminie będziemy mieć określną ilość czasu na wykonanie zadań
        egzaminacyjnych, dlatego też operacje kompresji czy archiwizacji
        plików będą przeprowadzane na małych plikach, aby nie tracić czasu.
      </p> 
      <h2 id="3.3.vim">3.3. Edycja plików za pomocą edytora Vim</h2>
      <p>
        Podczas wykonywania zadań związanych z administracją system, niezbędna
        może być edycja jakiegoś pliku. Edytor <strong>Vim</strong> jest 
        standardem jeśli
        chodzi o edycje plików. Ten edytor w wersji podstawowej jaką jest
        program <em>Vi</em> jest dostępny w większości Uniksów. W przypadku
        w wielu dystrybucji Linuksa preinstalowany jest <em>Vim</em>. Lepiej
        jest nauczyć się rozwiązania, które możemy zastosować beż żadnej
        ingerencji w system (bez instalacji ulubionego edytora, który znamy).
      </p>
      <p>
        Edytor <em>Vim</em> może działać w trzech trybach:
      </p>
      <ul>
        <li><strong>tryb poleceń</strong> - domyślny tryb pracy programu,
          <em>Vim</em> oczekuje na wprowadzenie polecenia. Ten tryb jest
          uruchamiany w momencie uruchomienia programu. Polecenia są
          przypisane do poszczególnych znaków na klawiaturze.</li>
        <li><strong>tryb wprowadzania</strong> - tryb ten służy do edycji
          tekstu, uruchamiany za pomocą polecenia <em>i</em> lub <em>a</em>.</li>
        <li><strong>tryb ostatniej lini</strong> - ten tryb możemy również
          nazwać wierszem polecenia. Urchamiany jest poprzez wciśniecie
          dwukropka (<strong>:</strong>) w trybie poleceń. Po tym znaku
          podajemy polecenie.</li> 
      </ul>
      <h3 id="3.3.1.startingvim">3.3.1. Podstawy obsługi Vim</h3>
      <p>
        Edytor vim uruchamiamy, jak każde inne polecenie. Podając jego nazwę
        w wierszu polecenia. Podczas uruchamiania możemy podać plik jako
        argument, lub też użyć polecenia trybu ostatniej linii <em>:o</em>
        po czym podać ścieżkę do pliku.
      </p>
<pre class="code-block">
[root@server1 ~]# vim test.txt
</pre>
      </p>
        Poruszanie po tekscie odbywa się w trybie poleceń za pomocą klawiszy:
      </p>
      <ul>
        <li><strong>h</strong> - przesunięcie kursora w lewo</li>
        <li><strong>j</strong> - przesunięcie kursora w dół</li>
        <li><strong>k</strong> - przesunięcie kursora w górę</li>
        <li><strong>l</strong> - przesunięcie kursora w prawo</li>
      </ul>
      <p>
        Przejście do edycji tekstu, wymaga użycia polecenia <strong>i</strong> 
        co spowoduje rozpoczęcie edycji w pozycji kursora lub polecenia 
        <strong>a</strong>, które spowoduje przesunięcie kursora o jedną 
        pozycję i rozpoczęcie edycji, polecenie <em>a</em> możemy tłumczyć 
        jako dopisywanie (ang. <em>append</em>), a <em>i</em> jako wprowadzanie 
        (ang. <em>insert</em>).
      </p>
      <p>
        Opuszczenie trybu wprowadzania i powrót do trybu polecenia wymagania
        naciśnięcia klawisza <em>Esc</em> (escape). Przjście do trybu polecenia
        jest wymgane, aby przenieść kursor w inne miejsce. W tym trybie również
        zapisuje oraz opuszczamy edytor. Zmiany w tekscie również możemy
        porzućić, nie musimy ich zapisywać poniżej umieściłem kilka poleceń
        trybu ostatniej linii, służacych od zapisywania i opuszczania edytora.
      </p>
      <ul>
        <li><strong>:w</strong> - zapisanie zmian w pliku oraz pozostanie w
          w edytorze</li>
        <li><strong>:x</strong> - zapisanie zmian w pliku oraz opuszczenie
          <em>Vim</em></li>
        <li><strong>:q</strong> - opuszczenie <em>Vim</em>.</li>
      </ul>
      <p>
        Każdej z tych opcji może towarzyszyć wykrzyknik (<strong>!</strong>),
        więc jeśli chcielibyśmy porzucić zmiany w pliku i wyjść należy użyć
        polecenia <em>:q!</em>. Możemy czasami spotkać się z uprawnieniami,
        które nie pozwolą nam zapisać zmian w pliku. Rozwiązać tego typu
        problem możemy dwa sposoby, wymusić zapisanie zamian za pomocą
        wykrzyknika, lub podać ścieżkę do nowego pliku poleceniu <em>:w</em>.
      </p>
      <h3 id="3.3.2.othervimcommands">3.3.2. Pozostałe polecenia Vim</h3>
      <p>
        Vim posiada bogatą kolekcję poleceń trybu polecnia oraz trybu ostatniej
        linii, na poniższej liście znajdują się część z nich, możemy
        wykorzystać je do sprawniejszego używania edytora <em>Vim</em>.
      </p>
      <p><strong>Komendy trybu poleceń:</strong></p>
      <ul>
        <li><strong>^ - Shift + 6</strong> - Przeniesie kursora na początek
          linii.</li>
        <li><strong>$ - Shift + 4</strong> - Przeniesie kursora na koniec 
          linii.</li>
        <li><strong>Ctrl+f</strong> - przewinięcie tekstu o jedną stronę w
          przód.</li>
        <li><strong>Ctrl+b</strong> - przewinięcie tesktu o jedną stronę w
          tył.</li>
        <li><strong>x</strong> - usunięcie znaku wskazywanego przez kursor,
          znak tak naprawdę zostaje wycięty, i poźniej może zostać wklejony.</li>
        <li><strong>dd</strong> - usunięcie/wycięcie całej linii, linia
          podobnie jak znak może zostać wklejona.</li>
        <li><strong>v</strong> - przejście <em>Vim</em> w tryb wizualny
          (tutaj nie omawiany), pozwala zaznaczać tekst co ułatwia kopiowanie
          oraz wycinanie.</li>
        <li><strong>y</strong> - kopiowanie zaznaczenia w trybie wizualnym.</li>
        <li><strong>d</strong> - wycinanie/usuwanie w trybie wizualnym.</li>
        <li><strong>p</strong> - wklejanie.</p>
        <li><strong>u</strong> - cofnięcie się o jedną zmianę, odpowiednik
          <em>Ctrl+z</em>.</li>
        <li><strong>Ctrl+r</strong> - tzw. redo, powrót do stanu przed
          cofnięciem zmiany. Czasami bardzo przydatna funkcja.</li>
        <li><strong>. - kropka</strong> - powtórzenie ostatniego polecenia.
          Jeśli ostatnim poleceniem było wprowadzanie, to, to polecenie wklei
          cały wprowadzony tekst do momentu zmiany polecenia.</li>
        <li><strong>/ - slash</strong> - przeszukiwanie tekstu w przód.</li>
        <li><strong>? - znak zapytania</strong> - przeszukiwanie tekstu w tył.</li>
        <li><strong>n</strong> - następne wystąpienie frazy w tekście</li>
        <li><strong>N</strong> - poprzednie wystąpienie frazy w tekscie. W
          przypadku przeszukiwania w tył, działanie poleceń <em>n</em> oraz
          <em>N</em> jest odwrócone.</li>
      </ul>
      <p>
        W przypadku tryb poleceń, możemy zwielokrotnić działanie tych poleceń,
        stawiając liczbę wykonywania tego polecenia. Na przykład jeśli chcemy
        usunąć 3 linie to zamiast wydawać trzykrotnie polecenie <em>dd</em>,
        możemy nacisnąć <em>3</em> następnie <em>dd</em> i trzy linie spod
        kursora zostaną usunięte/wycięte.
      </p>
      <p><strong>Polecenia trybu ostatniej linii:</strong></p>
      <ul>
        <li><strong>:set number</strong> - ustawienia numerowanie linii.</li>
        <li><strong>:o</strong> - otwiera plik, jako argument podajemy ścieżekę
          do pliku.</li>
        <li><strong>:%s/old/new</strong> - zamiana pierwszego wstąpienia słowa 
          <em>old</em> słowem <em>new</em>.</li>
        <li><strong>:%s/old/new/g</strong> - zamiana wszystkich wystąpień słowa
          <em>old</em> słowem <em>new</em>.</li>
        <li><strong>:6,11co4</strong> - polecenie kopiuje zawrtość linii od
          6 do 11 i wkleja ją po 4 linii.</li>
        <li><strong>:3,5m6</strong> - polecenie przenosii linię od 3 do 5 na
          miejsce po linii numer 6.</li>
        <li><strong>:6,8d</strong> - polecenie usuwa linie od 6 do 8.</li>
        <li><strong>:r</strong> - polecenie wprowadza w miejscu kursora
          zawartość pliku podanego jako argument.
      </ul>
      <p>
        Podczas korzystania <em>Vim</em> istotna jest praktyka. Dlatego trzeba
        przesiąść się na niego i zacząć tworzyć w nim pliki.
      </p>
      <p class="exam_tip">
        Podczas egzaminu, możemy spotkać się z zadaniem w którym trzeba
        zmienić jakiś plik. Dostępność <em>Vim</em> na maszynie
        egzaminacyjnej jest niemal pewna, dlatego też nauczenie się jego 
        obsługi jest dość istotne.
      </p>
      <h2 id="3.4.filesanddirectories">3.4. Pliki i katalogi</h2>
      <p>
        Jaka kolwiek praca z komputerem prędzej czy poźniej będzie wymagać
        operacji na plikach i katalogach. Poniżej przedstawiam najprostsze
        czynności takie możemy wykonywać na tych elementach. 
      </p>
      <h3 id="3.4.1.createfilesanddirs">3.4.1. Tworzenie plików i katalogów</h3>
      <p>
        Tworzenie plików może zrealizować na kilka sposób. Jednym z nich jest
        wykorzystanie polecenia <strong>touch</strong>, które służy generalnie
        do uaktualnienia czasów dostępu oraz modyfikacji, jednak kiedy podany
        plik nie istnieje to zostanie on utworzony przez to polecenie.
      </p>
<pre class="code-block">
[root@server1 ~]# touch plik1
[root@server1 ~]# ls -l plik1
-rw-r--r--. 1 root root 0 Jun 19 14:52 plik1
</pre>
      <p>
        Jak widać na powyższym przykładzie został utworzony plik, którego
        wielkość to całe 0 bajtów. Innym sposobem na utworzenie katalog jest
        wykorzystanie polecenia <em>Vim</em>, w którym zapisując zmiany w 
        nowym pliku, tworzymy go mimochodem. Ostanim ze sposobów jest
        utworzenie plików ze strumienia (stumienie będą opisywane w dalszej
        części tego materiału), za pomocą polecenia <strong>cat</strong>,
        który omówimy sobie w następnym podrozdziale. Wydając następujące
        polecenie:
      </p>
<pre class="code-block">
[root@server1 ~]# cat &gt; plik2
test1
test2
test3
test4
test5
</pre>
      <p>
        Uruchamiając to polecenie przełączymy strumienie tak, aby wszystko
        co zostanie wpisane do terminala trafi do pliku (w dużym skrócie). Taką
        edycję pliku możemy zakończyć naciskając kombinacje klawiszy
        <em>Ctrl+d</em>.
      </p>
      <p>
        Za tworzenie katalogów odpowiedzialne jest polecenie 
        <strong>mkdir</strong>. Polecenie to utworzy katalog o nazwie podanej
        jako argument. Ważną opcją tego polecenia jest <em>-p</em>, za pomocą
        które jesteśmy wstanie tworzyć z poziomu pojedyńczego polecenia całe
        struktury katalogów. Opcja ta powoduje utworzenie katalogów podanych
        na ścieżce, które nie istnieją.
      </p>
<pre class="code-block">
[root@server1 ~]# mkdir dir1
</pre>
      <h3 id="3.4.2.listingfiles">3.4.2. Wyświetlanie zawartości pliku</h3>
      <p>
        Na Uniksach do wyświetlania zawartości plików mamy kilka rozwiązań
        pierwszym z nich jest wspomanianie już polecenie <strong>cat</strong>.
        Polecenie wyświetli zawartość pliku podanego jako argument w terminalu.  
      </p>
<pre class="code-block">
[root@server1 ~]# cat plik2 
test1
test2
test3
test4
test5
</pre>
      <p>
        Na Uniksach, obok polecenia <em>cat</em> występuje polecenie
        <strong>tac</strong>, która ma takie samo zastosowanie jak to wyżej
        wymienione, wyświetlając je jednak odwrotnie od końca. Poniższy
        przykład zaraz to zobrazuje:
      </p>
<pre class="code-block">
[root@server1 ~]# tac plik2 
test5
test4
test3
test2
test1
</pre>
      <p>
        Podczas wyświetlania dużych plików ich zawartość może mieścić się na
        ekranie, czy też w oknie terminala. Do wyświetlania tego typu plików
        wykorzystuje się takie polecenia jak <strong>more</strong> czy
        <strong>less</strong>. Oba dzielą wyświetloną treść plików na strony
        wielkości ekranu czy terminala. Program <em>more</em> nie jest za
        bardzo zaawansowanym narzędziem, wyświetlając pliki za jego pomocą nie
        mamy zbyt duże pola manewru. Możemy przesuwać stronę po stronie, do
        końca pliku. Nie możemy się cofnąć, dlatego jeśli chcielibyśmy wróć do
        poprzedniej strony, musielibyśmy zakończyć działanie programu i
        uruchomić go od nowa. Dlatego też znacznie lepszym rozwiązaniem jest
        wykorzystanie polecenia <em>less</em>, który pozwala poruszać się
        po tekscie w góre i w dół, ale również pozwala na wyszukiwanie, oraz
        możemy go obsługiwać za pomocą klawiszy znanych z nawigacji programem
        <em>Vim</em>. Program <em>less</em> uruchomi się szybciej niż, program
        <em>more</em> ponieważ nie musi on załadować całego pliku od razu.
      </p>
<pre class="code-block">
[root@server1 ~]# less /var/log/messages
</pre>
      <p>
        Ostatnim już sposoben na wyświetlenie zawartości plików jest, użycie
        polecenia <strong>head</strong> oraz <strong>tail</strong>, ich
        zadaniem jest wyświetlenie kilku początkowych (domyślnie 10) linii
        z podanego jako argument pliku - polecenie <em>head</em> lub kilku
        ostatnich (również 10) linii z podanego pliku - polecenie <em>tail</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# tail /var/log/messages
Jun 19 13:59:33 server1 systemd[1]: Finished dnf makecache.
Jun 19 14:18:23 server1 cupsd[964]: REQUEST localhost - - "POST / HTTP/1.1" 200 182 Renew-Subscription successful-ok
Jun 19 15:16:43 server1 cupsd[964]: REQUEST localhost - - "POST / HTTP/1.1" 200 182 Renew-Subscription successful-ok
Jun 19 15:28:22 server1 systemd[1]: Starting dnf makecache...
Jun 19 15:28:23 server1 dnf[2173]: Updating Subscription Management repositories.
Jun 19 15:28:23 server1 dnf[2173]: Unable to read consumer identity
Jun 19 15:28:23 server1 dnf[2173]: This system is not registered with an entitlement server. You can use subscription-manager to register.
Jun 19 15:28:23 server1 dnf[2173]: Metadata cache refreshed recently.
Jun 19 15:28:23 server1 systemd[1]: dnf-makecache.service: Deactivated successfully.
Jun 19 15:28:23 server1 systemd[1]: Finished dnf makecache.
</pre>
      <p>
        Domyślną ilość wypisywanych linii możemy regulować poprzez podanie po
        myślniku (<strong>-</strong>) żądanej liczby.
      </p>
<pre class="code-block">
[root@server1 ~]# tail -5 /var/log/messages
Jun 19 15:28:23 server1 dnf[2173]: Unable to read consumer identity
Jun 19 15:28:23 server1 dnf[2173]: This system is not registered with an entitlement server. You can use subscription-manager to register.
Jun 19 15:28:23 server1 dnf[2173]: Metadata cache refreshed recently.
Jun 19 15:28:23 server1 systemd[1]: dnf-makecache.service: Deactivated successfully.
Jun 19 15:28:23 server1 systemd[1]: Finished dnf makecache.
</pre>
      <p>
        Polecenie <em>less</em> ma jedną bardzo istoną opcję, która pozwala
        śledzić na bierząco zmiany w pliku, ta opcja to <em>-f</em>.
      </p>
      <p>
        Poleceniem związanym z zawartością plików, ale nie z jej wyświetlaniem
        może być polecenie <strong>wc</strong>, które domyślnie wyświetla
        ilość linii, liczbe słów oraz bajtów. 
      </p>
<pre class="code-block">
[root@server1 ~]# wc /var/log/messages
  639  7503 61333 /var/log/messages
</pre>
      <h3 id="3.4.3.copyingandmoving">3.4.3. Kopiowanie i przenoszenie plików
        i katalogów</h3>
      <p>
        Pracując z plikami, być może wystąpi potrzeba skopiowania danych bądź
        przeniesienia danych w inne miejsce. Za operacje kopiowania
        odpowiedzialnie jest polecenie <strong>cp</strong>. Jako pierwszy
        argument przyjmuje ono scieżkę lub plik źródłowy, jako drugi ścieżke
        lub plik docelowy.
      </p>
<pre class="code-block">
[root@server1 ~]# cp plik2 plik3
</pre>
      <p>
        W przypadku gdy dany plik już istnieje w podanym katalogu polecenie
        zapyta się czy nadpisać docelowy plik, ale tylko w przypadku
        użytkownika, bowiem on w konfiguracji swojej powłoki posiada 
        <em>alias</em>
        (nazwę zastępcza) <em>cp</em> dla polecenia <em>cp -i</em>, opcja
        <em>-i</em> włącz tryb interaktywy, czyli właśnie takie pytania.
      </p>
<pre class="code-block">
[root@server1 ~]# cp plik1 plik3 
cp: overwrite 'plik3'? n
</pre>
      <p>
        Za pomocą polecenia <em>cp</em> możemy kopiować całe katalogi z
        podkatalogami przy użyciu opcji <em>-r</em>, która włacza kopiowanie
        rekrencyjne. Jeśli atrybuty plików są dla nas waża, to żeby nie
        nadpisać ich należy użyć opcji <em>-p</em>.
      </p>
      <p>
        Za przenoszenie plików odpowiedzialne jest polecenie 
        <strong>mv</strong>, które ma jeszcze jedną ważną cechę ukrytą w
        mechnice swojego działa. Otóż jeśli będzie przenośić plik lub katalog
        w ramach tego samego katalogu, to zmieni on tylko swoją nazwę.
      </p>
      <p>
        Polecenie <em>mv</em> w przypadku superużytkownika, posiada podobny
        alias co w przypadku polecenia <em>cp</em>, polecenie jest uruchamiane
        domyślnie z opcją pytającą o nadpisanie elementu docelowego.
      </p>
<pre class="code-block">
[root@server1 ~]# mv plik1 plik3 
mv: overwrite 'plik3'? n
</pre>
      <p>
        Polecenie <em>mv</em> nie potrzebuje żadnej opcji, aby
        przenieść cały katalog wraz z podkatalogami.
      </p>
<pre class="code-block">
[root@server1 ~]# mv gzipped /tmp
[root@server1 ~]# ls -ld /tmp/gzipped/
drwxr-xr-x. 3 root root 17 Jun 16 18:14 /tmp/gzipped/
</pre>
      <h3 id="3.4.5.removefilesanddirs">3.4.5. Usuwanie plików i katalogów</h3>
      <p>
        Zbędne plik i katalogi możemy usunąć, za pomocą polecenia <em>rm</em>.
        Polecenie do usunięcie katalogu wymaga podania nazwy pliku jako
        argumentu.
      </p>
<pre class="code-block">
[root@server1 ~]# rm plik1 
rm: remove regular empty file 'plik1'? y
</pre>
      <p>
        Polecenie <em>rm</em> również jest aliasem, z tą samą opcją co
        <em>cp</em> czy <em>mv</em>. Aby usunąć cały katalog wraz
        podkatalogami, należy użyć kolejno opcji <em>-r</em> -
        uruchamiającej usuwanie rekurencjne oraz opcji <em>-f</em>,
        wymuszające odpowiedź <em>y</em> na wszystkie pytania
      </p>
<pre class="code-block">
[root@server1 ~]# rm -rf /tmp/etc
</pre>
      <p>
        Usuwanie plików i katalogów posiadając uprawnienia superużytkownika,
        może skończyć się katastrofą. Pomyłka w tym poleceniu może uszkodzić
        system. Dlatego też należy zachować szczególną ostrożność przy
        korzystaniu z tego polecenia, a w szcególności w połączeniu z
        <strong>nazwami wieloznacznymi</strong> (będzie o tym przy okazji
        omawiania powłoki BASH).
      </p>
      <p>
        Do usuwania pustych katalogów, możemy użyć polecenia 
        <strong>rmdir</strong>, jak i opcji <em>-d</em> polecenia <em>rm</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# rm -d dir1/
rm: remove directory 'dir1/'? y
[root@server1 ~]# rmdir dir2
</pre>
      <p class="exap_tip">
        Polecenia manipulacji plikami są podstawowymi czynnościami związnymi
        z administracją każdego Uniksa, więc warto przyswoić wiedzę zebraną
        w tym podrozdziale. 
      </p>
      <h2 id="3.5.links">3.5. Dowiązania</h2>
      <p>
        Wśród systemów uniksowych, możemy w kategoriach manipulacji plikami
        wyróżnić takie elementy jak <strong>dowiązania</strong>. Dowiązania
        są najprościej rzecz biorąc elementami, które wskazują na inne pliki.
        Dowiązania możemy podzielić na <strong>twarde</strong> oraz 
        <em>symboliczne</em>.
      </p>
      <h3 id="3.5.1.hardlinks">3.5.1. Dowiązania twarde</h3>
      <p>
        <strong>Twarde dowiązania</strong> nie są same w sobie stricte plikami.
        Pliki bowiem znajdują na urządzeniach służacych do przechowywania
        danych. Systemy plików przechowują meta-dane plików, ich atrybuty oraz
        informacje w jakich obszarch, której z pamięci masowych należy szukać
        zawartości pliku, aby ludzie mogli się nimi posługiwać używa się nazw
        plików. Taką własnie nazwą jest twarde dowiązanie. Dla eksperymentu
        utworzymy pusty plik, o nazwie <em>hard1</em>, oto jego artybuty
      </p>
<pre class="code-block">
[root@server1 ~]# ls -li hard1 
6043841 -rw-r--r--. 1 root root 0 Jun 19 17:31 hard1
</pre>
      <p>
        Pierwsza kolumna zawiera numer <strong>i-node</strong> jest to 
        identyfikator
        wpisu w bazie danych systemu plików, ktory zawiera meta-informacje na
        temat pliku. W trzeciej kolumnie atrybutów znajduje się wartość
        <code class="code-inline">1</code>. Ta kolumna przedstawia ilość
        dowiązań twardych. Każdy zwykły plik posiada co najmniej 
        dowiązanie - identyfikującą bezpośrednio plik nazwę. Tworząc kolejne
        twarde dowiązanie, podłączamy kolejną nazwę tego pliku. Teraz utworzmy
        dowiązanie o nazwie <em>hard2</em> do pliku <em>hard1</em>. Dowiązania
        towrzymy za pomocą polecenia <strong>ln</strong>.
      </p>
<pre class="code-block">
[root@server1 ~]# ln hard1 hard2
[root@server1 ~]# ls -li hard*
6043841 -rw-r--r--. 2 root root 0 Jun 19 17:31 hard1
6043841 -rw-r--r--. 2 root root 0 Jun 19 17:31 hard2
</pre>
      <p>
        Zwróć my uwagę na to, iż <code class="code-inline">hard2</code>
        wskazuje na ten sam numer <em>i-node</em>, czyli wskazuje na ten sam
        pliki. Liczba dowiązań uległa zmianie tak samo w przypadku
        <code class="code-inline">hard1</code> jak i 
        <code class="code-inline">hard2</code>, ponieważ na ten sam plik
        wskazują dwa dowiązania. Usuń my teraz plik <em>hard1</em>.
      </p>
<pre class="code-block">
[root@server1 ~]# rm hard1
rm: remove regular empty file 'hard1'? y
[root@server1 ~]# ls -li hard*
6043841 -rw-r--r--. 1 root root 0 Jun 19 17:31 hard2
</pre>
      <p>
        Można by rzec, że plik przeżył. Ponieważ nie został on bez dowiązania.
        Systemy plików, pliki bez dowiązań uznają za usunięte.
      </p>
      <h3 id="3.5.2.symlinks">3.5.2. Dowiązania symboliczne</h3>
      <p>
        Innym rodzajem dowiązań są <strong>dowiązania symboliczne</strong>, są
        one często porównywane do skrótów znanych z systemów Windows i tak
        na prawdę taka jest ich rola. Dowiązania symboliczne mają wskazywać
        na inne pliki. W przeciwieństwie do dowiązań twardych, te dowiązania
        są jednak odrębnymi plikami (tak jakby), posiadają one bowiem wpis
        w bazie danych systemu plików, ale w miejscu przeznaczonym na adres
        przechowywania danych pliku na dysku lub innej pamięci znajduje się
        scieżka pliku źródłowego, na który wskazuje dowiązania. Za tem tego
        rodzaju elementy mają własne atrybuty. Wielkość dowiązania
        symbolicznego zalezy od ilość znaków na ścieżce do pliku źródłowego.
        Dowiązania symboliczne tworzymy za pomocą tego samego narzędzia co
        dowiązania twarde, dodając tylko opcję <em>-s</em>.
      </p>
<pre class="code-block">
[user@server1 ~]$ ln -s symfile symlink1
[user@server1 ~]$ ls -l symlink1
lrwxrwxrwx. 1 user user 7 Jun 20 19:28 symlink1 -&gt; symfile
</pre>
      <p>
        Dowiązania symboliczne mogą być wydawać się, że są w wstanie zastąpić
        kopiowanie. Kopiując plik, odwzrowywuje się jego zwartość w innym
        miejscu na pamięci masowej, tworząc odrębny nienaruszony plik. Tworząc
        dowiązanie, podłączamy się pod istniejący już plik, który może być
        nie tylko przez użytkowników, ale też programy. Dowiązania symboliczne
        możemy użyć jak wymienionego wcześniej skrótu, chcąc zaoszczędzić
        sobie pisania długich ścieżek do odrębnych miejsc w systemie
        ewentualnie ułatwić pisanie ścieżek w skryptach oraz programach.
      </p>
      <h3 id="exec3.1">Ćwiczenie 1: Archiwa</h3>
      <p>
        Na maszynie <em>server1</em> jako zwykły użytkownik, utwórz
        skompresowane za pomocą programu <em>gzip</em> archiwum z zawartością
        katalogu <em>/etc</em>. Powtórz czynność tym razem z użyciem programu
        <em>bzip2</em>. Porównaj wielkość tych archiwów. Na koniec rozpakuj
        oba archiwa bez zaznaczania algorytmu kompresji (bez podawania
        odpowiedniej opcji).
      </p>
      <h3 id="exec3.2">Ćwiczenie 2: Praktyka z Vim-a</h3>
      <p>
        Na maszynie <em>server1</em> jako zwykły użytkownik, utworz przepisując
        treść ćwiczenia nr. 1, każde zdanie w odrębnej linii, zapisz zmiany w 
        pliku o nazwie <em>vimpractice</em> i zamknij edytor. Otwórz plik w
        edytorze ponownie, wyświetl numery linii. Skopiuj linię 2 i 3 na koniec
        pliku, tak aby było łącznie 6 linii. Przenieś linię nr. 3 w miejsce
        pierwszej. Przejdź na koniec pliku i dodaj do niego zawartośc w pliku
        <em>.bash_profile</em> (znajdziesz go w katalogu domowym użytkownika).
        Zamień wszystkie wszystkie wystąpienia słowa <em>profile</em> na
        <em>pro file</em>. Usuń linię od 5 do 8, zapisz zmiany w pliku i
        opuść edytor. Na koniec wyświetl podsumowanie pliku za pomocą polecenia
        <em>wc</em>.
      </p>
      <h3 id="exec3.3">Ćwiczenia 3: Manipulacja plikami</h3>
      <p>
        Na maszynie <em>server1</em> jako zwykły użytkownik, utwórz jeden
        dowolny plik oraz jeden katalog, wyświetl ich atrybuty, sprawdź
        uprawnienia, nazwę właściciela oraz grupę do której ten plik należy.
        Co się stanie gdy spróbujesz przenieć utworzony wcześniej plik do
        katalogu <em>/var/log</em>. Przenieś plik oraz katalog do katalogu
        <em>/tmp</em>. Utwórz duplikat pliku i zmień jego nazwę na jakąkolwiek 
        inną. Usuń wszystkie pliki utworzone na potrzeby tego ćwiczenia.
      </p>
      <h3 id="ch3summary">Podsumowanie</h3>
      <p>
        W tym rozdziale zapoznaliśmy się, z typowymi zadaniami związanymi z
        administracją plikami w systemie. Poznaliśmy edytor Vim, którego
        nauka wymaga zachodu, aczkolwiek nie pójdzie ona na marne. Ten edytor
        w uboższej podstawowej wersji w postaci programu <em>Vi</em> 
        spotkamy w każdym Uniksie, zatem będzie potrafili sprawnie edytować
        pliki w każdym systemie, niezależnie od tego czy nasz ulubiony edytor
        jest dostępny. Ciekawszą rzeczą w tym rodziale z pewnością były 
        dowiązania symboliczne. W następnym rodziale skupimy się na
        uprawnieniach plików i katlogów, oraz przekonamy się jak potężnym
        narzędziem jest polecenie <em>find</em>.
      </p>
		</div>
	  <p style="margin: 15px; padding: 0; outline: 0;">
				2022; COPYLEFT; ALL RIGHTS REVERSED;
		</p>
	</body>
</html>
