<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<style>
			.code-block {
				display: block;
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
				text-align: left;
			}
			.code-inline {
				background-color: silver;
				font-family: monospace;
				font-weight: bolder;
			}
			ul {
				text-align: left;
			}
		</style>
	</head>
	<body style="font-family: monospace;" >
<pre>
 ____          _ _   _       _   
|  _ \ ___  __| | | | | __ _| |_ 
| |_) / _ \/ _` | |_| |/ _` | __|
|  _ &lt;  __/ (_| |  _  | (_| | |_ 
|_| \_\___|\__,_|_| |_|\__,_|\__|
                                 
</pre>
    <p style="margin: 0; padding: 0; outline: 0; font-size: 18pt;">
	    &#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
    </p>
		<div style="margin-left: auto; margin-right: auto; width: 80%;">
      <h1 style="text-align: center;">RedHat - Red Hat Certified System 
        Administrator 9</h1>
      <p>
        Chcąc zmienić coś w swoim życiu postanowiłem, że zacznę od pracy.
        Dalej chciałem pracować w IT (chociaż praca szkolnego administratora
        jest porównywalna z pracą technika IT, tu ma ktoś problem z system
        tu trzeba podłączyć rzutnik, szczerze to znudziła się praca tego 
        typu), tylko na innym stanowisku. Dobrze czułem się pracując z
        Linuksem, to była moja pasja. Znałem dwa stanowiska na których 
        mógłbym pracować: Linux System Administrator lub Linux System
        Engineer. Teraz na rynku pracy jeśli chodzi o IT ważniejsze są 
        uzyskane certyfikaty i kursy niż wykształcenie. Szukając certyfikatów,
        które spowodują większe szanse na zatrudnienie, znalazłem dwa.
        Linux Fundation oraz Red Hat. Po przeczytaniu postu a na Reddit
        doszedłem do wniosku, że lepszym wyborem będzie Red Hat. Jeśli
        chodzi o produkcyjne wykorzystanie Linuksa to prym wśród firm
        wiedzie Red Hat lub jego darmowy odpowiednik. Kiedyś CentOS ale
        obecnie może być to zarówno Rocky Linux lub Alma Linux, oba są
        pochodnymi Red Hat. Szukając jakiś materiałów w internecie, które
        pomogły by mi się przygotować natrafiłem na Amazonie na książke
        Asghar Ghori pt. <em>RHCSA Red Hat Enterprise Linux 8 (UPDATED): 
        Training and Exam Preparation Guide (EX200), Second Edition</em>
        zamówiłem ją na swojego Kindla i zacząłem przygotowywać się do
        egzaminu. 
      </p>
      <h2>Egzamin</h2>
      <p>
        Egzamin EX200 dający uprawnienia Red Hat Certified System
        Administrator jest egzamin praktycznym sprawdzającym umiejętność
        instalacji, konfiguracji oraz rozwiązywania podstawowych problemów
        administracyjnych na dystrybucji Red Hat. Egzamin będzie odbywać
        się w postaci elektronicznej i zdający będzie mięć do dyspozycji
        dwie maszyny wirtualne do wykonania zadania egzaminacyjnego. Takie
        też środowisko przygotujemy sobie do nauki. Na dzień 11 listopada
        2020 (tak jak podaje książka) egzamin obejmować 69 zagadnień jednak
        ta liczba, ze względu na rozwój technologii jak i samego Red Hata
        mogła ulec już zmianie.
      </p>
      <h2>Zagadnienia</h2>
      <p>
        Zagadnienia używane na egzaminie mogą cały czas ewoluować. Na
        poniższej stronie zostały one opisane.
        <a href="http://www.redhat.com/training/courses/ex200/examobjective">http://www.redhat.com/training/courses/ex200/examobjective</a>. Obecnie egzamin zadawany jest na
        RHEL 9, wydany 17 maja 2022. Dość istotną zmianą w produkcji tego
        systemu jest zmiana <em>upstreamu</em>. Ta wersja Red Hat nie jest
        już oparta na Fedorze tak jak wszystkie do tej pory, ale na CentOS
        Stream (wersja non-stream tej dystrybucji nie jest już dostępna stąd
        rozbicie społeczonościowych dystrybucji do zastosowań produkcyjnych na
        Rocky oraz Alma Linux) i tej wersji będziemy użwać na maszynach
        wirtualnych.
      </p>
      <h2>Przygotowania</h2>
      <p>
        Kiedy uznałem, że chce zdobyć RHCSA, uzyskałem Red Hat na zasadzie
        <em>Non-cost RHEL Individual Developer Subscription</em>, gdzie
        istotne informacje znajdują się na stronie podanej poniżej.
        <a href="https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux">https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux</a>
        Przy użyciu tej subskrypcji uzyskamy dostęp do Red Hat przez rok na
        16 instalacji (bez znaczenia czy to fizyczny komputer, czy maszyna
        wirtualna). Po tym czasie należy zalogować się ponownie, zakceptować
        warunki umowy i po 15 do 30 minut powinnimy uzyskać ponowny rok
        subskrypcji i tak co roku. Wszystko jest opisane na powyższej stronie.
        System w wersji 8.6 (ponieważ na wersję 9.0, moim zdaniem jest
        za wcześnie, kiedyś zainstalowałem RHEL 8 na laptopie to non stop
        otrzymywałem jakieś raporty o błedach) zainstalowałem na komputerze
        codziennego użytku w pracownii. Najlepszym sposobem na nauczenie się
        administracji systemu jest jego używanie, a że jest entuzajstą a nie
        profesjonalistą, mój kontakt z systemami tego typu jest raczej dość
        mocno ograniczony. Dlatego też przesiadłem się na RHEL, póki co ten
        system poprostu działa, wcześniej korzystałem z Fedory 35 oraz
        Debiana 11. Do celów dydaktycznych potrzebujemy peceta lub laptopa
        z min. procesorem dwurdzeniowym, 8GB pamięci operacyjnej oraz 27GB
        wolnej przestrzeni na dysku na potrzeby utworzenia maszyn wirtualnych
        z wymagną przez ćwiczenia przestrzenią dyskową oraz możliwością
        wirtualzacji 64-bitowych systemów. Do tego celu 
        użyjemy oprogramowania Oracle VirtualBox, dającego najprostszy
        interfejs do interakcji z maszynami, gdyż przy późniejszych
        zagadnienia będziemy musieli zmienić jej ustawienia lub dodać kilka
        urządzeń, oczywiście jeśli ktoś czuje się mocny w innych środowiskach
        może użyć swojego ulubionego, nie mniej jednak w trakcie nauki będzie
        trzeba dokonać kilku zmian w na tych maszynach, a opisy zamieszczone
        tutaj będą dotyczyć głównie VirtualBox. Czy ktoś zainstaluje na swoim 
        komputerze RHEL czy nie to
        już indywidualna sprawa i nie wypłynie ona wykonanie ćwiczeń. Nie
        mniej jednak, w podpunkcie onośnie maszyn wirtualnych tego rodziału
        przedstawie skrypt powłoki, który po uruchomiony będzie tworzyć
        automatycznie maszyny wymagane do wykonania ćwiczeń. Ale póki co 
        przedstawie teraz instalacje Oracle VirtualBox na RHEL 8.6.
      </p>
      <h3>Instalacja Oracle VirtualBox na RHEL 8.6</h3>
      <p>
        Pierwszą czynnością jest uruchomienie przeglądarki i przejście pod
        adres: <a href="https://www.virtualbox.org/wiki/Linux_Downloads">https://www.virtualbox.org/wiki/Linux_Downloads</a>, na samym dole strony znajdują się pliki repozytorium
        dla kilku dystrybucji Linuksa. Pobieramy ten przeznaczony dla RHEL
        następnie przenosimy go do wskazanego na stronie katalogu. Następnie
        możemy wydać polecenie:
      </p>
<pre class="code-block">
$ sudo yum install VirtualBox
</pre>
      <p>
        Po instalacji, przełączamy się w terminalu na użytkownika <em>root</em>.
        Następnie wydajemy poniższe polecenia:
      </p>
<pre class="code-block">
$ sudo su
# akmods
Checking kmods exist for 4.18.0-372.9.1.el8.x86_64         [  OK  ]
# systemctl restart vboxdrv.service
</pre>
      <p>
        Teraz Oracle VirtualBox jest gotów do działania.
      </p>
      <h3>Pozyskanie obrazu ISO z Red Hat Enterprise Linux 9</h3>
      <p>
        Aby uzyskać takowy obraz musimy zarejestrować się w subskrypcji dla
        indywidualnych deweloperów. Przechodzimy na stronę <a href="https://developers.redhat.com/register">https://developers.redhat.com/register</a> i rejestrujemy się. Następnie
        logujemy i po zalogowaniu przechodzimy na stronę: <a href="https://developers.redhat.com/products/rhel/download">https://developers.redhat.com/products/rhel/download</a>.
        w sekcji <em>All Downloads</em> znajdują się wszystkie dostępne wersje
        Red Hat objęte jeszcze wsparciem. Nas będzie interesować wyłącznie
        wersja 9 i tą też pobieramy, oczywiście dla architektury <em>x86_64</em>
        w wersji DVD.
      </p>
      <h3>Tworzenie maszyn wirtualnych VirtualBox z RHEL</h3>
      <p>
        Tworzenie maszyn wirtualnych VirtualBox, nie jest zaganieniem
        egzaminacyjnym. Na egzaminie dostaniem dostęp do dwóch zdalnych
        maszyn. Teoretycznie można by użyć fizycznych maszyn o ile ktoś ma
        do takowych dostęp, jednak do drugiej maszyny trzeba dodać aż 7 dysków,
        więc użycie wirtualki, to chyba jedyne efektywne rozwiązanie. Poniżej
        znajdują się wymagania jakie powinna spełniać każda z nich:
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
          <ul>
            <li>64-Bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor,</li>
            <li>1024 MB pamięci operacyjnej,</li>
            <li>10GB dysk twardy, wyłącznie na instalacje systemu,</li>
            <li>Karta sieciowa ustawiona na bridged.</li>
            <li>Nazwa hosta ustawioną na server1.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
        <li><strong>RHEL9-VM2</strong>:
          <ul>
            <li>64-bitowy Red Hat Enterprise Linux 9.0,</li>
            <li>1 wirtualny procesor</li>
            <li>2048 MB pamięci operacyjnej</li>
            <li>10 GB dysk twardy, na instalacje systemu</li>
            <li>4 x 250 MB dysk twardy, dla ćwiczeń z LVM</li>
            <li>1 x 4 GB dysk twardy, dla ćwiczeń z VDO</li>
            <li>1 x 1 GB dysk twardy, dla ćwiczeń ze Stratis</li>
            <li>Nazwa hosta ustawioną na server2.example.com</li>
            <li>Stały adres IP, pozwalający na swobodną komunikację w sieci</li>
          </ul></li>
      </ul>
      <p>
        Maszyny możemy utworzyć ręcznie, podąrzając za wskazówkami przewodnik,
        w przypadku drugiej maszyny dodatkowe dyski trzeba będzie dodać z
        poziomu ustawień maszyny. Drugą możliwością jest skorzystanie z dwóch
        poniższych skryptów kolejno dla
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM1";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;
$vboxmanage storagectl $vmname --name SATA0 --add sata;

$vboxmanage modifyvm $vmname --memory 1024;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 1 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";
</pre>
        </li>
        <li><strong>RHEL9-VM2</strong>:
<pre class="code-block">
#!/bin/bash

vboxmanage=$(which vboxmanage);
vmname="RHEL9-VM2";
bridged_if="wlp1s0";

$vboxmanage createvm --name $vmname --ostype RedHat_64 --register;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/OS.vdi" --size \
10240 --format VDI --variant Standard;

$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/VDO.vdi" --size \
4096 --format VDI --variant Standard;
$vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/Stratis.vdi" \
--size 1024 --format VDI --variant Standard;

$vboxmanage storagectl $vmname --name SATA0 --add sata;
$vboxmanage modifyvm $vmname --memory 2048;
$vboxmanage modifyvm $vmname --graphicscontroller vmsvga;
$vboxmanage modifyvm $vmname --nic1 bridged;
$vboxmanage modifyvm $vmname --bridgeadapter1 $bridged_if;

$vboxmanage storageattach $vmname --storagectl SATA0 --port 0 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/OS.vdi";

i=1;
while [ $i -le 4 ]; do
  $vboxmanage createhd --filename "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi" --size \
  250 --format VDI --variant Standard;
  $vboxmanage storageattach $vmname --storagectl SATA0 --port $i --type hdd --medium \
  "$HOME/VirtualBox VMs/${vmname}/LVM${i}.vdi";
  i=$((i + 1));
done

$vboxmanage storageattach $vmname --storagectl SATA0 --port 5 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/VDO.vdi";
$vboxmanage storageattach $vmname --storagectl SATA0 --port 6 --type hdd --medium \
"$HOME/VirtualBox VMs/${vmname}/Stratis.vdi";

$vboxmanage storageattach $vmname --storagectl SATA0 --port 7 --type dvddrive \
--medium "$HOME/Pobrane/rhel-baseos-9.0-x86_64-dvd.iso";

</pre>
        </li>
      </ul>
      <p>
        Powyższe skrypt są również dostępne na moim profilu na github-ie. Pod
        poniższymi linkami.
      </p>
      <ul>
        <li><strong>RHEL9-VM1</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM1.sh</a></li>
        <li><strong>RHEL9-VM2</strong>:<a href="https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh">https://github.com/xf0r3m/docs/raw/main/RHCSA/RHEL9-VM2.sh</a></li>
      </ul>
      <p>
        Korzystając ze skryptów <strong>należy pamiętać o zmianie intefejsu
        sieciowego</strong> wykorzystywanego do mostkowania. Zmienna
        <code class="code-inline">bridge_if</code>.
      </p>
      <p>
        Po utworzeniu maszyn przyszedł czas na instalację.
      </p>
      <h3>Instalacja Red Hat Enterprise Linux 9.0</h3>
      <p>
        Zaraz po uruchomieniu maszyny rozpocznie się proces ładowania
        zawartości płyty. Menu bootowania płyty zwiera trzy opcje. 
      </p>
      <ol>
        <li><em>Install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Test this media & install Red Hat Enterprise Linux 9.0</em></li>
        <li><em>Troubleshooting</em></li>
      </ol>
      <p>
        Domyślnie zaznaczoną jest opcja numer 2. Mamy minutę na zmianę
        decyzji. Naciśnięcie dowolnego klawisza zatrzymuje odliczanie. Dając
        nam czas do namysłu, jednak na ten moment nie co za bardzo rozmyślać
        dlatego też wybieramy opcję numer 1. Po wybraniu tej opcji nastąpi
        uruchomie systemu oraz instalatora. Instalator używany przez RHEL oraz
        jemu pochodne nazywa się <strong>Anaconda</strong>. Swoje działanie
        rozpoczyna jeszcze w trybie tekstowym, następnie domyślnie uruchamia
        tryb graficzny, gdzie odbywa się konfiguracja a następnie instalacja.
        Nie mniej jednak instalacja w trybie tekstowym jest również możliwa.
        Podczas instalacji, poza głównym instalatorem będziemy mieć do
        dyspozycji 
        multipekser terminala, który do momentu uruchomienia właściwego 
        instalatora (w wersji graficznej) był główną konsolą. W multiplekserze
        będzie my mieć dostęp do komunikatów diagnostyczny, które w wersji 8
        RHEL był wyświetlane na oddzielnych konsolach; kilka powłok z
        uprawnieniami superużytkownika (uruchomione na konsolach 2, 3 i 5) 
        oraz konsolę z komunikatami przechwytywanymi przez główny 
        rejestrator systemu <em>syslog</em>. Udostępnienie tych funkcjonalności
        podczas instalacji systemu, może pomóc w ewentualnym namierzeniu i
        naprawie problemów z instalacją.
        Pliki z komunikatami na czas instalacji przechowywane są w katalogu 
        <em>/tmp</em>, poinstalacji zostaną one przeniesione do katalogu
        <em>/var/log/anaconda</em>. Według mnie jest dość przydatna
        funkcjonalność, ponieważ na podstawie czasu modyfikacji tych plików
        możemy dowiedzić się kiedy system został zainstalowany. Poniżej
        znajduje się lista, opisująca za co odpowiada konkretna konsola
        (kolejny ekran, dostępny po naciśnięciu klawiszy Ctrl + Alt + F1 - F6).
      </p>
      <ul>
        <li><strong>CTLR + ALT + F1</strong> - multiplekser terminala,</li>
        <li><strong>CTRL + ALT + F2</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F3</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F4</strong> - komunikaty diagnostyczne
            rejestrator <em>syslog</em>.</li>
        <li><strong>CTRL + ALT + F5</strong> - powłoka z dostępem do root,</li>
        <li><strong>CTRL + ALT + F6</strong> - tryb graficzny.</li>
      </ul>
      <p>
        Instalacja Red Hat Enterprise Linux rozpoczyna się od wyboru języka
        procesu instalacji. Chcąc pracować już w takim prawowitym IT, należy
        posługiwać się językiem angielskim i to technicznym. Systemy z którymi
        zderzmy się w potencjalnej raczej będą systemami o zasięgu
        międzynarodowym, prawdopodobnie już o tym wspominałem ale egzamin
        pozwalający uzyskać certyfikacje RHCSA również będzie po angielsku.
        Dlatego też instalować jak i korzystać z systemu będziemy w języku
        angielskim, na pierwszym ekranie wybieramy <em>English</em>
        pozostawiając wariant <em>English (United States)</em>. Następnym
        ekranem jest <em>Installation Summary</em> (lewy górny róg), jest tak
        jakby pulpit programu instalacyjnego, na nim występują komponenty,
        które możemy skonfigurować. W wersji 9.0, te komponenty są podzielone
        na 4 sekcje: <em>Localization</em>, <em>Software</em>, <em>System</em>
        oraz <em>User Settings</em>. W pierwszym procesie instalacji,
        przejdziemy przez wszystkie z nich.
      </p>
      <p>
        Zwróć my uwagę na to, iż system sam dokonał wstępnej konfiguracji
        instalatora, na pozostało jedynie sprawdzić oraz skonfigurować tylko
        te opcje oznaczone znakiem ostrzegawczym oraz czerwoną podpowiedzią po
        ich konfiguracji program umożliwi nam zainstalowanie systemu.
      </p>
      <p>
        W sekcji lokalizacyjne do ustawienia są takie opcje, układ klawiatury,
        język, oraz data i czas. Podczas ładowania pierwszego okna (moment 
        wybrania języka instalacji), instalator na podstawie informacji GeoIP
        postara się określić naszą przybliżoną lokalizację, o ile posiada on
        na tym momencie połączenie z internetem. Dlatego też możemy
        spotkać się z samoinstnie wybranym języku instalacji ustawionym na
        Polski. Język został zmieniony, ale wybrana strefa czasowa może
        pozostać, wręcz powinna. Dzięki tej funkcji możemy zaoszczędzić czas,
        i przejść do kolejnej sekcji.
      </p>
      <p>
        Kolejną sekcja dotyczy oprogramowania, tutaj konfigurowane będzie
        na przykład połączenie z firmą Red Hat. RHEL jest system 
        licencjonowanym i jeśli chcemy skorzystać z oficjalnych repozytoriów
        należy "podłączyć" system do naszego konta założonego w celu
        pozyskania obrazu płyty. Jednak na razie nie trzeba tego, będzie to
        do zrobienia na późniejszych etapach nauki administracji systemu.
        Kolejną opcją jest <em>Installation Source</em>, konfigurąc tę opcję 
        możemy
        wybrać czy będzięmy korzystać pod czas instalacji z obrazu płyty lub
        sieciowego repozytorium lub Red Hat CDN. Z racji tego, iż ściągneliśmy 
        pełny obraz
        ważący kilka gigabajtów, nie ma sensu używać instalacji sieciowej.
        Tego typu źródło instalacji należy wybrać w momencie gdy pobraliśmy
        minimalistyczną wersję obrazu, dlatego też zostaniemy przy standardowym
        wyborze <em>Local media</em>. Ta opcja pozwala też na dodanie podczas
        instalacji dodatkowego repozytorium, jednak na tym etapie nie będziemy
        się tym zajmować. Ostanią opcją z tej sekcji jest <em>Software
        selection</em>, ta opcja daje nam możliwość, wyboru rodzaju instalacji.
        Na potrzeby nauki, wybierzemy opcję <em>Server with GUI</em>, jeśli
        będziemy instalować RHEL na naszym komputerze do codziennego użytku
        możemy wybrać <em>Workstation</em>. Wybierając rodzaj instalacji po
        lewej stronie, po prawej wyświetają się dodatkowe pakiety lub
        warianty do zainstalowania.
      </p>
      <p>
        Sekcja <em>System</em>, służy głównie do wyboru docelowego miejsca dla
        instalacji za pomocą opcji <em>Instalation Destination</em>, gdzie
        wskazujemy docelowy dysk do instalacji, możemy go spartycjonować 
        ręcznie jak utworzyć lub utworzyć szyfrowany wolumin. Toworząc
        szyfrowany wolumin, bardzo ważny jest układ klawiatury. Innymi opcjami
        póki co dla nas ważnymi jest <em>Network &amp; Host name</em>, w
        założeniach zadania, może być wymagane ustawienie odpowiedniego adresu
        oraz nazwy dla maszyny. Tak jest w naszym przypadku, to te opcje
        ustawiamy właśnie tam. Pozostałe opcje tej sekcji, poki co nie są
        dla nas istotne.
      </p>
      <p>
        Ostatnia sekcja ustawia hasło dla superużytkownika oraz tworzą konto
        dla pierwszego użytkownika. Nie musi on posiadać uprawnień
        administratora i nie będzie ich miał. Opcja utworzenia użytkownika
        może się nie mieścić na ekranie, podczas instalacji systemu maszynie
        witualnej, dlatego nie należy przjmować, że jej nie ma.
      </p>
      <p>
        Teraz kiedy wszyskie (te istotne dla instalacji) zostały opisane możemy
        zainstalować system zgodnie założeniami pierwsze maszyny i powtorzyć
        to na drugiej. I to jest pierwsze ćwiczenie.
      </p>
      <h3>Ćwiczenie 1: Instalacja Red Hat Enterprise Linux 9</h3>
      <p>
        Zainstaluj zgodnie założeniami podanymi w podrozdziale 
        <em>Tworzenie maszyn wirtualnych VirtualBox z RHEL</em> oraz sugestiami
        podanymi podczas opisu procesu instalacji. Red Hat
        Enterprise Linux 9 na maszynie wirtualnej <em>RHEL-VM1</em>. Następnie
        powtórz tę czynność drugiej maszynie przeznaczonej do laboratorium.
        Pamiętaj, że założenia dla drugiej maszyny różnią się.
      </p>
      <h3>Ćwiczenie 2: Logowanie zdalne do RHEL</h3>
      <p>
        Wykorzystując program do obsługi protokołu SSH dla twoje systemu
        operacyjnego zaloguj się na superużytkownika. Pamiętaj o tym, że
        bezpośrednie logowanie na superużytkownika wymagało zaznaczenia opcji
        podczas ustawiania hasła dla niego.
      </p>
      <h2>Podsumowanie</h2>
      <p>
        W tym rozdziale przezszliśmy przez proces instalacji RHEL.
        Dowiedzielśmy się, że możliwe jest instalacja w trybie tekstowym oraz
        oraz, że nienależy ona do najtrudniejszych. Warto zwrócić uwagę na to
        iż jeśli do tej pory korzystaliśmy z jakiś materiałów to dotyczą one
        wersji 8 RHEL, my będziemy korzystać z wersji 9, bo to na niej w 2022
        roku będziemy zdawać egzamin, a między tymi wersjami jest kilka zmian.
        W następnym rozdziale zapoznamy się z środowiskiem graficznym,
        strukturą katalogów oraz podstawowym narzędziami do pracy w powłoce.
      </p>
      <h1>2. Poruszenia się po systemie RHEL 9</h1> 
      <p>
        Wykonując ćwiczenia z pierwszego rozdziału, zainstalowaliśmy sobie
        Red Hat w wersji 9 na maszynie wirtualnej. Jako wariant wyboru
        oprogramowania wybraliśmy <em>Server with GUI</em> i od drobnego
        omówienia środowiska graficznego rozpocznę ten rodział.
      </p>
      <h2>2.1. Środowisko graficzne RHEL 9</h2>
      <p>
        Red Hat jest dystrybucją Linuksa przeznaczoną do zastosowań
        produkcyjnych, więc system tego typu musi wykazywać się dużą
        stabilnością. Znaczące zmiany są wprowadzane raczej w dużych wydania
        jak RHEL 9, takim znaczącym przeskokiem jest zmiana linii jądra z
        4.18 (w przypadku RHEL 8) na 5.14 (w przypadku RHEL 9) oraz zastąpienie
        klasycznego serwera X Window protokołem Wayland, to jednak nastąpiło z
        wydaniem RHEL 8. Zmiany w RHEL 9, odnośnie środowiska graficznego
        to przejście z Gnome 3.38 na Gnome 40, ta zmiana przyniosła również
        odświerzenie menedżera wyświetlania lub menedżera logowania czym w
        przypadku środowiska Gnome jest GDM. Większość elementów pozostała
        taka sama na górnej belce mamy datę oraz czas w prawyn górnym rogu
        do wyboru opcje ułatwień dostępu, wskaźnik połączenia sieciowego oraz
        porozwinięciu możliwość regulacji głośności i jasności ekranu oraz 
        wyłączenia komputera. Wiecej opcji w tym miejscu pojawi się dopiero 
        po zalogowaniu, będzie można zmienić kilka ustawień jak np. sieć
        bezprzewodwą. Zmianie uległ również sposób prezentacji kont użytkownika.
        Z racji tego iż <em>root</em> nie jest zwykłym użytkownikiem nie będzie
        pojawiać się na liscie, ale zalogowanie na niego jest możliwe za pomocą
        kliknięcia w "Not Listed?" pod listą użytkowników, wówczas będzie mogli
        ręcznie podać nazwę użytkownika oraz hasło. Ekranem startowym po
        zalogowaniu jest ekran <em>Activities</em>, który pozwala na podgląd
        wykonywanych czynności, rozpoczęcie nowych (wybierają aplikacje z 
        z doka lub z pełnej listy aplikacji, która jest dostępna po kliknięciu
        na ikonę 9 kropek w doku) oraz przełacznie się między obszarami
        roboczymi. Domyślnie GNOME daje dostęp do dwóch przestrzeni roboczych,
        gdy tylko przeniesiemy aplikację do na nowy obszar, GNOME udostępni
        nam kolejny i tak dalej. Wyszukiwarka nad podgląd obszaru roboczego
        daje możliwość wyszukiwania nie tylko aplikacji ale także ustawień co
        jest raczej normą w GNOME od wersji 3. Na doku znajdują się ulubione
        aplikacje, które możemy usuwać i dodawać za pomocą PPM i następnie
        wybierając dodaj lub usuń z ulubionych.
      </p>
      <h2>2.2. Struktura katalogowa w uniksach</h2>
      <p>
        Zanim jednak przjedziemy do obsługi wiersza polecenia omówimy sobie
        hierachiczną strukturę katalogów, która występuje nie tylko w RHEL ale
        i w innych uniksach, ponieważ HFS (<em>ang. Hierarchy File System</em>)
        jest ogólnym standardem. Na uniksach możemy spotkać się z trzema typami
        systemów plików.
      </p>
      <ul>
        <li><strong><em>Disk-based</em> - dyskowe</strong> - są to klasyczne
          pliki i katalogi przechowywane bezpośrednio na dysku.</li>
        <li><strong><em>Network-based</em> - sieciowe</strong> - są to udziały
          podmontowane w naszych systemach za pomocą róznych protokołów, nie
          tylko SMB.</li>
        <li><strong><em>Memory-based</em> - wirtualne</strong> - te systemy
          plików są tworzone przez procesy potrzeby działania systemu, takim
          systemem może być katalog <em>/dev</em> lub <em>/tmp</em>. Ich
          trwałość często zależy od tego jak długo system pozostaje włączony
          lub od wewnętrznych ustaleń samego systemu.</li>
      </ul>
      <p>
        Struktura plików i katalogów na uniksach ma postać odwrócone drzewa.
        Korzeń (katalog główny) znajduje się na szczycie struktury i odniego
        rozchodzą się poszczególne gałęzie (podkatalogi), gałęzię mogą zawierać
        kolejne rozgałezienia i tworzyć całe struktury, na gałęziach
        znajdują się również liscie czyli pliki i na liściach struktura się
        kończy.
      </p>
      <p>
        Dostęp do konkretnych plików i katalogów w strukturze określany jest
        za pomocą ścieżek. Scieżki określają położenie plików i katalogów
        wewnątrz HFS.
        Separatorem elementów ścieżki (posczególnych pod katalogów), jest
        ukośnik, slash (<strong>/</strong>).
      </p>
      <p>
        Podczas pracy z elemtami systemu plików, jakim są foldery oraz katalogi
        możemy spotkać <strong>scieżki bezwzględne</strong> zaczynające się od
        katalogu głównego, lub <strong>ściezki względne</strong> zaczynające
        się od następnego elementu znajdującego w obecnym katalogu robocznym
        (tym katalogu, w którym się obecnie znajdujemy).
      </p>
      <p>
        Katalog główny jest miejscem do przechwywania wszystkich plików, jakie
        znajdują się w systemie, jest pierwszy element znajdujący się na
        ścieżce (bezwzględnej) i oznaczny jest on poprostu ukośnikiem
        (<strong>/</strong>), od tego katalogu zaczyna się cała struktura.
        Poniżej znajduje się lista najważniejsych podkatalogów katalogu
        głównego, każdy z nich ma swoje znaczenie w systemie.
      </p>
      <ul>
        <li><strong>/boot</strong> (<em>disk-based</em>) - katalog ten
            przedchowuje jądro, <em>initramfs</em> oraz konfiguracje programu
            rozruchowego.</li>
        <li><strong>/dev</strong> (<em>memory-based</em>) - katalog ten
            przechowuje pliki urządzeń służące do odwoływania się do
            rzeczywistego sprzętu podczas komunikacji. Pliki te są tworzone
            przez usługę <em>udevd</em> podczas podłączania urządzenia oraz
            rozruchu systemu.</li>
        <li><strong>/etc</strong> (<em>disk-based</em>) - skrót <em>etc</em>
            możemy rozwinąć do <em>ang. etcetera</em> lub <em>ang. extended
            text configration</em>. Jest to miejsce do przechwywania plików
            konfirugracyjnych różnych programów.</li>
        <li><strong>/home</strong> (<em>disk-based</em>) - ten katalog
            przechowuje, katalogi domowe użytkowników.</li>
        <li><strong>/opt</strong> (<em>disk-based</em>) - katalog przeznaczony
            na dodatkowe oprogramowanie instalowane w systemie.</li>
        <li><strong>/proc</strong> (<em>memory-based</em>) - wirtualna 
            struktura podkatalogów, zawierająca informacje o procesach oraz
            różne informacje o systemie, np. informacje o procesorze.</li>
        <li><strong>/run</strong> (<em>memory-based</em>) - katalog
            przechowywujący pliku wykorzystywane przez procesy podczas
            wykonywania ich czynności. W tym katalogu znajduje się również
            podkatalog <em>media</em> zawierący punkt monotowania automatycznie
            montowanych w systemie dysków wymiennych.</li>
        <li><strong>/sys</strong> (<em>memory-based</em>) - katalog
            przechowuje informacje o urządzeniach, sterownikach. Pewne
            funkcjonalności jądra również są zawarte w tym katalogu. Informacje
            z tego katalogu są używane przez jądro obsługi urządzeń.</li>
        <li><strong>/tmp</strong> (<em>memory-based</em>) - miejsce 
            przechowywania plików tymczasowych okres przechowywania tych 
            plików to 10 dni, lub ponowne uruchomienie komputera.</li>
        <li><strong>/usr</strong> (<em>disk-based</em>) - skrót <em>usr</em>,
            należy rozwinąć jako <em>ang. UNIX System Resources</em>. Ten
            katalog jest kolejną dużą strukturą katalogów w systemie. W tym
            katalog przechowywane są wszystkie programy, więc wiekszość 
            systemu. Na poniższej liście znajdują się rozpisane podkatalogi
            tego katalogu:
            <ul>
              <li><strong>/usr/bin</strong> - katalog przechowuje większosć
                  plików binarnych, wykorzystywanych w systemie, programy oraz
                  polecenia.</li>
              <li><strong>/usr/sbin</strong> - narzędzia administracyjne
                  niedostępne dla zwykłych użytkowników, poza kilkoma
                  programami. Ten katalog często nie jest ujęty podczas 
                  wyszuiwania poleceń.</li>
              <li><strong>/usr/lib</strong>, <strong>/usr/lib64</strong> - 
                  biblioteki współdzielone oraz pliki statyczne, nie których
                  programów typu init.</li>
              <li><strong>/usr/include</strong> - pliki nagłówkowe języka C</li>
              <li><strong>/usr/local</strong> - miejsce przechowywania
                  zewnętrznych programów administracyjnych instalowane i
                  wykorzystywane przez administatorów, ten katalog zawiera w
                  sobie podobną strukturę katalogą jak sam <em>/usr</em>.</li>
              <li><strong>/usr/share</strong> - miejsce przechowywania stron
                  podręcznika, dokumentacji czy przykładowych plików 
                  konfiguracyjnych.</li>
            </ul>
        </li>
        <li><strong>/var</strong> (<em>disk-based</em>) - katalog na zmienne
            dane, katalog podobnie do <em>/usr</em> ma wewnątrz wiele znaczący
            podkatalogów, których opis znajduje się poniżej:
            <ul>
              <li><strong>/var/log</strong> - katalog na pliki dzienników,
                zbierane nie tylko z głównego rejestratora, ale i funkcji
                rejestrowania utrzymwane przez same usługi.</li>
              <li><strong>/var/opt</strong> - katalog na zmienne dane
                oprogramowania instalowanego w katalogu <em>/opt</em></li>
              <li><strong>/var/spool</strong> - katalog ten przechowuje dane
                zanim zostaną przekazane lub pobrane przez właściwe komponenty.</li>
              <li><strong>/var/tmp</strong> - katalog przechowuje duże pliki
                tymczasowe. Pliki przeżywają uruchomienie ponowne systemu.
                Czas ich istnienia w tym katalog to 30 dni.</li>
            </ul>
        </li>
      </ul>
      <p>
        Za pomocą polecenia <strong>tree</strong>, możemy wyświetlić strukturę
        katalogą w postaci drzewa, jednak najpierw nauczymy się korzystać z
        poleceń w RHEL.
      </p>
      <h2>2.3. Obsługa wiersza poleceń i najprostsze polecenia</h2>
      <p>
        Obsługa wiersza poleceń zależy w znacznym stopniu od powłoki, ponieważ
        to ona zajmuj się jego interpretacją i koniec końców wykonaniem
        programu, którego nazwę podaliśmy chcą wykonać polecenie. Aby móc
        skorzystać w RHEL z wiersza poleceń musimy albo uruchomić w środowisku
        graficznym aplikację <strong>Terminal</strong>, lub zalogować się
        zdalnie za pomocą protokołu SSH. Uruchomienie terminala lub zalogowanie
        się przez SSH uruchomi powłokę, która swoją gotowość na otrzymywanie
        poleceń obwieści wyświetleniem <strong>znaku zachęty</strong>.
      </p> 
      <p>
        Znak zachęty jest wskaźnikiem za kursorem po którym możemy wprowadzać 
        do systemu
        polecenia. Kiedyś znaki zachęty były pojedyńczymi znakmi informującymi
        o uprawnieniach z jakimi działa proces powłoki (o tym za chwilę). Teraz
        znaki zwracają nazwę użytkownika, nazwę komputera oraz obecny katalog
        roboczy wewnątrz nawiasu kwadratowego, następnie zanim znajduje się
        znak krzyżyka (<strong>#</strong>), mówiący że powłoka działa
        uprawnieniami użytkownika <em>root</em> lub symbol dolara 
        (<strong>$</strong>), mówiący że połoka działa z uprawnieniami zwykłego
        użytkownika. Poniżej przedstawiłem oba znaki:
      </p>
<pre class="code-block">
[root@server1 ~]#

[user@server1 ~]$
</pre>
      <p>
        W różnych dystrybucjach, znak zachęty może różnorako wyglądąć. Możemy
        dostować do własnych potrzeb, wiele osób korzysta z jak najmniejszych
        znaków zachęty, aby zaoszczedzić miejsce w wierszu polecenia. Teraz
        możemy już wydawać polecenia.
      </p>
      <p>
        Kazde polecenie w jakim kolwiek uniksie, składa się z nazwy polecenia,
        ewentualnych opcji oraz ewentualnych argumentów. Nie wszystkie
        polecenia do uzyskania żądanych przez nas efektów.  
      </p>
<pre class="code-block">
$ nazwa_polecenia [opcje] [argumenty]
</pre>
      <p>
        Przez cały kurs będziemy poznawać jakieś polecenia ale w tym momencie
        nauczymy się najprostszych znich.
      </p>
      <h3>2.3.1. Listowanie zawartości katalogu</h3>
      <p>
        Aby wyświetlić zawartość katalogu w powłoce, możemy użyć polecenia
        <strong>ls</strong>. Polecenie bez podania argumentu w postaci
        katalogu wyświetli zawartość folderu, w którym się znajdujemy.
        Najważniejszymi opcjami między innymi są:
      </p>
      <ul>
        <li><strong>-a</strong> - wyświetlanie wszystkich, elementów w katalogu
            także tych, które normalnie nie są wyświetlane (plik i foldery,
            których nazwa rozpoczyna się od kropki).</li>
        <li><strong>-l</strong> - wyświetlenie szczegółowych informacji na
            temat elementów. Informacja zwraca przez polecenie jest wówczas
            podzielona na 7 pól, które kolejno oznaczają: typ pliku oraz
            uprawnienia; liczbę dowiązań; nazwę użytkownika (właściciela pliku);
            nazwę grupy do której należy ten plik; rozmiar w bajtach; czas
            modyfikacji oraz nazwę elementu.</li>
        <li><strong>-ld</strong> - wyświetla szczegółową informacje na temat
            podanego jak argument katalog, bez wyświetlania jego zawartości.
            Jeśli nie podamy argumentu polecenie wyświetli informacje na temat
            bierzącego katalogu.</li>
        <li><strong>-lh</strong> - wyświetli szczegółowo informacje
            na temat elementów w katalogu, wyświetlając ich rozmiar w
            przeskalowanych wartościach, co ułatwi odczytanie go przez 
            człowieka.</li>
        <li><strong>-lt</strong> - wyświetli szczegółową listę elementów
            posortową względem czasu modyfikacji od najnowszego pliku.</li>
        <li><strong>-ltr</strong> - działanie podobne to <em>-lt</em>, ale
            odwrócone, elementy zostaną wyświetlone od najstarszego.</li>
        <li><strong>-R</strong> - wyświetlenie elementów w sposób 
            rekurencyjny. Polecenie z tą opcją wyświetli zawartość katalogów
            wraz z ich podkatalogami itd.</li>
      </ul>
      <p>
        Podczas korzystania z wielu programów możemy natknąć się na wiele opcji
        jednak one dzielą się na długie i krótkie, opcje krótkie występują w
        postaci pojedyńczego znaku poprzedzonego jednym myślnikiem
        (<strong>-</strong>). Opcje długie występuje w postaci pojedyńczego
        (najczęsciej, ponieważ to zależy od programu) poprzedzone dwoma 
        myślnikami (<strong>--</strong>). W przypadku tak prostych poleceń jak
        <em>ls</em> również możemy mieć doczynienia długi opcjami np. zamiast
        <em>-a</em> możemy użyć <em>--all</em>.
      </p>
		</div>
	  <p style="margin: 15px; padding: 0; outline: 0;">
				2022; COPYLEFT; ALL RIGHTS REVERSED;
		</p>
	</body>
</html>
